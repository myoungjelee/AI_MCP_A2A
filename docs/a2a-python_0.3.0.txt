This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.
The content has been processed where content has been compressed (code blocks are separated by ⋮---- delimiter), security check has been disabled.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: src/a2a/**/*.*
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Content has been compressed - code blocks are separated by ⋮---- delimiter
- Security check has been disabled - content may contain sensitive information
- Files are sorted by Git change count (files with more changes are at the bottom)


================================================================
Directory Structure
================================================================
src/
  a2a/
    auth/
      user.py
    client/
      auth/
        __init__.py
        credentials.py
        interceptor.py
      transports/
        __init__.py
        base.py
        grpc.py
        jsonrpc.py
        rest.py
      __init__.py
      base_client.py
      card_resolver.py
      client_factory.py
      client_task_manager.py
      client.py
      errors.py
      helpers.py
      legacy_grpc.py
      legacy.py
      middleware.py
      optionals.py
    extensions/
      common.py
    grpc/
      a2a_pb2_grpc.py
      a2a_pb2.py
      a2a_pb2.pyi
    server/
      agent_execution/
        __init__.py
        agent_executor.py
        context.py
        request_context_builder.py
        simple_request_context_builder.py
      apps/
        jsonrpc/
          __init__.py
          fastapi_app.py
          jsonrpc_app.py
          starlette_app.py
        rest/
          __init__.py
          fastapi_app.py
          rest_adapter.py
        __init__.py
      events/
        __init__.py
        event_consumer.py
        event_queue.py
        in_memory_queue_manager.py
        queue_manager.py
      request_handlers/
        __init__.py
        default_request_handler.py
        grpc_handler.py
        jsonrpc_handler.py
        request_handler.py
        response_helpers.py
        rest_handler.py
      tasks/
        __init__.py
        base_push_notification_sender.py
        database_push_notification_config_store.py
        database_task_store.py
        inmemory_push_notification_config_store.py
        inmemory_task_store.py
        push_notification_config_store.py
        push_notification_sender.py
        result_aggregator.py
        task_manager.py
        task_store.py
        task_updater.py
      __init__.py
      context.py
      models.py
    utils/
      __init__.py
      artifact.py
      constants.py
      error_handlers.py
      errors.py
      helpers.py
      message.py
      proto_utils.py
      task.py
      telemetry.py
    __init__.py
    _base.py
    types.py

================================================================
Files
================================================================

================
File: src/a2a/auth/user.py
================
"""Authenticated user information."""
⋮----
class User(ABC)
⋮----
"""A representation of an authenticated user."""
⋮----
@property
@abstractmethod
    def is_authenticated(self) -> bool
⋮----
"""Returns whether the current user is authenticated."""
⋮----
@property
@abstractmethod
    def user_name(self) -> str
⋮----
"""Returns the user name of the current user."""
⋮----
class UnauthenticatedUser(User)
⋮----
"""A representation that no user has been authenticated in the request."""
⋮----
@property
    def is_authenticated(self) -> bool
⋮----
@property
    def user_name(self) -> str

================
File: src/a2a/client/auth/__init__.py
================
"""Client-side authentication components for the A2A Python SDK."""
⋮----
__all__ = [

================
File: src/a2a/client/auth/credentials.py
================
class CredentialService(ABC)
⋮----
"""An abstract service for retrieving credentials."""
⋮----
"""
        Retrieves a credential (e.g., token) for a security scheme.
        """
⋮----
class InMemoryContextCredentialStore(CredentialService)
⋮----
"""A simple in-memory store for session-keyed credentials.

    This class uses the 'sessionId' from the ClientCallContext state to
    store and retrieve credentials...
    """
⋮----
def __init__(self) -> None
⋮----
"""Retrieves credentials from the in-memory store.

        Args:
            security_scheme_name: The name of the security scheme.
            context: The client call context.

        Returns:
            The credential string, or None if not found.
        """
⋮----
session_id = context.state['sessionId']
⋮----
"""Method to populate the store."""

================
File: src/a2a/client/auth/interceptor.py
================
import logging  # noqa: I001
⋮----
logger = logging.getLogger(__name__)
⋮----
class AuthInterceptor(ClientCallInterceptor)
⋮----
"""An interceptor that automatically adds authentication details to requests.

    Based on the agent's security schemes.
    """
⋮----
def __init__(self, credential_service: CredentialService)
⋮----
"""Applies authentication headers to the request if credentials are available."""
⋮----
credential = await self._credential_service.get_credentials(
⋮----
scheme_def_union = agent_card.security_schemes.get(
⋮----
scheme_def = scheme_def_union.root
⋮----
headers = http_kwargs.get('headers', {})
⋮----
# Case 1a: HTTP Bearer scheme with an if guard
⋮----
# Case 1b: OAuth2 and OIDC schemes, which are implicitly Bearer
⋮----
# Case 2: API Key in Header
⋮----
# Note: Other cases like API keys in query/cookie are not handled and will be skipped.

================
File: src/a2a/client/transports/__init__.py
================
"""A2A Client Transports."""
⋮----
GrpcTransport = None  # type: ignore
⋮----
__all__ = [

================
File: src/a2a/client/transports/base.py
================
class ClientTransport(ABC)
⋮----
"""Abstract base class for a client transport."""
⋮----
"""Sends a non-streaming message request to the agent."""
⋮----
"""Sends a streaming message request to the agent and yields responses as they arrive."""
⋮----
"""Retrieves the current state and history of a specific task."""
⋮----
"""Requests the agent to cancel a specific task."""
⋮----
"""Sets or updates the push notification configuration for a specific task."""
⋮----
"""Retrieves the push notification configuration for a specific task."""
⋮----
"""Reconnects to get task updates."""
⋮----
"""Retrieves the AgentCard."""
⋮----
@abstractmethod
    async def close(self) -> None
⋮----
"""Closes the transport."""

================
File: src/a2a/client/transports/grpc.py
================
logger = logging.getLogger(__name__)
⋮----
@trace_class(kind=SpanKind.CLIENT)
class GrpcTransport(ClientTransport)
⋮----
"""A gRPC transport for the A2A client."""
⋮----
"""Initializes the GrpcTransport."""
⋮----
"""Creates a gRPC transport for the A2A client."""
⋮----
"""Sends a non-streaming message request to the agent."""
response = await self.stub.SendMessage(
⋮----
"""Sends a streaming message request to the agent and yields responses as they arrive."""
stream = self.stub.SendStreamingMessage(
⋮----
response = await stream.read()
if response == grpc.aio.EOF:  # pyright: ignore[reportAttributeAccessIssue]
⋮----
"""Reconnects to get task updates."""
stream = self.stub.TaskSubscription(
⋮----
"""Retrieves the current state and history of a specific task."""
task = await self.stub.GetTask(
⋮----
"""Requests the agent to cancel a specific task."""
task = await self.stub.CancelTask(
⋮----
"""Sets or updates the push notification configuration for a specific task."""
config = await self.stub.CreateTaskPushNotificationConfig(
⋮----
"""Retrieves the push notification configuration for a specific task."""
config = await self.stub.GetTaskPushNotificationConfig(
⋮----
"""Retrieves the agent's card."""
card = self.agent_card
⋮----
card_pb = await self.stub.GetAgentCard(
card = proto_utils.FromProto.agent_card(card_pb)
⋮----
async def close(self) -> None
⋮----
"""Closes the gRPC channel."""

================
File: src/a2a/client/transports/jsonrpc.py
================
logger = logging.getLogger(__name__)
⋮----
@trace_class(kind=SpanKind.CLIENT)
class JsonRpcTransport(ClientTransport)
⋮----
"""A JSON-RPC transport for the A2A client."""
⋮----
"""Initializes the JsonRpcTransport."""
⋮----
final_http_kwargs = http_kwargs or {}
final_request_payload = request_payload
⋮----
"""Sends a non-streaming message request to the agent."""
rpc_request = SendMessageRequest(params=request, id=str(uuid4()))
⋮----
response_data = await self._send_request(payload, modified_kwargs)
response = SendMessageResponse.model_validate(response_data)
⋮----
"""Sends a streaming message request to the agent and yields responses as they arrive."""
rpc_request = SendStreamingMessageRequest(
⋮----
response = SendStreamingMessageResponse.model_validate(
⋮----
response = await self.httpx_client.post(
⋮----
"""Retrieves the current state and history of a specific task."""
rpc_request = GetTaskRequest(params=request, id=str(uuid4()))
⋮----
response = GetTaskResponse.model_validate(response_data)
⋮----
"""Requests the agent to cancel a specific task."""
rpc_request = CancelTaskRequest(params=request, id=str(uuid4()))
⋮----
response = CancelTaskResponse.model_validate(response_data)
⋮----
"""Sets or updates the push notification configuration for a specific task."""
rpc_request = SetTaskPushNotificationConfigRequest(
⋮----
response = SetTaskPushNotificationConfigResponse.model_validate(
⋮----
"""Retrieves the push notification configuration for a specific task."""
rpc_request = GetTaskPushNotificationConfigRequest(
⋮----
response = GetTaskPushNotificationConfigResponse.model_validate(
⋮----
"""Reconnects to get task updates."""
rpc_request = TaskResubscriptionRequest(params=request, id=str(uuid4()))
⋮----
response = SendStreamingMessageResponse.model_validate_json(
⋮----
"""Retrieves the agent's card."""
card = self.agent_card
⋮----
resolver = A2ACardResolver(self.httpx_client, self.url)
card = await resolver.get_agent_card(
⋮----
request = GetAuthenticatedExtendedCardRequest(id=str(uuid4()))
⋮----
response_data = await self._send_request(
response = GetAuthenticatedExtendedCardResponse.model_validate(
⋮----
async def close(self) -> None
⋮----
"""Closes the httpx client."""

================
File: src/a2a/client/transports/rest.py
================
logger = logging.getLogger(__name__)
⋮----
@trace_class(kind=SpanKind.CLIENT)
class RestTransport(ClientTransport)
⋮----
"""A REST transport for the A2A client."""
⋮----
"""Initializes the RestTransport."""
⋮----
final_http_kwargs = http_kwargs or {}
final_request_payload = request_payload
# TODO: Implement interceptors for other transports
⋮----
pb = a2a_pb2.SendMessageRequest(
payload = MessageToDict(pb)
⋮----
"""Sends a non-streaming message request to the agent."""
⋮----
response_data = await self._send_post_request(
response_pb = a2a_pb2.SendMessageResponse()
⋮----
"""Sends a streaming message request to the agent and yields responses as they arrive."""
⋮----
event = a2a_pb2.StreamResponse()
⋮----
async def _send_request(self, request: httpx.Request) -> dict[str, Any]
⋮----
response = await self.httpx_client.send(request)
⋮----
"""Retrieves the current state and history of a specific task."""
⋮----
response_data = await self._send_get_request(
task = a2a_pb2.Task()
⋮----
"""Requests the agent to cancel a specific task."""
pb = a2a_pb2.CancelTaskRequest(name=f'tasks/{request.id}')
⋮----
"""Sets or updates the push notification configuration for a specific task."""
pb = a2a_pb2.CreateTaskPushNotificationConfigRequest(
⋮----
config = a2a_pb2.TaskPushNotificationConfig()
⋮----
"""Retrieves the push notification configuration for a specific task."""
pb = a2a_pb2.GetTaskPushNotificationConfigRequest(
⋮----
"""Reconnects to get task updates."""
http_kwargs = self._get_http_args(context) or {}
⋮----
"""Retrieves the agent's card."""
card = self.agent_card
⋮----
resolver = A2ACardResolver(self.httpx_client, self.url)
card = await resolver.get_agent_card(
⋮----
card = AgentCard.model_validate(response_data)
⋮----
async def close(self) -> None
⋮----
"""Closes the httpx client."""

================
File: src/a2a/client/__init__.py
================
"""Client-side components for interacting with an A2A agent."""
⋮----
logger = logging.getLogger(__name__)
⋮----
from a2a.client.legacy_grpc import A2AGrpcClient  # type: ignore
⋮----
_original_error = e
⋮----
class A2AGrpcClient:  # type: ignore
⋮----
"""Placeholder for A2AGrpcClient when dependencies are not installed."""
⋮----
def __init__(self, *args, **kwargs)
⋮----
__all__ = [

================
File: src/a2a/client/base_client.py
================
class BaseClient(Client)
⋮----
"""Base implementation of the A2A client, containing transport-independent logic."""
⋮----
"""Sends a message to the agent.

        This method handles both streaming and non-streaming (polling) interactions
        based on the client configuration and agent capabilities. It will yield
        events as they are received from the agent.

        Args:
            request: The message to send to the agent.
            context: The client call context.

        Yields:
            An async iterator of `ClientEvent` or a final `Message` response.
        """
config = MessageSendConfiguration(
params = MessageSendParams(message=request, configuration=config)
⋮----
response = await self._transport.send_message(
result = (
⋮----
tracker = ClientTaskManager()
stream = self._transport.send_message_streaming(params, context=context)
⋮----
first_event = await anext(stream)
# The response from a server may be either exactly one Message or a
# series of Task updates. Separate out the first message for special
# case handling, which allows us to simplify further stream processing.
⋮----
task = tracker.get_task_or_raise()
update = None if isinstance(event, Task) else event
client_event = (task, update)
⋮----
"""Retrieves the current state and history of a specific task.

        Args:
            request: The `TaskQueryParams` object specifying the task ID.
            context: The client call context.

        Returns:
            A `Task` object representing the current state of the task.
        """
⋮----
"""Requests the agent to cancel a specific task.

        Args:
            request: The `TaskIdParams` object specifying the task ID.
            context: The client call context.

        Returns:
            A `Task` object containing the updated task status.
        """
⋮----
"""Sets or updates the push notification configuration for a specific task.

        Args:
            request: The `TaskPushNotificationConfig` object with the new configuration.
            context: The client call context.

        Returns:
            The created or updated `TaskPushNotificationConfig` object.
        """
⋮----
"""Retrieves the push notification configuration for a specific task.

        Args:
            request: The `GetTaskPushNotificationConfigParams` object specifying the task.
            context: The client call context.

        Returns:
            A `TaskPushNotificationConfig` object containing the configuration.
        """
⋮----
"""Resubscribes to a task's event stream.

        This is only available if both the client and server support streaming.

        Args:
            request: Parameters to identify the task to resubscribe to.
            context: The client call context.

        Yields:
            An async iterator of `ClientEvent` objects.

        Raises:
            NotImplementedError: If streaming is not supported by the client or server.
        """
⋮----
# Note: resubscribe can only be called on an existing task. As such,
# we should never see Message updates, despite the typing of the service
# definition indicating it may be possible.
⋮----
"""Retrieves the agent's card.

        This will fetch the authenticated card if necessary and update the
        client's internal state with the new card.

        Args:
            context: The client call context.

        Returns:
            The `AgentCard` for the agent.
        """
card = await self._transport.get_card(context=context)
⋮----
async def close(self) -> None
⋮----
"""Closes the underlying transport."""

================
File: src/a2a/client/card_resolver.py
================
logger = logging.getLogger(__name__)
⋮----
class A2ACardResolver
⋮----
"""Agent Card resolver."""
⋮----
"""Initializes the A2ACardResolver.

        Args:
            httpx_client: An async HTTP client instance (e.g., httpx.AsyncClient).
            base_url: The base URL of the agent's host.
            agent_card_path: The path to the agent card endpoint, relative to the base URL.
        """
⋮----
"""Fetches an agent card from a specified path relative to the base_url.

        If relative_card_path is None, it defaults to the resolver's configured
        agent_card_path (for the public agent card).

        Args:
            relative_card_path: Optional path to the agent card endpoint,
                relative to the base URL. If None, uses the default public
                agent card path.
            http_kwargs: Optional dictionary of keyword arguments to pass to the
                underlying httpx.get request.

        Returns:
            An `AgentCard` object representing the agent's capabilities.

        Raises:
            A2AClientHTTPError: If an HTTP error occurs during the request.
            A2AClientJSONError: If the response body cannot be decoded as JSON
                or validated against the AgentCard schema.
        """
⋮----
# Use the default public agent card path configured during initialization
path_segment = self.agent_card_path
⋮----
path_segment = relative_card_path.lstrip('/')
⋮----
target_url = f'{self.base_url}/{path_segment}'
⋮----
response = await self.httpx_client.get(
⋮----
agent_card_data = response.json()
⋮----
agent_card = AgentCard.model_validate(agent_card_data)
⋮----
except ValidationError as e:  # Pydantic validation error

================
File: src/a2a/client/client_factory.py
================
GrpcTransport = None  # type: ignore # pyright: ignore
⋮----
logger = logging.getLogger(__name__)
⋮----
TransportProducer = Callable[
⋮----
class ClientFactory
⋮----
"""ClientFactory is used to generate the appropriate client for the agent.

    The factory is configured with a `ClientConfig` and optionally a list of
    `Consumer`s to use for all generated `Client`s. The expected use is:

    factory = ClientFactory(config, consumers)
    # Optionally register custom client implementations
    factory.register('my_customer_transport', NewCustomTransportClient)
    # Then with an agent card make a client with additional consumers and
    # interceptors
    client = factory.create(card, additional_consumers, interceptors)
    # Now the client can be used the same regardless of transport and
    # aligns client config with server capabilities.
    """
⋮----
consumers = []
⋮----
# Empty support list implies JSON-RPC only.
⋮----
def register(self, label: str, generator: TransportProducer) -> None
⋮----
"""Register a new transport producer for a given transport label."""
⋮----
"""Create a new `Client` for the provided `AgentCard`.

        Args:
          card: An `AgentCard` defining the characteristics of the agent.
          consumers: A list of `Consumer` methods to pass responses to.
          interceptors: A list of interceptors to use for each request. These
            are used for things like attaching credentials or http headers
            to all outbound requests.

        Returns:
          A `Client` object.

        Raises:
          If there is no valid matching of the client configuration with the
          server configuration, a `ValueError` is raised.
        """
server_preferred = card.preferred_transport or TransportProtocol.jsonrpc
server_set = {server_preferred: card.url}
⋮----
client_set = self._config.supported_transports or [
transport_protocol = None
transport_url = None
⋮----
transport_protocol = x
transport_url = server_set[x]
⋮----
transport_url = url
⋮----
all_consumers = self._consumers.copy()
⋮----
transport = self._registry[transport_protocol](
⋮----
"""Generates a minimal card to simplify bootstrapping client creation.

    This minimal card is not viable itself to interact with the remote agent.
    Instead this is a short hand way to take a known url and transport option
    and interact with the get card endpoint of the agent server to get the
    correct agent card. This pattern is necessary for gRPC based card access
    as typically these servers won't expose a well known path card.
    """
⋮----
transports = []

================
File: src/a2a/client/client_task_manager.py
================
logger = logging.getLogger(__name__)
⋮----
class ClientTaskManager
⋮----
"""Helps manage a task's lifecycle during execution of a request.

    Responsible for retrieving, saving, and updating the `Task` object based on
    events received from the agent.
    """
⋮----
"""Initializes the `ClientTaskManager`."""
⋮----
def get_task(self) -> Task | None
⋮----
"""Retrieves the current task object, either from memory.

        If `task_id` is set, it returns `_current_task` otherwise None.

        Returns:
            The `Task` object if found, otherwise `None`.
        """
⋮----
def get_task_or_raise(self) -> Task
⋮----
"""Retrieves the current task object.

        Returns:
            The `Task` object.

        Raises:
            A2AClientInvalidStateError: If there is no current known Task.
        """
⋮----
# Note: The source of this error is either from bad client usage
# or from the server sending invalid updates. It indicates that this
# task manager has not consumed any information about a task, yet
# the caller is attempting to retrieve the current state of the task
# it expects to be present.
⋮----
"""Processes a task-related event (Task, Status, Artifact) and saves the updated task state.

        Ensures task and context IDs match or are set from the event.

        Args:
            event: The task-related event (`Task`, `TaskStatusUpdateEvent`, or `TaskArtifactUpdateEvent`).

        Returns:
            The updated `Task` object after processing the event.

        Raises:
            ClientError: If the task ID in the event conflicts with the TaskManager's ID
                         when the TaskManager's ID is already set.
        """
⋮----
task_id_from_event = (
⋮----
task = self._current_task
⋮----
task = Task(
⋮----
async def process(self, event: Event) -> Event
⋮----
"""Processes an event, updates the task state if applicable, stores it, and returns the event.

        If the event is task-related (`Task`, `TaskStatusUpdateEvent`, `TaskArtifactUpdateEvent`),
        the internal task state is updated and persisted.

        Args:
            event: The event object received from the agent.

        Returns:
            The same event object that was processed.
        """
⋮----
async def _save_task(self, task: Task) -> None
⋮----
"""Saves the given task to the `_current_task` and updated `_task_id` and `_context_id`.

        Args:
            task: The `Task` object to save.
        """
⋮----
def update_with_message(self, message: Message, task: Task) -> Task
⋮----
"""Updates a task object adding a new message to its history.

        If the task has a message in its current status, that message is moved
        to the history first.

        Args:
            message: The new `Message` to add to the history.
            task: The `Task` object to update.

        Returns:
            The updated `Task` object (updated in-place).
        """

================
File: src/a2a/client/client.py
================
logger = logging.getLogger(__name__)
⋮----
@dataclasses.dataclass
class ClientConfig
⋮----
"""Configuration class for the A2AClient Factory."""
⋮----
streaming: bool = True
"""Whether client supports streaming"""
⋮----
polling: bool = False
"""Whether client prefers to poll for updates from message:send. It is
    the callers job to check if the response is completed and if not run a
    polling loop."""
⋮----
httpx_client: httpx.AsyncClient | None = None
"""Http client to use to connect to agent."""
⋮----
grpc_channel_factory: Callable[[str], Channel] | None = None
"""Generates a grpc connection channel for a given url."""
⋮----
supported_transports: list[TransportProtocol | str] = dataclasses.field(
"""Ordered list of transports for connecting to agent
       (in order of preference). Empty implies JSONRPC only.

       This is a string type to allow custom
       transports to exist in closed ecosystems.
    """
⋮----
use_client_preference: bool = False
"""Whether to use client transport preferences over server preferences.
       Recommended to use server preferences in most situations."""
⋮----
accepted_output_modes: list[str] = dataclasses.field(default_factory=list)
"""The set of accepted output modes for the client."""
⋮----
push_notification_configs: list[PushNotificationConfig] = dataclasses.field(
"""Push notification callbacks to use for every request."""
⋮----
UpdateEvent = TaskStatusUpdateEvent | TaskArtifactUpdateEvent | None
# Alias for emitted events from client
ClientEvent = tuple[Task, UpdateEvent]
# Alias for an event consuming callback. It takes either a (task, update) pair
# or a message as well as the agent card for the agent this came from.
Consumer = Callable[
⋮----
class Client(ABC)
⋮----
"""Abstract base class defining the interface for an A2A client.

    This class provides a standard set of methods for interacting with an A2A
    agent, regardless of the underlying transport protocol (e.g., gRPC, JSON-RPC).
    It supports sending messages, managing tasks, and handling event streams.
    """
⋮----
"""Initializes the client with consumers and middleware.

        Args:
            consumers: A list of callables to process events from the agent.
            middleware: A list of interceptors to process requests and responses.
        """
⋮----
middleware = []
⋮----
consumers = []
⋮----
"""Sends a message to the server.

        This will automatically use the streaming or non-streaming approach
        as supported by the server and the client config. Client will
        aggregate update events and return an iterator of (`Task`,`Update`)
        pairs, or a `Message`. Client will also send these values to any
        configured `Consumer`s in the client.
        """
⋮----
"""Retrieves the current state and history of a specific task."""
⋮----
"""Requests the agent to cancel a specific task."""
⋮----
"""Sets or updates the push notification configuration for a specific task."""
⋮----
"""Retrieves the push notification configuration for a specific task."""
⋮----
"""Resubscribes to a task's event stream."""
⋮----
"""Retrieves the agent's card."""
⋮----
async def add_event_consumer(self, consumer: Consumer) -> None
⋮----
"""Attaches additional consumers to the `Client`."""
⋮----
"""Attaches additional middleware to the `Client`."""
⋮----
"""Processes the event via all the registered `Consumer`s."""

================
File: src/a2a/client/errors.py
================
"""Custom exceptions for the A2A client."""
⋮----
class A2AClientError(Exception)
⋮----
"""Base exception for A2A Client errors."""
⋮----
class A2AClientHTTPError(A2AClientError)
⋮----
"""Client exception for HTTP errors received from the server."""
⋮----
def __init__(self, status_code: int, message: str)
⋮----
"""Initializes the A2AClientHTTPError.

        Args:
            status_code: The HTTP status code of the response.
            message: A descriptive error message.
        """
⋮----
class A2AClientJSONError(A2AClientError)
⋮----
"""Client exception for JSON errors during response parsing or validation."""
⋮----
def __init__(self, message: str)
⋮----
"""Initializes the A2AClientJSONError.

        Args:
            message: A descriptive error message.
        """
⋮----
class A2AClientTimeoutError(A2AClientError)
⋮----
"""Client exception for timeout errors during a request."""
⋮----
"""Initializes the A2AClientTimeoutError.

        Args:
            message: A descriptive error message.
        """
⋮----
class A2AClientInvalidArgsError(A2AClientError)
⋮----
"""Client exception for invalid arguments passed to a method."""
⋮----
"""Initializes the A2AClientInvalidArgsError.

        Args:
            message: A descriptive error message.
        """
⋮----
class A2AClientInvalidStateError(A2AClientError)
⋮----
"""Client exception for an invalid client state."""
⋮----
"""Initializes the A2AClientInvalidStateError.

        Args:
            message: A descriptive error message.
        """
⋮----
class A2AClientJSONRPCError(A2AClientError)
⋮----
"""Client exception for JSON-RPC errors returned by the server."""
⋮----
def __init__(self, error: JSONRPCErrorResponse)
⋮----
"""Initializes the A2AClientJsonRPCError.

        Args:
            error: The JSON-RPC error object.
        """

================
File: src/a2a/client/helpers.py
================
"""Helper functions for the A2A client."""
⋮----
"""Create a Message object containing a single TextPart.

    Args:
        role: The role of the message sender (user or agent). Defaults to Role.user.
        content: The text content of the message. Defaults to an empty string.

    Returns:
        A `Message` object with a new UUID message_id.
    """

================
File: src/a2a/client/legacy_grpc.py
================
"""Backwards compatibility layer for the legacy A2A gRPC client."""
⋮----
class A2AGrpcClient(GrpcTransport)
⋮----
"""[DEPRECATED] Backwards compatibility wrapper for the gRPC client."""
⋮----
def __init__(  # pylint: disable=super-init-not-called
⋮----
# The old gRPC client accepted a stub directly. The new one accepts a
# channel and builds the stub itself. We just have a stub here, so we
# need to handle initialization ourselves.
⋮----
class _NopChannel
⋮----
async def close(self) -> None

================
File: src/a2a/client/legacy.py
================
"""Backwards compatibility layer for legacy A2A clients."""
⋮----
class A2AClient
⋮----
"""[DEPRECATED] Backwards compatibility wrapper for the JSON-RPC client."""
⋮----
"""Sends a non-streaming message request to the agent.

        Args:
            request: The `SendMessageRequest` object containing the message and configuration.
            http_kwargs: Optional dictionary of keyword arguments to pass to the
                underlying httpx.post request.
            context: The client call context.

        Returns:
            A `SendMessageResponse` object containing the agent's response (Task or Message) or an error.

        Raises:
            A2AClientHTTPError: If an HTTP error occurs during the request.
            A2AClientJSONError: If the response body cannot be decoded as JSON or validated.
        """
⋮----
context = ClientCallContext(state={'http_kwargs': http_kwargs})
⋮----
result = await self._transport.send_message(
⋮----
"""Sends a streaming message request to the agent and yields responses as they arrive.

        This method uses Server-Sent Events (SSE) to receive a stream of updates from the agent.

        Args:
            request: The `SendStreamingMessageRequest` object containing the message and configuration.
            http_kwargs: Optional dictionary of keyword arguments to pass to the
                underlying httpx.post request. A default `timeout=None` is set but can be overridden.
            context: The client call context.

        Yields:
            `SendStreamingMessageResponse` objects as they are received in the SSE stream.
            These can be Task, Message, TaskStatusUpdateEvent, or TaskArtifactUpdateEvent.

        Raises:
            A2AClientHTTPError: If an HTTP or SSE protocol error occurs during the request.
            A2AClientJSONError: If an SSE event data cannot be decoded as JSON or validated.
        """
⋮----
"""Retrieves the current state and history of a specific task.

        Args:
            request: The `GetTaskRequest` object specifying the task ID and history length.
            http_kwargs: Optional dictionary of keyword arguments to pass to the
                underlying httpx.post request.
            context: The client call context.

        Returns:
            A `GetTaskResponse` object containing the Task or an error.

        Raises:
            A2AClientHTTPError: If an HTTP error occurs during the request.
            A2AClientJSONError: If the response body cannot be decoded as JSON or validated.
        """
⋮----
result = await self._transport.get_task(
⋮----
"""Requests the agent to cancel a specific task.

        Args:
            request: The `CancelTaskRequest` object specifying the task ID.
            http_kwargs: Optional dictionary of keyword arguments to pass to the
                underlying httpx.post request.
            context: The client call context.

        Returns:
            A `CancelTaskResponse` object containing the updated Task with canceled status or an error.

        Raises:
            A2AClientHTTPError: If an HTTP error occurs during the request.
            A2AClientJSONError: If the response body cannot be decoded as JSON or validated.
        """
⋮----
result = await self._transport.cancel_task(
⋮----
"""Sets or updates the push notification configuration for a specific task.

        Args:
            request: The `SetTaskPushNotificationConfigRequest` object specifying the task ID and configuration.
            http_kwargs: Optional dictionary of keyword arguments to pass to the
                underlying httpx.post request.
            context: The client call context.

        Returns:
            A `SetTaskPushNotificationConfigResponse` object containing the confirmation or an error.

        Raises:
            A2AClientHTTPError: If an HTTP error occurs during the request.
            A2AClientJSONError: If the response body cannot be decoded as JSON or validated.
        """
⋮----
result = await self._transport.set_task_callback(
⋮----
"""Retrieves the push notification configuration for a specific task.

        Args:
            request: The `GetTaskPushNotificationConfigRequest` object specifying the task ID.
            http_kwargs: Optional dictionary of keyword arguments to pass to the
                underlying httpx.post request.
            context: The client call context.

        Returns:
            A `GetTaskPushNotificationConfigResponse` object containing the configuration or an error.

        Raises:
            A2AClientHTTPError: If an HTTP error occurs during the request.
            A2AClientJSONError: If the response body cannot be decoded as JSON or validated.
        """
⋮----
params = request.params
⋮----
params = GetTaskPushNotificationConfigParams(id=request.params.id)
⋮----
result = await self._transport.get_task_callback(
⋮----
"""Reconnects to get task updates.

        This method uses Server-Sent Events (SSE) to receive a stream of updates from the agent.

        Args:
            request: The `TaskResubscriptionRequest` object containing the task information to reconnect to.
            http_kwargs: Optional dictionary of keyword arguments to pass to the
                underlying httpx.post request. A default `timeout=None` is set but can be overridden.
            context: The client call context.

        Yields:
            `SendStreamingMessageResponse` objects as they are received in the SSE stream.
            These can be Task, Message, TaskStatusUpdateEvent, or TaskArtifactUpdateEvent.

        Raises:
            A2AClientHTTPError: If an HTTP or SSE protocol error occurs during the request.
            A2AClientJSONError: If an SSE event data cannot be decoded as JSON or validated.
        """
⋮----
"""Retrieves the authenticated card (if necessary) or the public one.

        Args:
            http_kwargs: Optional dictionary of keyword arguments to pass to the
                underlying httpx.post request.
            context: The client call context.

        Returns:
            A `AgentCard` object containing the card or an error.

        Raises:
            A2AClientHTTPError: If an HTTP error occurs during the request.
            A2AClientJSONError: If the response body cannot be decoded as JSON or validated.
        """

================
File: src/a2a/client/middleware.py
================
from collections.abc import MutableMapping  # noqa: TC003
⋮----
class ClientCallContext(BaseModel)
⋮----
"""A context passed with each client call, allowing for call-specific.

    configuration and data passing. Such as authentication details or
    request deadlines.
    """
⋮----
state: MutableMapping[str, Any] = Field(default_factory=dict)
⋮----
class ClientCallInterceptor(ABC)
⋮----
"""An abstract base class for client-side call interceptors.

    Interceptors can inspect and modify requests before they are sent,
    which is ideal for concerns like authentication, logging, or tracing.
    """
⋮----
"""
        Intercepts a client call before the request is sent.

        Args:
            method_name: The name of the RPC method (e.g., 'message/send').
            request_payload: The JSON RPC request payload dictionary.
            http_kwargs: The keyword arguments for the httpx request.
            agent_card: The AgentCard associated with the client.
            context: The ClientCallContext for this specific call.

        Returns:
            A tuple containing the (potentially modified) request_payload
            and http_kwargs.
        """

================
File: src/a2a/client/optionals.py
================
# Attempt to import the optional module
⋮----
from grpc.aio import Channel  # pyright: ignore[reportAssignmentType]
⋮----
# If grpc.aio is not available, define a dummy type for type checking.
# This dummy type will only be used by type checkers.
⋮----
class Channel:  # type: ignore[no-redef]
⋮----
"""Dummy class for type hinting when grpc.aio is not available."""
⋮----
Channel = None  # At runtime, pd will be None if the import failed.

================
File: src/a2a/extensions/common.py
================
HTTP_EXTENSION_HEADER = 'X-A2A-Extensions'
⋮----
def get_requested_extensions(values: list[str]) -> set[str]
⋮----
"""Get the set of requested extensions from an input list.

    This handles the list containing potentially comma-separated values, as
    occurs when using a list in an HTTP header.
    """
⋮----
def find_extension_by_uri(card: AgentCard, uri: str) -> AgentExtension | None
⋮----
"""Find an AgentExtension in an AgentCard given a uri."""

================
File: src/a2a/grpc/a2a_pb2_grpc.py
================
# Generated by the gRPC Python protocol compiler plugin. DO NOT EDIT!
"""Client and server classes corresponding to protobuf-defined services."""
⋮----
class A2AServiceStub(object)
⋮----
"""A2AService defines the gRPC version of the A2A protocol. This has a slightly
    different shape than the JSONRPC version to better conform to AIP-127,
    where appropriate. The nouns are AgentCard, Message, Task and
    TaskPushNotificationConfig.
    - Messages are not a standard resource so there is no get/delete/update/list
    interface, only a send and stream custom methods.
    - Tasks have a get interface and custom cancel and subscribe methods.
    - TaskPushNotificationConfig are a resource whose parent is a task.
    They have get, list and create methods.
    - AgentCard is a static resource with only a get method.
    fields are not present as they don't comply with AIP rules, and the
    optional history_length on the get task method is not present as it also
    violates AIP-127 and AIP-131.
    """
⋮----
def __init__(self, channel)
⋮----
"""Constructor.

        Args:
            channel: A grpc.Channel.
        """
⋮----
class A2AServiceServicer(object)
⋮----
def SendMessage(self, request, context)
⋮----
"""Send a message to the agent. This is a blocking call that will return the
        task once it is completed, or a LRO if requested.
        """
⋮----
def SendStreamingMessage(self, request, context)
⋮----
"""SendStreamingMessage is a streaming call that will return a stream of
        task update events until the Task is in an interrupted or terminal state.
        """
⋮----
def GetTask(self, request, context)
⋮----
"""Get the current state of a task from the agent.
        """
⋮----
def CancelTask(self, request, context)
⋮----
"""Cancel a task from the agent. If supported one should expect no
        more task updates for the task.
        """
⋮----
def TaskSubscription(self, request, context)
⋮----
"""TaskSubscription is a streaming call that will return a stream of task
        update events. This attaches the stream to an existing in process task.
        If the task is complete the stream will return the completed task (like
        GetTask) and close the stream.
        """
⋮----
def CreateTaskPushNotificationConfig(self, request, context)
⋮----
"""Set a push notification config for a task.
        """
⋮----
def GetTaskPushNotificationConfig(self, request, context)
⋮----
"""Get a push notification config for a task.
        """
⋮----
def ListTaskPushNotificationConfig(self, request, context)
⋮----
"""Get a list of push notifications configured for a task.
        """
⋮----
def GetAgentCard(self, request, context)
⋮----
"""GetAgentCard returns the agent card for the agent.
        """
⋮----
def DeleteTaskPushNotificationConfig(self, request, context)
⋮----
"""Delete a push notification config for a task.
        """
⋮----
def add_A2AServiceServicer_to_server(servicer, server)
⋮----
rpc_method_handlers = {
generic_handler = grpc.method_handlers_generic_handler(
⋮----
# This class is part of an EXPERIMENTAL API.
class A2AService(object)

================
File: src/a2a/grpc/a2a_pb2.py
================
# -*- coding: utf-8 -*-
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# NO CHECKED-IN PROTOBUF GENCODE
# source: a2a.proto
# Protobuf Python Version: 5.29.3
"""Generated protocol buffer code."""
⋮----
# @@protoc_insertion_point(imports)
⋮----
_sym_db = _symbol_database.Default()
⋮----
DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(b'\n\ta2a.proto\x12\x06\x61\x32\x61.v1\x1a\x1cgoogle/api/annotations.proto\x1a\x17google/api/client.proto\x1a\x1fgoogle/api/field_behavior.proto\x1a\x1bgoogle/protobuf/empty.proto\x1a\x1cgoogle/protobuf/struct.proto\x1a\x1fgoogle/protobuf/timestamp.proto\"\xde\x01\n\x18SendMessageConfiguration\x12\x32\n\x15\x61\x63\x63\x65pted_output_modes\x18\x01 \x03(\tR\x13\x61\x63\x63\x65ptedOutputModes\x12K\n\x11push_notification\x18\x02 \x01(\x0b\x32\x1e.a2a.v1.PushNotificationConfigR\x10pushNotification\x12%\n\x0ehistory_length\x18\x03 \x01(\x05R\rhistoryLength\x12\x1a\n\x08\x62locking\x18\x04 \x01(\x08R\x08\x62locking\"\xf1\x01\n\x04Task\x12\x0e\n\x02id\x18\x01 \x01(\tR\x02id\x12\x1d\n\ncontext_id\x18\x02 \x01(\tR\tcontextId\x12*\n\x06status\x18\x03 \x01(\x0b\x32\x12.a2a.v1.TaskStatusR\x06status\x12.\n\tartifacts\x18\x04 \x03(\x0b\x32\x10.a2a.v1.ArtifactR\tartifacts\x12)\n\x07history\x18\x05 \x03(\x0b\x32\x0f.a2a.v1.MessageR\x07history\x12\x33\n\x08metadata\x18\x06 \x01(\x0b\x32\x17.google.protobuf.StructR\x08metadata\"\x99\x01\n\nTaskStatus\x12\'\n\x05state\x18\x01 \x01(\x0e\x32\x11.a2a.v1.TaskStateR\x05state\x12(\n\x06update\x18\x02 \x01(\x0b\x32\x0f.a2a.v1.MessageR\x07message\x12\x38\n\ttimestamp\x18\x03 \x01(\x0b\x32\x1a.google.protobuf.TimestampR\ttimestamp\"t\n\x04Part\x12\x14\n\x04text\x18\x01 \x01(\tH\x00R\x04text\x12&\n\x04\x66ile\x18\x02 \x01(\x0b\x32\x10.a2a.v1.FilePartH\x00R\x04\x66ile\x12&\n\x04\x64\x61ta\x18\x03 \x01(\x0b\x32\x10.a2a.v1.DataPartH\x00R\x04\x64\x61taB\x06\n\x04part\"\x7f\n\x08\x46ilePart\x12$\n\rfile_with_uri\x18\x01 \x01(\tH\x00R\x0b\x66ileWithUri\x12(\n\x0f\x66ile_with_bytes\x18\x02 \x01(\x0cH\x00R\rfileWithBytes\x12\x1b\n\tmime_type\x18\x03 \x01(\tR\x08mimeTypeB\x06\n\x04\x66ile\"7\n\x08\x44\x61taPart\x12+\n\x04\x64\x61ta\x18\x01 \x01(\x0b\x32\x17.google.protobuf.StructR\x04\x64\x61ta\"\xff\x01\n\x07Message\x12\x1d\n\nmessage_id\x18\x01 \x01(\tR\tmessageId\x12\x1d\n\ncontext_id\x18\x02 \x01(\tR\tcontextId\x12\x17\n\x07task_id\x18\x03 \x01(\tR\x06taskId\x12 \n\x04role\x18\x04 \x01(\x0e\x32\x0c.a2a.v1.RoleR\x04role\x12&\n\x07\x63ontent\x18\x05 \x03(\x0b\x32\x0c.a2a.v1.PartR\x07\x63ontent\x12\x33\n\x08metadata\x18\x06 \x01(\x0b\x32\x17.google.protobuf.StructR\x08metadata\x12\x1e\n\nextensions\x18\x07 \x03(\tR\nextensions\"\xda\x01\n\x08\x41rtifact\x12\x1f\n\x0b\x61rtifact_id\x18\x01 \x01(\tR\nartifactId\x12\x12\n\x04name\x18\x03 \x01(\tR\x04name\x12 \n\x0b\x64\x65scription\x18\x04 \x01(\tR\x0b\x64\x65scription\x12\"\n\x05parts\x18\x05 \x03(\x0b\x32\x0c.a2a.v1.PartR\x05parts\x12\x33\n\x08metadata\x18\x06 \x01(\x0b\x32\x17.google.protobuf.StructR\x08metadata\x12\x1e\n\nextensions\x18\x07 \x03(\tR\nextensions\"\xc6\x01\n\x15TaskStatusUpdateEvent\x12\x17\n\x07task_id\x18\x01 \x01(\tR\x06taskId\x12\x1d\n\ncontext_id\x18\x02 \x01(\tR\tcontextId\x12*\n\x06status\x18\x03 \x01(\x0b\x32\x12.a2a.v1.TaskStatusR\x06status\x12\x14\n\x05\x66inal\x18\x04 \x01(\x08R\x05\x66inal\x12\x33\n\x08metadata\x18\x05 \x01(\x0b\x32\x17.google.protobuf.StructR\x08metadata\"\xeb\x01\n\x17TaskArtifactUpdateEvent\x12\x17\n\x07task_id\x18\x01 \x01(\tR\x06taskId\x12\x1d\n\ncontext_id\x18\x02 \x01(\tR\tcontextId\x12,\n\x08\x61rtifact\x18\x03 \x01(\x0b\x32\x10.a2a.v1.ArtifactR\x08\x61rtifact\x12\x16\n\x06\x61ppend\x18\x04 \x01(\x08R\x06\x61ppend\x12\x1d\n\nlast_chunk\x18\x05 \x01(\x08R\tlastChunk\x12\x33\n\x08metadata\x18\x06 \x01(\x0b\x32\x17.google.protobuf.StructR\x08metadata\"\x94\x01\n\x16PushNotificationConfig\x12\x0e\n\x02id\x18\x01 \x01(\tR\x02id\x12\x10\n\x03url\x18\x02 \x01(\tR\x03url\x12\x14\n\x05token\x18\x03 \x01(\tR\x05token\x12\x42\n\x0e\x61uthentication\x18\x04 \x01(\x0b\x32\x1a.a2a.v1.AuthenticationInfoR\x0e\x61uthentication\"P\n\x12\x41uthenticationInfo\x12\x18\n\x07schemes\x18\x01 \x03(\tR\x07schemes\x12 \n\x0b\x63redentials\x18\x02 \x01(\tR\x0b\x63redentials\"@\n\x0e\x41gentInterface\x12\x10\n\x03url\x18\x01 \x01(\tR\x03url\x12\x1c\n\ttransport\x18\x02 \x01(\tR\ttransport\"\xad\x07\n\tAgentCard\x12)\n\x10protocol_version\x18\x10 \x01(\tR\x0fprotocolVersion\x12\x12\n\x04name\x18\x01 \x01(\tR\x04name\x12 \n\x0b\x64\x65scription\x18\x02 \x01(\tR\x0b\x64\x65scription\x12\x10\n\x03url\x18\x03 \x01(\tR\x03url\x12/\n\x13preferred_transport\x18\x0e \x01(\tR\x12preferredTransport\x12K\n\x15\x61\x64\x64itional_interfaces\x18\x0f \x03(\x0b\x32\x16.a2a.v1.AgentInterfaceR\x14\x61\x64\x64itionalInterfaces\x12\x31\n\x08provider\x18\x04 \x01(\x0b\x32\x15.a2a.v1.AgentProviderR\x08provider\x12\x18\n\x07version\x18\x05 \x01(\tR\x07version\x12+\n\x11\x64ocumentation_url\x18\x06 \x01(\tR\x10\x64ocumentationUrl\x12=\n\x0c\x63\x61pabilities\x18\x07 \x01(\x0b\x32\x19.a2a.v1.AgentCapabilitiesR\x0c\x63\x61pabilities\x12Q\n\x10security_schemes\x18\x08 \x03(\x0b\x32&.a2a.v1.AgentCard.SecuritySchemesEntryR\x0fsecuritySchemes\x12,\n\x08security\x18\t \x03(\x0b\x32\x10.a2a.v1.SecurityR\x08security\x12.\n\x13\x64\x65\x66\x61ult_input_modes\x18\n \x03(\tR\x11\x64\x65\x66\x61ultInputModes\x12\x30\n\x14\x64\x65\x66\x61ult_output_modes\x18\x0b \x03(\tR\x12\x64\x65\x66\x61ultOutputModes\x12*\n\x06skills\x18\x0c \x03(\x0b\x32\x12.a2a.v1.AgentSkillR\x06skills\x12O\n$supports_authenticated_extended_card\x18\r \x01(\x08R!supportsAuthenticatedExtendedCard\x12:\n\nsignatures\x18\x11 \x03(\x0b\x32\x1a.a2a.v1.AgentCardSignatureR\nsignatures\x1aZ\n\x14SecuritySchemesEntry\x12\x10\n\x03key\x18\x01 \x01(\tR\x03key\x12,\n\x05value\x18\x02 \x01(\x0b\x32\x16.a2a.v1.SecuritySchemeR\x05value:\x02\x38\x01\"E\n\rAgentProvider\x12\x10\n\x03url\x18\x01 \x01(\tR\x03url\x12\"\n\x0corganization\x18\x02 \x01(\tR\x0corganization\"\x98\x01\n\x11\x41gentCapabilities\x12\x1c\n\tstreaming\x18\x01 \x01(\x08R\tstreaming\x12-\n\x12push_notifications\x18\x02 \x01(\x08R\x11pushNotifications\x12\x36\n\nextensions\x18\x03 \x03(\x0b\x32\x16.a2a.v1.AgentExtensionR\nextensions\"\x91\x01\n\x0e\x41gentExtension\x12\x10\n\x03uri\x18\x01 \x01(\tR\x03uri\x12 \n\x0b\x64\x65scription\x18\x02 \x01(\tR\x0b\x64\x65scription\x12\x1a\n\x08required\x18\x03 \x01(\x08R\x08required\x12/\n\x06params\x18\x04 \x01(\x0b\x32\x17.google.protobuf.StructR\x06params\"\xf4\x01\n\nAgentSkill\x12\x0e\n\x02id\x18\x01 \x01(\tR\x02id\x12\x12\n\x04name\x18\x02 \x01(\tR\x04name\x12 \n\x0b\x64\x65scription\x18\x03 \x01(\tR\x0b\x64\x65scription\x12\x12\n\x04tags\x18\x04 \x03(\tR\x04tags\x12\x1a\n\x08\x65xamples\x18\x05 \x03(\tR\x08\x65xamples\x12\x1f\n\x0binput_modes\x18\x06 \x03(\tR\ninputModes\x12!\n\x0coutput_modes\x18\x07 \x03(\tR\x0boutputModes\x12,\n\x08security\x18\x08 \x03(\x0b\x32\x10.a2a.v1.SecurityR\x08security\"\x8b\x01\n\x12\x41gentCardSignature\x12!\n\tprotected\x18\x01 \x01(\tB\x03\xe0\x41\x02R\tprotected\x12!\n\tsignature\x18\x02 \x01(\tB\x03\xe0\x41\x02R\tsignature\x12/\n\x06header\x18\x03 \x01(\x0b\x32\x17.google.protobuf.StructR\x06header\"\x8a\x01\n\x1aTaskPushNotificationConfig\x12\x12\n\x04name\x18\x01 \x01(\tR\x04name\x12X\n\x18push_notification_config\x18\x02 \x01(\x0b\x32\x1e.a2a.v1.PushNotificationConfigR\x16pushNotificationConfig\" \n\nStringList\x12\x12\n\x04list\x18\x01 \x03(\tR\x04list\"\x93\x01\n\x08Security\x12\x37\n\x07schemes\x18\x01 \x03(\x0b\x32\x1d.a2a.v1.Security.SchemesEntryR\x07schemes\x1aN\n\x0cSchemesEntry\x12\x10\n\x03key\x18\x01 \x01(\tR\x03key\x12(\n\x05value\x18\x02 \x01(\x0b\x32\x12.a2a.v1.StringListR\x05value:\x02\x38\x01\"\xe6\x03\n\x0eSecurityScheme\x12U\n\x17\x61pi_key_security_scheme\x18\x01 \x01(\x0b\x32\x1c.a2a.v1.APIKeySecuritySchemeH\x00R\x14\x61piKeySecurityScheme\x12[\n\x19http_auth_security_scheme\x18\x02 \x01(\x0b\x32\x1e.a2a.v1.HTTPAuthSecuritySchemeH\x00R\x16httpAuthSecurityScheme\x12T\n\x16oauth2_security_scheme\x18\x03 \x01(\x0b\x32\x1c.a2a.v1.OAuth2SecuritySchemeH\x00R\x14oauth2SecurityScheme\x12k\n\x1fopen_id_connect_security_scheme\x18\x04 \x01(\x0b\x32#.a2a.v1.OpenIdConnectSecuritySchemeH\x00R\x1bopenIdConnectSecurityScheme\x12S\n\x14mtls_security_scheme\x18\x05 \x01(\x0b\x32\x1f.a2a.v1.MutualTlsSecuritySchemeH\x00R\x12mtlsSecuritySchemeB\x08\n\x06scheme\"h\n\x14\x41PIKeySecurityScheme\x12 \n\x0b\x64\x65scription\x18\x01 \x01(\tR\x0b\x64\x65scription\x12\x1a\n\x08location\x18\x02 \x01(\tR\x08location\x12\x12\n\x04name\x18\x03 \x01(\tR\x04name\"w\n\x16HTTPAuthSecurityScheme\x12 \n\x0b\x64\x65scription\x18\x01 \x01(\tR\x0b\x64\x65scription\x12\x16\n\x06scheme\x18\x02 \x01(\tR\x06scheme\x12#\n\rbearer_format\x18\x03 \x01(\tR\x0c\x62\x65\x61rerFormat\"\x92\x01\n\x14OAuth2SecurityScheme\x12 \n\x0b\x64\x65scription\x18\x01 \x01(\tR\x0b\x64\x65scription\x12(\n\x05\x66lows\x18\x02 \x01(\x0b\x32\x12.a2a.v1.OAuthFlowsR\x05\x66lows\x12.\n\x13oauth2_metadata_url\x18\x03 \x01(\tR\x11oauth2MetadataUrl\"n\n\x1bOpenIdConnectSecurityScheme\x12 \n\x0b\x64\x65scription\x18\x01 \x01(\tR\x0b\x64\x65scription\x12-\n\x13open_id_connect_url\x18\x02 \x01(\tR\x10openIdConnectUrl\";\n\x17MutualTlsSecurityScheme\x12 \n\x0b\x64\x65scription\x18\x01 \x01(\tR\x0b\x64\x65scription\"\xb0\x02\n\nOAuthFlows\x12S\n\x12\x61uthorization_code\x18\x01 \x01(\x0b\x32\".a2a.v1.AuthorizationCodeOAuthFlowH\x00R\x11\x61uthorizationCode\x12S\n\x12\x63lient_credentials\x18\x02 \x01(\x0b\x32\".a2a.v1.ClientCredentialsOAuthFlowH\x00R\x11\x63lientCredentials\x12\x37\n\x08implicit\x18\x03 \x01(\x0b\x32\x19.a2a.v1.ImplicitOAuthFlowH\x00R\x08implicit\x12\x37\n\x08password\x18\x04 \x01(\x0b\x32\x19.a2a.v1.PasswordOAuthFlowH\x00R\x08passwordB\x06\n\x04\x66low\"\x8a\x02\n\x1a\x41uthorizationCodeOAuthFlow\x12+\n\x11\x61uthorization_url\x18\x01 \x01(\tR\x10\x61uthorizationUrl\x12\x1b\n\ttoken_url\x18\x02 \x01(\tR\x08tokenUrl\x12\x1f\n\x0brefresh_url\x18\x03 \x01(\tR\nrefreshUrl\x12\x46\n\x06scopes\x18\x04 \x03(\x0b\x32..a2a.v1.AuthorizationCodeOAuthFlow.ScopesEntryR\x06scopes\x1a\x39\n\x0bScopesEntry\x12\x10\n\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n\x05value\x18\x02 \x01(\tR\x05value:\x02\x38\x01\"\xdd\x01\n\x1a\x43lientCredentialsOAuthFlow\x12\x1b\n\ttoken_url\x18\x01 \x01(\tR\x08tokenUrl\x12\x1f\n\x0brefresh_url\x18\x02 \x01(\tR\nrefreshUrl\x12\x46\n\x06scopes\x18\x03 \x03(\x0b\x32..a2a.v1.ClientCredentialsOAuthFlow.ScopesEntryR\x06scopes\x1a\x39\n\x0bScopesEntry\x12\x10\n\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n\x05value\x18\x02 \x01(\tR\x05value:\x02\x38\x01\"\xdb\x01\n\x11ImplicitOAuthFlow\x12+\n\x11\x61uthorization_url\x18\x01 \x01(\tR\x10\x61uthorizationUrl\x12\x1f\n\x0brefresh_url\x18\x02 \x01(\tR\nrefreshUrl\x12=\n\x06scopes\x18\x03 \x03(\x0b\x32%.a2a.v1.ImplicitOAuthFlow.ScopesEntryR\x06scopes\x1a\x39\n\x0bScopesEntry\x12\x10\n\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n\x05value\x18\x02 \x01(\tR\x05value:\x02\x38\x01\"\xcb\x01\n\x11PasswordOAuthFlow\x12\x1b\n\ttoken_url\x18\x01 \x01(\tR\x08tokenUrl\x12\x1f\n\x0brefresh_url\x18\x02 \x01(\tR\nrefreshUrl\x12=\n\x06scopes\x18\x03 \x03(\x0b\x32%.a2a.v1.PasswordOAuthFlow.ScopesEntryR\x06scopes\x1a\x39\n\x0bScopesEntry\x12\x10\n\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n\x05value\x18\x02 \x01(\tR\x05value:\x02\x38\x01\"\xc1\x01\n\x12SendMessageRequest\x12.\n\x07request\x18\x01 \x01(\x0b\x32\x0f.a2a.v1.MessageB\x03\xe0\x41\x02R\x07message\x12\x46\n\rconfiguration\x18\x02 \x01(\x0b\x32 .a2a.v1.SendMessageConfigurationR\rconfiguration\x12\x33\n\x08metadata\x18\x03 \x01(\x0b\x32\x17.google.protobuf.StructR\x08metadata\"P\n\x0eGetTaskRequest\x12\x17\n\x04name\x18\x01 \x01(\tB\x03\xe0\x41\x02R\x04name\x12%\n\x0ehistory_length\x18\x02 \x01(\x05R\rhistoryLength\"\'\n\x11\x43\x61ncelTaskRequest\x12\x12\n\x04name\x18\x01 \x01(\tR\x04name\":\n$GetTaskPushNotificationConfigRequest\x12\x12\n\x04name\x18\x01 \x01(\tR\x04name\"=\n\'DeleteTaskPushNotificationConfigRequest\x12\x12\n\x04name\x18\x01 \x01(\tR\x04name\"\xa9\x01\n\'CreateTaskPushNotificationConfigRequest\x12\x1b\n\x06parent\x18\x01 \x01(\tB\x03\xe0\x41\x02R\x06parent\x12 \n\tconfig_id\x18\x02 \x01(\tB\x03\xe0\x41\x02R\x08\x63onfigId\x12?\n\x06\x63onfig\x18\x03 \x01(\x0b\x32\".a2a.v1.TaskPushNotificationConfigB\x03\xe0\x41\x02R\x06\x63onfig\"-\n\x17TaskSubscriptionRequest\x12\x12\n\x04name\x18\x01 \x01(\tR\x04name\"{\n%ListTaskPushNotificationConfigRequest\x12\x16\n\x06parent\x18\x01 \x01(\tR\x06parent\x12\x1b\n\tpage_size\x18\x02 \x01(\x05R\x08pageSize\x12\x1d\n\npage_token\x18\x03 \x01(\tR\tpageToken\"\x15\n\x13GetAgentCardRequest\"m\n\x13SendMessageResponse\x12\"\n\x04task\x18\x01 \x01(\x0b\x32\x0c.a2a.v1.TaskH\x00R\x04task\x12\'\n\x03msg\x18\x02 \x01(\x0b\x32\x0f.a2a.v1.MessageH\x00R\x07messageB\t\n\x07payload\"\xfa\x01\n\x0eStreamResponse\x12\"\n\x04task\x18\x01 \x01(\x0b\x32\x0c.a2a.v1.TaskH\x00R\x04task\x12\'\n\x03msg\x18\x02 \x01(\x0b\x32\x0f.a2a.v1.MessageH\x00R\x07message\x12\x44\n\rstatus_update\x18\x03 \x01(\x0b\x32\x1d.a2a.v1.TaskStatusUpdateEventH\x00R\x0cstatusUpdate\x12J\n\x0f\x61rtifact_update\x18\x04 \x01(\x0b\x32\x1f.a2a.v1.TaskArtifactUpdateEventH\x00R\x0e\x61rtifactUpdateB\t\n\x07payload\"\x8e\x01\n&ListTaskPushNotificationConfigResponse\x12<\n\x07\x63onfigs\x18\x01 \x03(\x0b\x32\".a2a.v1.TaskPushNotificationConfigR\x07\x63onfigs\x12&\n\x0fnext_page_token\x18\x02 \x01(\tR\rnextPageToken*\xfa\x01\n\tTaskState\x12\x1a\n\x16TASK_STATE_UNSPECIFIED\x10\x00\x12\x18\n\x14TASK_STATE_SUBMITTED\x10\x01\x12\x16\n\x12TASK_STATE_WORKING\x10\x02\x12\x18\n\x14TASK_STATE_COMPLETED\x10\x03\x12\x15\n\x11TASK_STATE_FAILED\x10\x04\x12\x18\n\x14TASK_STATE_CANCELLED\x10\x05\x12\x1d\n\x19TASK_STATE_INPUT_REQUIRED\x10\x06\x12\x17\n\x13TASK_STATE_REJECTED\x10\x07\x12\x1c\n\x18TASK_STATE_AUTH_REQUIRED\x10\x08*;\n\x04Role\x12\x14\n\x10ROLE_UNSPECIFIED\x10\x00\x12\r\n\tROLE_USER\x10\x01\x12\x0e\n\nROLE_AGENT\x10\x02\x32\xba\n\n\nA2AService\x12\x63\n\x0bSendMessage\x12\x1a.a2a.v1.SendMessageRequest\x1a\x1b.a2a.v1.SendMessageResponse\"\x1b\x82\xd3\xe4\x93\x02\x15\"\x10/v1/message:send:\x01*\x12k\n\x14SendStreamingMessage\x12\x1a.a2a.v1.SendMessageRequest\x1a\x16.a2a.v1.StreamResponse\"\x1d\x82\xd3\xe4\x93\x02\x17\"\x12/v1/message:stream:\x01*0\x01\x12R\n\x07GetTask\x12\x16.a2a.v1.GetTaskRequest\x1a\x0c.a2a.v1.Task\"!\xda\x41\x04name\x82\xd3\xe4\x93\x02\x14\x12\x12/v1/{name=tasks/*}\x12[\n\nCancelTask\x12\x19.a2a.v1.CancelTaskRequest\x1a\x0c.a2a.v1.Task\"$\x82\xd3\xe4\x93\x02\x1e\"\x19/v1/{name=tasks/*}:cancel:\x01*\x12s\n\x10TaskSubscription\x12\x1f.a2a.v1.TaskSubscriptionRequest\x1a\x16.a2a.v1.StreamResponse\"$\x82\xd3\xe4\x93\x02\x1e\x12\x1c/v1/{name=tasks/*}:subscribe0\x01\x12\xc4\x01\n CreateTaskPushNotificationConfig\x12/.a2a.v1.CreateTaskPushNotificationConfigRequest\x1a\".a2a.v1.TaskPushNotificationConfig\"K\xda\x41\rparent,config\x82\xd3\xe4\x93\x02\x35\"+/v1/{parent=task/*/pushNotificationConfigs}:\x06\x63onfig\x12\xae\x01\n\x1dGetTaskPushNotificationConfig\x12,.a2a.v1.GetTaskPushNotificationConfigRequest\x1a\".a2a.v1.TaskPushNotificationConfig\";\xda\x41\x04name\x82\xd3\xe4\x93\x02.\x12,/v1/{name=tasks/*/pushNotificationConfigs/*}\x12\xbe\x01\n\x1eListTaskPushNotificationConfig\x12-.a2a.v1.ListTaskPushNotificationConfigRequest\x1a..a2a.v1.ListTaskPushNotificationConfigResponse\"=\xda\x41\x06parent\x82\xd3\xe4\x93\x02.\x12,/v1/{parent=tasks/*}/pushNotificationConfigs\x12P\n\x0cGetAgentCard\x12\x1b.a2a.v1.GetAgentCardRequest\x1a\x11.a2a.v1.AgentCard\"\x10\x82\xd3\xe4\x93\x02\n\x12\x08/v1/card\x12\xa8\x01\n DeleteTaskPushNotificationConfig\x12/.a2a.v1.DeleteTaskPushNotificationConfigRequest\x1a\x16.google.protobuf.Empty\";\xda\x41\x04name\x82\xd3\xe4\x93\x02.*,/v1/{name=tasks/*/pushNotificationConfigs/*}Bi\n\ncom.a2a.v1B\x08\x41\x32\x61ProtoP\x01Z\x18google.golang.org/a2a/v1\xa2\x02\x03\x41XX\xaa\x02\x06\x41\x32\x61.V1\xca\x02\x06\x41\x32\x61\\V1\xe2\x02\x12\x41\x32\x61\\V1\\GPBMetadata\xea\x02\x07\x41\x32\x61::V1b\x06proto3')
⋮----
_globals = globals()
⋮----
# @@protoc_insertion_point(module_scope)

================
File: src/a2a/grpc/a2a_pb2.pyi
================
import datetime

from google.api import annotations_pb2 as _annotations_pb2
from google.api import client_pb2 as _client_pb2
from google.api import field_behavior_pb2 as _field_behavior_pb2
from google.protobuf import empty_pb2 as _empty_pb2
from google.protobuf import struct_pb2 as _struct_pb2
from google.protobuf import timestamp_pb2 as _timestamp_pb2
from google.protobuf.internal import containers as _containers
from google.protobuf.internal import enum_type_wrapper as _enum_type_wrapper
from google.protobuf import descriptor as _descriptor
from google.protobuf import message as _message
from collections.abc import Iterable as _Iterable, Mapping as _Mapping
from typing import ClassVar as _ClassVar, Optional as _Optional, Union as _Union

DESCRIPTOR: _descriptor.FileDescriptor

class TaskState(int, metaclass=_enum_type_wrapper.EnumTypeWrapper):
    __slots__ = ()
    TASK_STATE_UNSPECIFIED: _ClassVar[TaskState]
    TASK_STATE_SUBMITTED: _ClassVar[TaskState]
    TASK_STATE_WORKING: _ClassVar[TaskState]
    TASK_STATE_COMPLETED: _ClassVar[TaskState]
    TASK_STATE_FAILED: _ClassVar[TaskState]
    TASK_STATE_CANCELLED: _ClassVar[TaskState]
    TASK_STATE_INPUT_REQUIRED: _ClassVar[TaskState]
    TASK_STATE_REJECTED: _ClassVar[TaskState]
    TASK_STATE_AUTH_REQUIRED: _ClassVar[TaskState]

class Role(int, metaclass=_enum_type_wrapper.EnumTypeWrapper):
    __slots__ = ()
    ROLE_UNSPECIFIED: _ClassVar[Role]
    ROLE_USER: _ClassVar[Role]
    ROLE_AGENT: _ClassVar[Role]
TASK_STATE_UNSPECIFIED: TaskState
TASK_STATE_SUBMITTED: TaskState
TASK_STATE_WORKING: TaskState
TASK_STATE_COMPLETED: TaskState
TASK_STATE_FAILED: TaskState
TASK_STATE_CANCELLED: TaskState
TASK_STATE_INPUT_REQUIRED: TaskState
TASK_STATE_REJECTED: TaskState
TASK_STATE_AUTH_REQUIRED: TaskState
ROLE_UNSPECIFIED: Role
ROLE_USER: Role
ROLE_AGENT: Role

class SendMessageConfiguration(_message.Message):
    __slots__ = ("accepted_output_modes", "push_notification", "history_length", "blocking")
    ACCEPTED_OUTPUT_MODES_FIELD_NUMBER: _ClassVar[int]
    PUSH_NOTIFICATION_FIELD_NUMBER: _ClassVar[int]
    HISTORY_LENGTH_FIELD_NUMBER: _ClassVar[int]
    BLOCKING_FIELD_NUMBER: _ClassVar[int]
    accepted_output_modes: _containers.RepeatedScalarFieldContainer[str]
    push_notification: PushNotificationConfig
    history_length: int
    blocking: bool
    def __init__(self, accepted_output_modes: _Optional[_Iterable[str]] = ..., push_notification: _Optional[_Union[PushNotificationConfig, _Mapping]] = ..., history_length: _Optional[int] = ..., blocking: bool = ...) -> None: ...

class Task(_message.Message):
    __slots__ = ("id", "context_id", "status", "artifacts", "history", "metadata")
    ID_FIELD_NUMBER: _ClassVar[int]
    CONTEXT_ID_FIELD_NUMBER: _ClassVar[int]
    STATUS_FIELD_NUMBER: _ClassVar[int]
    ARTIFACTS_FIELD_NUMBER: _ClassVar[int]
    HISTORY_FIELD_NUMBER: _ClassVar[int]
    METADATA_FIELD_NUMBER: _ClassVar[int]
    id: str
    context_id: str
    status: TaskStatus
    artifacts: _containers.RepeatedCompositeFieldContainer[Artifact]
    history: _containers.RepeatedCompositeFieldContainer[Message]
    metadata: _struct_pb2.Struct
    def __init__(self, id: _Optional[str] = ..., context_id: _Optional[str] = ..., status: _Optional[_Union[TaskStatus, _Mapping]] = ..., artifacts: _Optional[_Iterable[_Union[Artifact, _Mapping]]] = ..., history: _Optional[_Iterable[_Union[Message, _Mapping]]] = ..., metadata: _Optional[_Union[_struct_pb2.Struct, _Mapping]] = ...) -> None: ...

class TaskStatus(_message.Message):
    __slots__ = ("state", "update", "timestamp")
    STATE_FIELD_NUMBER: _ClassVar[int]
    UPDATE_FIELD_NUMBER: _ClassVar[int]
    TIMESTAMP_FIELD_NUMBER: _ClassVar[int]
    state: TaskState
    update: Message
    timestamp: _timestamp_pb2.Timestamp
    def __init__(self, state: _Optional[_Union[TaskState, str]] = ..., update: _Optional[_Union[Message, _Mapping]] = ..., timestamp: _Optional[_Union[datetime.datetime, _timestamp_pb2.Timestamp, _Mapping]] = ...) -> None: ...

class Part(_message.Message):
    __slots__ = ("text", "file", "data")
    TEXT_FIELD_NUMBER: _ClassVar[int]
    FILE_FIELD_NUMBER: _ClassVar[int]
    DATA_FIELD_NUMBER: _ClassVar[int]
    text: str
    file: FilePart
    data: DataPart
    def __init__(self, text: _Optional[str] = ..., file: _Optional[_Union[FilePart, _Mapping]] = ..., data: _Optional[_Union[DataPart, _Mapping]] = ...) -> None: ...

class FilePart(_message.Message):
    __slots__ = ("file_with_uri", "file_with_bytes", "mime_type")
    FILE_WITH_URI_FIELD_NUMBER: _ClassVar[int]
    FILE_WITH_BYTES_FIELD_NUMBER: _ClassVar[int]
    MIME_TYPE_FIELD_NUMBER: _ClassVar[int]
    file_with_uri: str
    file_with_bytes: bytes
    mime_type: str
    def __init__(self, file_with_uri: _Optional[str] = ..., file_with_bytes: _Optional[bytes] = ..., mime_type: _Optional[str] = ...) -> None: ...

class DataPart(_message.Message):
    __slots__ = ("data",)
    DATA_FIELD_NUMBER: _ClassVar[int]
    data: _struct_pb2.Struct
    def __init__(self, data: _Optional[_Union[_struct_pb2.Struct, _Mapping]] = ...) -> None: ...

class Message(_message.Message):
    __slots__ = ("message_id", "context_id", "task_id", "role", "content", "metadata", "extensions")
    MESSAGE_ID_FIELD_NUMBER: _ClassVar[int]
    CONTEXT_ID_FIELD_NUMBER: _ClassVar[int]
    TASK_ID_FIELD_NUMBER: _ClassVar[int]
    ROLE_FIELD_NUMBER: _ClassVar[int]
    CONTENT_FIELD_NUMBER: _ClassVar[int]
    METADATA_FIELD_NUMBER: _ClassVar[int]
    EXTENSIONS_FIELD_NUMBER: _ClassVar[int]
    message_id: str
    context_id: str
    task_id: str
    role: Role
    content: _containers.RepeatedCompositeFieldContainer[Part]
    metadata: _struct_pb2.Struct
    extensions: _containers.RepeatedScalarFieldContainer[str]
    def __init__(self, message_id: _Optional[str] = ..., context_id: _Optional[str] = ..., task_id: _Optional[str] = ..., role: _Optional[_Union[Role, str]] = ..., content: _Optional[_Iterable[_Union[Part, _Mapping]]] = ..., metadata: _Optional[_Union[_struct_pb2.Struct, _Mapping]] = ..., extensions: _Optional[_Iterable[str]] = ...) -> None: ...

class Artifact(_message.Message):
    __slots__ = ("artifact_id", "name", "description", "parts", "metadata", "extensions")
    ARTIFACT_ID_FIELD_NUMBER: _ClassVar[int]
    NAME_FIELD_NUMBER: _ClassVar[int]
    DESCRIPTION_FIELD_NUMBER: _ClassVar[int]
    PARTS_FIELD_NUMBER: _ClassVar[int]
    METADATA_FIELD_NUMBER: _ClassVar[int]
    EXTENSIONS_FIELD_NUMBER: _ClassVar[int]
    artifact_id: str
    name: str
    description: str
    parts: _containers.RepeatedCompositeFieldContainer[Part]
    metadata: _struct_pb2.Struct
    extensions: _containers.RepeatedScalarFieldContainer[str]
    def __init__(self, artifact_id: _Optional[str] = ..., name: _Optional[str] = ..., description: _Optional[str] = ..., parts: _Optional[_Iterable[_Union[Part, _Mapping]]] = ..., metadata: _Optional[_Union[_struct_pb2.Struct, _Mapping]] = ..., extensions: _Optional[_Iterable[str]] = ...) -> None: ...

class TaskStatusUpdateEvent(_message.Message):
    __slots__ = ("task_id", "context_id", "status", "final", "metadata")
    TASK_ID_FIELD_NUMBER: _ClassVar[int]
    CONTEXT_ID_FIELD_NUMBER: _ClassVar[int]
    STATUS_FIELD_NUMBER: _ClassVar[int]
    FINAL_FIELD_NUMBER: _ClassVar[int]
    METADATA_FIELD_NUMBER: _ClassVar[int]
    task_id: str
    context_id: str
    status: TaskStatus
    final: bool
    metadata: _struct_pb2.Struct
    def __init__(self, task_id: _Optional[str] = ..., context_id: _Optional[str] = ..., status: _Optional[_Union[TaskStatus, _Mapping]] = ..., final: bool = ..., metadata: _Optional[_Union[_struct_pb2.Struct, _Mapping]] = ...) -> None: ...

class TaskArtifactUpdateEvent(_message.Message):
    __slots__ = ("task_id", "context_id", "artifact", "append", "last_chunk", "metadata")
    TASK_ID_FIELD_NUMBER: _ClassVar[int]
    CONTEXT_ID_FIELD_NUMBER: _ClassVar[int]
    ARTIFACT_FIELD_NUMBER: _ClassVar[int]
    APPEND_FIELD_NUMBER: _ClassVar[int]
    LAST_CHUNK_FIELD_NUMBER: _ClassVar[int]
    METADATA_FIELD_NUMBER: _ClassVar[int]
    task_id: str
    context_id: str
    artifact: Artifact
    append: bool
    last_chunk: bool
    metadata: _struct_pb2.Struct
    def __init__(self, task_id: _Optional[str] = ..., context_id: _Optional[str] = ..., artifact: _Optional[_Union[Artifact, _Mapping]] = ..., append: bool = ..., last_chunk: bool = ..., metadata: _Optional[_Union[_struct_pb2.Struct, _Mapping]] = ...) -> None: ...

class PushNotificationConfig(_message.Message):
    __slots__ = ("id", "url", "token", "authentication")
    ID_FIELD_NUMBER: _ClassVar[int]
    URL_FIELD_NUMBER: _ClassVar[int]
    TOKEN_FIELD_NUMBER: _ClassVar[int]
    AUTHENTICATION_FIELD_NUMBER: _ClassVar[int]
    id: str
    url: str
    token: str
    authentication: AuthenticationInfo
    def __init__(self, id: _Optional[str] = ..., url: _Optional[str] = ..., token: _Optional[str] = ..., authentication: _Optional[_Union[AuthenticationInfo, _Mapping]] = ...) -> None: ...

class AuthenticationInfo(_message.Message):
    __slots__ = ("schemes", "credentials")
    SCHEMES_FIELD_NUMBER: _ClassVar[int]
    CREDENTIALS_FIELD_NUMBER: _ClassVar[int]
    schemes: _containers.RepeatedScalarFieldContainer[str]
    credentials: str
    def __init__(self, schemes: _Optional[_Iterable[str]] = ..., credentials: _Optional[str] = ...) -> None: ...

class AgentInterface(_message.Message):
    __slots__ = ("url", "transport")
    URL_FIELD_NUMBER: _ClassVar[int]
    TRANSPORT_FIELD_NUMBER: _ClassVar[int]
    url: str
    transport: str
    def __init__(self, url: _Optional[str] = ..., transport: _Optional[str] = ...) -> None: ...

class AgentCard(_message.Message):
    __slots__ = ("protocol_version", "name", "description", "url", "preferred_transport", "additional_interfaces", "provider", "version", "documentation_url", "capabilities", "security_schemes", "security", "default_input_modes", "default_output_modes", "skills", "supports_authenticated_extended_card", "signatures")
    class SecuritySchemesEntry(_message.Message):
        __slots__ = ("key", "value")
        KEY_FIELD_NUMBER: _ClassVar[int]
        VALUE_FIELD_NUMBER: _ClassVar[int]
        key: str
        value: SecurityScheme
        def __init__(self, key: _Optional[str] = ..., value: _Optional[_Union[SecurityScheme, _Mapping]] = ...) -> None: ...
    PROTOCOL_VERSION_FIELD_NUMBER: _ClassVar[int]
    NAME_FIELD_NUMBER: _ClassVar[int]
    DESCRIPTION_FIELD_NUMBER: _ClassVar[int]
    URL_FIELD_NUMBER: _ClassVar[int]
    PREFERRED_TRANSPORT_FIELD_NUMBER: _ClassVar[int]
    ADDITIONAL_INTERFACES_FIELD_NUMBER: _ClassVar[int]
    PROVIDER_FIELD_NUMBER: _ClassVar[int]
    VERSION_FIELD_NUMBER: _ClassVar[int]
    DOCUMENTATION_URL_FIELD_NUMBER: _ClassVar[int]
    CAPABILITIES_FIELD_NUMBER: _ClassVar[int]
    SECURITY_SCHEMES_FIELD_NUMBER: _ClassVar[int]
    SECURITY_FIELD_NUMBER: _ClassVar[int]
    DEFAULT_INPUT_MODES_FIELD_NUMBER: _ClassVar[int]
    DEFAULT_OUTPUT_MODES_FIELD_NUMBER: _ClassVar[int]
    SKILLS_FIELD_NUMBER: _ClassVar[int]
    SUPPORTS_AUTHENTICATED_EXTENDED_CARD_FIELD_NUMBER: _ClassVar[int]
    SIGNATURES_FIELD_NUMBER: _ClassVar[int]
    protocol_version: str
    name: str
    description: str
    url: str
    preferred_transport: str
    additional_interfaces: _containers.RepeatedCompositeFieldContainer[AgentInterface]
    provider: AgentProvider
    version: str
    documentation_url: str
    capabilities: AgentCapabilities
    security_schemes: _containers.MessageMap[str, SecurityScheme]
    security: _containers.RepeatedCompositeFieldContainer[Security]
    default_input_modes: _containers.RepeatedScalarFieldContainer[str]
    default_output_modes: _containers.RepeatedScalarFieldContainer[str]
    skills: _containers.RepeatedCompositeFieldContainer[AgentSkill]
    supports_authenticated_extended_card: bool
    signatures: _containers.RepeatedCompositeFieldContainer[AgentCardSignature]
    def __init__(self, protocol_version: _Optional[str] = ..., name: _Optional[str] = ..., description: _Optional[str] = ..., url: _Optional[str] = ..., preferred_transport: _Optional[str] = ..., additional_interfaces: _Optional[_Iterable[_Union[AgentInterface, _Mapping]]] = ..., provider: _Optional[_Union[AgentProvider, _Mapping]] = ..., version: _Optional[str] = ..., documentation_url: _Optional[str] = ..., capabilities: _Optional[_Union[AgentCapabilities, _Mapping]] = ..., security_schemes: _Optional[_Mapping[str, SecurityScheme]] = ..., security: _Optional[_Iterable[_Union[Security, _Mapping]]] = ..., default_input_modes: _Optional[_Iterable[str]] = ..., default_output_modes: _Optional[_Iterable[str]] = ..., skills: _Optional[_Iterable[_Union[AgentSkill, _Mapping]]] = ..., supports_authenticated_extended_card: bool = ..., signatures: _Optional[_Iterable[_Union[AgentCardSignature, _Mapping]]] = ...) -> None: ...

class AgentProvider(_message.Message):
    __slots__ = ("url", "organization")
    URL_FIELD_NUMBER: _ClassVar[int]
    ORGANIZATION_FIELD_NUMBER: _ClassVar[int]
    url: str
    organization: str
    def __init__(self, url: _Optional[str] = ..., organization: _Optional[str] = ...) -> None: ...

class AgentCapabilities(_message.Message):
    __slots__ = ("streaming", "push_notifications", "extensions")
    STREAMING_FIELD_NUMBER: _ClassVar[int]
    PUSH_NOTIFICATIONS_FIELD_NUMBER: _ClassVar[int]
    EXTENSIONS_FIELD_NUMBER: _ClassVar[int]
    streaming: bool
    push_notifications: bool
    extensions: _containers.RepeatedCompositeFieldContainer[AgentExtension]
    def __init__(self, streaming: bool = ..., push_notifications: bool = ..., extensions: _Optional[_Iterable[_Union[AgentExtension, _Mapping]]] = ...) -> None: ...

class AgentExtension(_message.Message):
    __slots__ = ("uri", "description", "required", "params")
    URI_FIELD_NUMBER: _ClassVar[int]
    DESCRIPTION_FIELD_NUMBER: _ClassVar[int]
    REQUIRED_FIELD_NUMBER: _ClassVar[int]
    PARAMS_FIELD_NUMBER: _ClassVar[int]
    uri: str
    description: str
    required: bool
    params: _struct_pb2.Struct
    def __init__(self, uri: _Optional[str] = ..., description: _Optional[str] = ..., required: bool = ..., params: _Optional[_Union[_struct_pb2.Struct, _Mapping]] = ...) -> None: ...

class AgentSkill(_message.Message):
    __slots__ = ("id", "name", "description", "tags", "examples", "input_modes", "output_modes", "security")
    ID_FIELD_NUMBER: _ClassVar[int]
    NAME_FIELD_NUMBER: _ClassVar[int]
    DESCRIPTION_FIELD_NUMBER: _ClassVar[int]
    TAGS_FIELD_NUMBER: _ClassVar[int]
    EXAMPLES_FIELD_NUMBER: _ClassVar[int]
    INPUT_MODES_FIELD_NUMBER: _ClassVar[int]
    OUTPUT_MODES_FIELD_NUMBER: _ClassVar[int]
    SECURITY_FIELD_NUMBER: _ClassVar[int]
    id: str
    name: str
    description: str
    tags: _containers.RepeatedScalarFieldContainer[str]
    examples: _containers.RepeatedScalarFieldContainer[str]
    input_modes: _containers.RepeatedScalarFieldContainer[str]
    output_modes: _containers.RepeatedScalarFieldContainer[str]
    security: _containers.RepeatedCompositeFieldContainer[Security]
    def __init__(self, id: _Optional[str] = ..., name: _Optional[str] = ..., description: _Optional[str] = ..., tags: _Optional[_Iterable[str]] = ..., examples: _Optional[_Iterable[str]] = ..., input_modes: _Optional[_Iterable[str]] = ..., output_modes: _Optional[_Iterable[str]] = ..., security: _Optional[_Iterable[_Union[Security, _Mapping]]] = ...) -> None: ...

class AgentCardSignature(_message.Message):
    __slots__ = ("protected", "signature", "header")
    PROTECTED_FIELD_NUMBER: _ClassVar[int]
    SIGNATURE_FIELD_NUMBER: _ClassVar[int]
    HEADER_FIELD_NUMBER: _ClassVar[int]
    protected: str
    signature: str
    header: _struct_pb2.Struct
    def __init__(self, protected: _Optional[str] = ..., signature: _Optional[str] = ..., header: _Optional[_Union[_struct_pb2.Struct, _Mapping]] = ...) -> None: ...

class TaskPushNotificationConfig(_message.Message):
    __slots__ = ("name", "push_notification_config")
    NAME_FIELD_NUMBER: _ClassVar[int]
    PUSH_NOTIFICATION_CONFIG_FIELD_NUMBER: _ClassVar[int]
    name: str
    push_notification_config: PushNotificationConfig
    def __init__(self, name: _Optional[str] = ..., push_notification_config: _Optional[_Union[PushNotificationConfig, _Mapping]] = ...) -> None: ...

class StringList(_message.Message):
    __slots__ = ("list",)
    LIST_FIELD_NUMBER: _ClassVar[int]
    list: _containers.RepeatedScalarFieldContainer[str]
    def __init__(self, list: _Optional[_Iterable[str]] = ...) -> None: ...

class Security(_message.Message):
    __slots__ = ("schemes",)
    class SchemesEntry(_message.Message):
        __slots__ = ("key", "value")
        KEY_FIELD_NUMBER: _ClassVar[int]
        VALUE_FIELD_NUMBER: _ClassVar[int]
        key: str
        value: StringList
        def __init__(self, key: _Optional[str] = ..., value: _Optional[_Union[StringList, _Mapping]] = ...) -> None: ...
    SCHEMES_FIELD_NUMBER: _ClassVar[int]
    schemes: _containers.MessageMap[str, StringList]
    def __init__(self, schemes: _Optional[_Mapping[str, StringList]] = ...) -> None: ...

class SecurityScheme(_message.Message):
    __slots__ = ("api_key_security_scheme", "http_auth_security_scheme", "oauth2_security_scheme", "open_id_connect_security_scheme", "mtls_security_scheme")
    API_KEY_SECURITY_SCHEME_FIELD_NUMBER: _ClassVar[int]
    HTTP_AUTH_SECURITY_SCHEME_FIELD_NUMBER: _ClassVar[int]
    OAUTH2_SECURITY_SCHEME_FIELD_NUMBER: _ClassVar[int]
    OPEN_ID_CONNECT_SECURITY_SCHEME_FIELD_NUMBER: _ClassVar[int]
    MTLS_SECURITY_SCHEME_FIELD_NUMBER: _ClassVar[int]
    api_key_security_scheme: APIKeySecurityScheme
    http_auth_security_scheme: HTTPAuthSecurityScheme
    oauth2_security_scheme: OAuth2SecurityScheme
    open_id_connect_security_scheme: OpenIdConnectSecurityScheme
    mtls_security_scheme: MutualTlsSecurityScheme
    def __init__(self, api_key_security_scheme: _Optional[_Union[APIKeySecurityScheme, _Mapping]] = ..., http_auth_security_scheme: _Optional[_Union[HTTPAuthSecurityScheme, _Mapping]] = ..., oauth2_security_scheme: _Optional[_Union[OAuth2SecurityScheme, _Mapping]] = ..., open_id_connect_security_scheme: _Optional[_Union[OpenIdConnectSecurityScheme, _Mapping]] = ..., mtls_security_scheme: _Optional[_Union[MutualTlsSecurityScheme, _Mapping]] = ...) -> None: ...

class APIKeySecurityScheme(_message.Message):
    __slots__ = ("description", "location", "name")
    DESCRIPTION_FIELD_NUMBER: _ClassVar[int]
    LOCATION_FIELD_NUMBER: _ClassVar[int]
    NAME_FIELD_NUMBER: _ClassVar[int]
    description: str
    location: str
    name: str
    def __init__(self, description: _Optional[str] = ..., location: _Optional[str] = ..., name: _Optional[str] = ...) -> None: ...

class HTTPAuthSecurityScheme(_message.Message):
    __slots__ = ("description", "scheme", "bearer_format")
    DESCRIPTION_FIELD_NUMBER: _ClassVar[int]
    SCHEME_FIELD_NUMBER: _ClassVar[int]
    BEARER_FORMAT_FIELD_NUMBER: _ClassVar[int]
    description: str
    scheme: str
    bearer_format: str
    def __init__(self, description: _Optional[str] = ..., scheme: _Optional[str] = ..., bearer_format: _Optional[str] = ...) -> None: ...

class OAuth2SecurityScheme(_message.Message):
    __slots__ = ("description", "flows", "oauth2_metadata_url")
    DESCRIPTION_FIELD_NUMBER: _ClassVar[int]
    FLOWS_FIELD_NUMBER: _ClassVar[int]
    OAUTH2_METADATA_URL_FIELD_NUMBER: _ClassVar[int]
    description: str
    flows: OAuthFlows
    oauth2_metadata_url: str
    def __init__(self, description: _Optional[str] = ..., flows: _Optional[_Union[OAuthFlows, _Mapping]] = ..., oauth2_metadata_url: _Optional[str] = ...) -> None: ...

class OpenIdConnectSecurityScheme(_message.Message):
    __slots__ = ("description", "open_id_connect_url")
    DESCRIPTION_FIELD_NUMBER: _ClassVar[int]
    OPEN_ID_CONNECT_URL_FIELD_NUMBER: _ClassVar[int]
    description: str
    open_id_connect_url: str
    def __init__(self, description: _Optional[str] = ..., open_id_connect_url: _Optional[str] = ...) -> None: ...

class MutualTlsSecurityScheme(_message.Message):
    __slots__ = ("description",)
    DESCRIPTION_FIELD_NUMBER: _ClassVar[int]
    description: str
    def __init__(self, description: _Optional[str] = ...) -> None: ...

class OAuthFlows(_message.Message):
    __slots__ = ("authorization_code", "client_credentials", "implicit", "password")
    AUTHORIZATION_CODE_FIELD_NUMBER: _ClassVar[int]
    CLIENT_CREDENTIALS_FIELD_NUMBER: _ClassVar[int]
    IMPLICIT_FIELD_NUMBER: _ClassVar[int]
    PASSWORD_FIELD_NUMBER: _ClassVar[int]
    authorization_code: AuthorizationCodeOAuthFlow
    client_credentials: ClientCredentialsOAuthFlow
    implicit: ImplicitOAuthFlow
    password: PasswordOAuthFlow
    def __init__(self, authorization_code: _Optional[_Union[AuthorizationCodeOAuthFlow, _Mapping]] = ..., client_credentials: _Optional[_Union[ClientCredentialsOAuthFlow, _Mapping]] = ..., implicit: _Optional[_Union[ImplicitOAuthFlow, _Mapping]] = ..., password: _Optional[_Union[PasswordOAuthFlow, _Mapping]] = ...) -> None: ...

class AuthorizationCodeOAuthFlow(_message.Message):
    __slots__ = ("authorization_url", "token_url", "refresh_url", "scopes")
    class ScopesEntry(_message.Message):
        __slots__ = ("key", "value")
        KEY_FIELD_NUMBER: _ClassVar[int]
        VALUE_FIELD_NUMBER: _ClassVar[int]
        key: str
        value: str
        def __init__(self, key: _Optional[str] = ..., value: _Optional[str] = ...) -> None: ...
    AUTHORIZATION_URL_FIELD_NUMBER: _ClassVar[int]
    TOKEN_URL_FIELD_NUMBER: _ClassVar[int]
    REFRESH_URL_FIELD_NUMBER: _ClassVar[int]
    SCOPES_FIELD_NUMBER: _ClassVar[int]
    authorization_url: str
    token_url: str
    refresh_url: str
    scopes: _containers.ScalarMap[str, str]
    def __init__(self, authorization_url: _Optional[str] = ..., token_url: _Optional[str] = ..., refresh_url: _Optional[str] = ..., scopes: _Optional[_Mapping[str, str]] = ...) -> None: ...

class ClientCredentialsOAuthFlow(_message.Message):
    __slots__ = ("token_url", "refresh_url", "scopes")
    class ScopesEntry(_message.Message):
        __slots__ = ("key", "value")
        KEY_FIELD_NUMBER: _ClassVar[int]
        VALUE_FIELD_NUMBER: _ClassVar[int]
        key: str
        value: str
        def __init__(self, key: _Optional[str] = ..., value: _Optional[str] = ...) -> None: ...
    TOKEN_URL_FIELD_NUMBER: _ClassVar[int]
    REFRESH_URL_FIELD_NUMBER: _ClassVar[int]
    SCOPES_FIELD_NUMBER: _ClassVar[int]
    token_url: str
    refresh_url: str
    scopes: _containers.ScalarMap[str, str]
    def __init__(self, token_url: _Optional[str] = ..., refresh_url: _Optional[str] = ..., scopes: _Optional[_Mapping[str, str]] = ...) -> None: ...

class ImplicitOAuthFlow(_message.Message):
    __slots__ = ("authorization_url", "refresh_url", "scopes")
    class ScopesEntry(_message.Message):
        __slots__ = ("key", "value")
        KEY_FIELD_NUMBER: _ClassVar[int]
        VALUE_FIELD_NUMBER: _ClassVar[int]
        key: str
        value: str
        def __init__(self, key: _Optional[str] = ..., value: _Optional[str] = ...) -> None: ...
    AUTHORIZATION_URL_FIELD_NUMBER: _ClassVar[int]
    REFRESH_URL_FIELD_NUMBER: _ClassVar[int]
    SCOPES_FIELD_NUMBER: _ClassVar[int]
    authorization_url: str
    refresh_url: str
    scopes: _containers.ScalarMap[str, str]
    def __init__(self, authorization_url: _Optional[str] = ..., refresh_url: _Optional[str] = ..., scopes: _Optional[_Mapping[str, str]] = ...) -> None: ...

class PasswordOAuthFlow(_message.Message):
    __slots__ = ("token_url", "refresh_url", "scopes")
    class ScopesEntry(_message.Message):
        __slots__ = ("key", "value")
        KEY_FIELD_NUMBER: _ClassVar[int]
        VALUE_FIELD_NUMBER: _ClassVar[int]
        key: str
        value: str
        def __init__(self, key: _Optional[str] = ..., value: _Optional[str] = ...) -> None: ...
    TOKEN_URL_FIELD_NUMBER: _ClassVar[int]
    REFRESH_URL_FIELD_NUMBER: _ClassVar[int]
    SCOPES_FIELD_NUMBER: _ClassVar[int]
    token_url: str
    refresh_url: str
    scopes: _containers.ScalarMap[str, str]
    def __init__(self, token_url: _Optional[str] = ..., refresh_url: _Optional[str] = ..., scopes: _Optional[_Mapping[str, str]] = ...) -> None: ...

class SendMessageRequest(_message.Message):
    __slots__ = ("request", "configuration", "metadata")
    REQUEST_FIELD_NUMBER: _ClassVar[int]
    CONFIGURATION_FIELD_NUMBER: _ClassVar[int]
    METADATA_FIELD_NUMBER: _ClassVar[int]
    request: Message
    configuration: SendMessageConfiguration
    metadata: _struct_pb2.Struct
    def __init__(self, request: _Optional[_Union[Message, _Mapping]] = ..., configuration: _Optional[_Union[SendMessageConfiguration, _Mapping]] = ..., metadata: _Optional[_Union[_struct_pb2.Struct, _Mapping]] = ...) -> None: ...

class GetTaskRequest(_message.Message):
    __slots__ = ("name", "history_length")
    NAME_FIELD_NUMBER: _ClassVar[int]
    HISTORY_LENGTH_FIELD_NUMBER: _ClassVar[int]
    name: str
    history_length: int
    def __init__(self, name: _Optional[str] = ..., history_length: _Optional[int] = ...) -> None: ...

class CancelTaskRequest(_message.Message):
    __slots__ = ("name",)
    NAME_FIELD_NUMBER: _ClassVar[int]
    name: str
    def __init__(self, name: _Optional[str] = ...) -> None: ...

class GetTaskPushNotificationConfigRequest(_message.Message):
    __slots__ = ("name",)
    NAME_FIELD_NUMBER: _ClassVar[int]
    name: str
    def __init__(self, name: _Optional[str] = ...) -> None: ...

class DeleteTaskPushNotificationConfigRequest(_message.Message):
    __slots__ = ("name",)
    NAME_FIELD_NUMBER: _ClassVar[int]
    name: str
    def __init__(self, name: _Optional[str] = ...) -> None: ...

class CreateTaskPushNotificationConfigRequest(_message.Message):
    __slots__ = ("parent", "config_id", "config")
    PARENT_FIELD_NUMBER: _ClassVar[int]
    CONFIG_ID_FIELD_NUMBER: _ClassVar[int]
    CONFIG_FIELD_NUMBER: _ClassVar[int]
    parent: str
    config_id: str
    config: TaskPushNotificationConfig
    def __init__(self, parent: _Optional[str] = ..., config_id: _Optional[str] = ..., config: _Optional[_Union[TaskPushNotificationConfig, _Mapping]] = ...) -> None: ...

class TaskSubscriptionRequest(_message.Message):
    __slots__ = ("name",)
    NAME_FIELD_NUMBER: _ClassVar[int]
    name: str
    def __init__(self, name: _Optional[str] = ...) -> None: ...

class ListTaskPushNotificationConfigRequest(_message.Message):
    __slots__ = ("parent", "page_size", "page_token")
    PARENT_FIELD_NUMBER: _ClassVar[int]
    PAGE_SIZE_FIELD_NUMBER: _ClassVar[int]
    PAGE_TOKEN_FIELD_NUMBER: _ClassVar[int]
    parent: str
    page_size: int
    page_token: str
    def __init__(self, parent: _Optional[str] = ..., page_size: _Optional[int] = ..., page_token: _Optional[str] = ...) -> None: ...

class GetAgentCardRequest(_message.Message):
    __slots__ = ()
    def __init__(self) -> None: ...

class SendMessageResponse(_message.Message):
    __slots__ = ("task", "msg")
    TASK_FIELD_NUMBER: _ClassVar[int]
    MSG_FIELD_NUMBER: _ClassVar[int]
    task: Task
    msg: Message
    def __init__(self, task: _Optional[_Union[Task, _Mapping]] = ..., msg: _Optional[_Union[Message, _Mapping]] = ...) -> None: ...

class StreamResponse(_message.Message):
    __slots__ = ("task", "msg", "status_update", "artifact_update")
    TASK_FIELD_NUMBER: _ClassVar[int]
    MSG_FIELD_NUMBER: _ClassVar[int]
    STATUS_UPDATE_FIELD_NUMBER: _ClassVar[int]
    ARTIFACT_UPDATE_FIELD_NUMBER: _ClassVar[int]
    task: Task
    msg: Message
    status_update: TaskStatusUpdateEvent
    artifact_update: TaskArtifactUpdateEvent
    def __init__(self, task: _Optional[_Union[Task, _Mapping]] = ..., msg: _Optional[_Union[Message, _Mapping]] = ..., status_update: _Optional[_Union[TaskStatusUpdateEvent, _Mapping]] = ..., artifact_update: _Optional[_Union[TaskArtifactUpdateEvent, _Mapping]] = ...) -> None: ...

class ListTaskPushNotificationConfigResponse(_message.Message):
    __slots__ = ("configs", "next_page_token")
    CONFIGS_FIELD_NUMBER: _ClassVar[int]
    NEXT_PAGE_TOKEN_FIELD_NUMBER: _ClassVar[int]
    configs: _containers.RepeatedCompositeFieldContainer[TaskPushNotificationConfig]
    next_page_token: str
    def __init__(self, configs: _Optional[_Iterable[_Union[TaskPushNotificationConfig, _Mapping]]] = ..., next_page_token: _Optional[str] = ...) -> None: ...

================
File: src/a2a/server/agent_execution/__init__.py
================
"""Components for executing agent logic within the A2A server."""
⋮----
__all__ = [

================
File: src/a2a/server/agent_execution/agent_executor.py
================
class AgentExecutor(ABC)
⋮----
"""Agent Executor interface.

    Implementations of this interface contain the core logic of the agent,
    executing tasks based on requests and publishing updates to an event queue.
    """
⋮----
"""Execute the agent's logic for a given request context.

        The agent should read necessary information from the `context` and
        publish `Task` or `Message` events, or `TaskStatusUpdateEvent` /
        `TaskArtifactUpdateEvent` to the `event_queue`. This method should
        return once the agent's execution for this request is complete or
        yields control (e.g., enters an input-required state).

        Args:
            context: The request context containing the message, task ID, etc.
            event_queue: The queue to publish events to.
        """
⋮----
"""Request the agent to cancel an ongoing task.

        The agent should attempt to stop the task identified by the task_id
        in the context and publish a `TaskStatusUpdateEvent` with state
        `TaskState.canceled` to the `event_queue`.

        Args:
            context: The request context containing the task ID to cancel.
            event_queue: The queue to publish the cancellation status update to.
        """

================
File: src/a2a/server/agent_execution/context.py
================
class RequestContext
⋮----
"""Request Context.

    Holds information about the current request being processed by the server,
    including the incoming message, task and context identifiers, and related
    tasks.
    """
⋮----
def __init__(  # noqa: PLR0913
⋮----
"""Initializes the RequestContext.

        Args:
            request: The incoming `MessageSendParams` request payload.
            task_id: The ID of the task explicitly provided in the request or path.
            context_id: The ID of the context explicitly provided in the request or path.
            task: The existing `Task` object retrieved from the store, if any.
            related_tasks: A list of other tasks related to the current request (e.g., for tool use).
            call_context: The server call context associated with this request.
        """
⋮----
related_tasks = []
⋮----
# If the task id and context id were provided, make sure they
# match the request. Otherwise, create them
⋮----
def get_user_input(self, delimiter: str = '\n') -> str
⋮----
"""Extracts text content from the user's message parts.

        Args:
            delimiter: The string to use when joining multiple text parts.

        Returns:
            A single string containing all text content from the user message,
            joined by the specified delimiter. Returns an empty string if no
            user message is present or if it contains no text parts.
        """
⋮----
def attach_related_task(self, task: Task) -> None
⋮----
"""Attaches a related task to the context.

        This is useful for scenarios like tool execution where a new task
        might be spawned.

        Args:
            task: The `Task` object to attach.
        """
⋮----
@property
    def message(self) -> Message | None
⋮----
"""The incoming `Message` object from the request, if available."""
⋮----
@property
    def related_tasks(self) -> list[Task]
⋮----
"""A list of tasks related to the current request."""
⋮----
@property
    def current_task(self) -> Task | None
⋮----
"""The current `Task` object being processed."""
⋮----
@current_task.setter
    def current_task(self, task: Task) -> None
⋮----
"""Sets the current task object."""
⋮----
@property
    def task_id(self) -> str | None
⋮----
"""The ID of the task associated with this context."""
⋮----
@property
    def context_id(self) -> str | None
⋮----
"""The ID of the conversation context associated with this task."""
⋮----
@property
    def configuration(self) -> MessageSendConfiguration | None
⋮----
"""The `MessageSendConfiguration` from the request, if available."""
⋮----
@property
    def call_context(self) -> ServerCallContext | None
⋮----
"""The server call context associated with this request."""
⋮----
@property
    def metadata(self) -> dict[str, Any]
⋮----
"""Metadata associated with the request, if available."""
⋮----
def add_activated_extension(self, uri: str) -> None
⋮----
"""Add an extension to the set of activated extensions for this request.

        This causes the extension to be indicated back to the client in the
        response.
        """
⋮----
@property
    def requested_extensions(self) -> set[str]
⋮----
"""Extensions that the client requested to activate."""
⋮----
def _check_or_generate_task_id(self) -> None
⋮----
"""Ensures a task ID is present, generating one if necessary."""
⋮----
def _check_or_generate_context_id(self) -> None
⋮----
"""Ensures a context ID is present, generating one if necessary."""

================
File: src/a2a/server/agent_execution/request_context_builder.py
================
class RequestContextBuilder(ABC)
⋮----
"""Builds request context to be supplied to agent executor."""

================
File: src/a2a/server/agent_execution/simple_request_context_builder.py
================
class SimpleRequestContextBuilder(RequestContextBuilder)
⋮----
"""Builds request context and populates referred tasks."""
⋮----
"""Initializes the SimpleRequestContextBuilder.

        Args:
            should_populate_referred_tasks: If True, the builder will fetch tasks
                referenced in `params.message.reference_task_ids` and populate the
                `related_tasks` field in the RequestContext. Defaults to False.
            task_store: The TaskStore instance to use for fetching referred tasks.
                Required if `should_populate_referred_tasks` is True.
        """
⋮----
"""Builds the request context for an agent execution.

        This method assembles the RequestContext object. If the builder was
        initialized with `should_populate_referred_tasks=True`, it fetches all tasks
        referenced in `params.message.reference_task_ids` from the `task_store`.

        Args:
            params: The parameters of the incoming message send request.
            task_id: The ID of the task being executed.
            context_id: The ID of the current execution context.
            task: The primary task object associated with the request.
            context: The server call context, containing metadata about the call.

        Returns:
            An instance of RequestContext populated with the provided information
            and potentially a list of related tasks.
        """
related_tasks: list[Task] | None = None
⋮----
tasks = await asyncio.gather(
related_tasks = [x for x in tasks if x is not None]

================
File: src/a2a/server/apps/jsonrpc/__init__.py
================
"""A2A JSON-RPC Applications."""
⋮----
__all__ = [

================
File: src/a2a/server/apps/jsonrpc/fastapi_app.py
================
logger = logging.getLogger(__name__)
⋮----
class A2AFastAPIApplication(JSONRPCApplication)
⋮----
"""A FastAPI application implementing the A2A protocol server endpoints.

    Handles incoming JSON-RPC requests, routes them to the appropriate
    handler methods, and manages response generation including Server-Sent Events
    (SSE).
    """
⋮----
"""Adds the routes to the FastAPI application.

        Args:
            app: The FastAPI application to add the routes to.
            agent_card_url: The URL for the agent card endpoint.
            rpc_url: The URL for the A2A JSON-RPC endpoint.
            extended_agent_card_url: The URL for the authenticated extended agent card endpoint.
        """
⋮----
# For backward compatibility, serve the agent card at the deprecated path as well.
# TODO: remove in a future release
⋮----
"""Builds and returns the FastAPI application instance.

        Args:
            agent_card_url: The URL for the agent card endpoint.
            rpc_url: The URL for the A2A JSON-RPC endpoint.
            extended_agent_card_url: The URL for the authenticated extended agent card endpoint.
            **kwargs: Additional keyword arguments to pass to the FastAPI constructor.

        Returns:
            A configured FastAPI application instance.
        """
⋮----
@asynccontextmanager
        async def lifespan(app: FastAPI) -> AsyncIterator[None]
⋮----
a2a_request_schema = A2ARequest.model_json_schema(
defs = a2a_request_schema.pop('$defs', {})
openapi_schema = app.openapi()
component_schemas = openapi_schema.setdefault(
⋮----
app = FastAPI(lifespan=lifespan, **kwargs)

================
File: src/a2a/server/apps/jsonrpc/jsonrpc_app.py
================
logger = logging.getLogger(__name__)
⋮----
class StarletteUserProxy(A2AUser)
⋮----
"""Adapts the Starlette User class to the A2A user representation."""
⋮----
def __init__(self, user: BaseUser)
⋮----
@property
    def is_authenticated(self) -> bool
⋮----
"""Returns whether the current user is authenticated."""
⋮----
@property
    def user_name(self) -> str
⋮----
"""Returns the user name of the current user."""
⋮----
class CallContextBuilder(ABC)
⋮----
"""A class for building ServerCallContexts using the Starlette Request."""
⋮----
@abstractmethod
    def build(self, request: Request) -> ServerCallContext
⋮----
"""Builds a ServerCallContext from a Starlette Request."""
⋮----
class DefaultCallContextBuilder(CallContextBuilder)
⋮----
"""A default implementation of CallContextBuilder."""
⋮----
def build(self, request: Request) -> ServerCallContext
⋮----
"""Builds a ServerCallContext from a Starlette Request.

        Args:
            request: The incoming Starlette Request object.

        Returns:
            A ServerCallContext instance populated with user and state
            information from the request.
        """
user: A2AUser = UnauthenticatedUser()
state = {}
⋮----
user = StarletteUserProxy(request.user)
⋮----
class JSONRPCApplication(ABC)
⋮----
"""Base class for A2A JSONRPC applications.

    Handles incoming JSON-RPC requests, routes them to the appropriate
    handler methods, and manages response generation including Server-Sent Events
    (SSE).
    """
⋮----
def __init__(  # noqa: PLR0913
⋮----
"""Initializes the A2AStarletteApplication.

        Args:
            agent_card: The AgentCard describing the agent's capabilities.
            http_handler: The handler instance responsible for processing A2A
              requests via http.
            extended_agent_card: An optional, distinct AgentCard to be served
              at the authenticated extended card endpoint.
            context_builder: The CallContextBuilder used to construct the
              ServerCallContext passed to the http_handler. If None, no
              ServerCallContext is passed.
            card_modifier: An optional callback to dynamically modify the public
              agent card before it is served.
            extended_card_modifier: An optional callback to dynamically modify
              the extended agent card before it is served. It receives the
              call context.
        """
⋮----
"""Creates a Starlette JSONResponse for a JSON-RPC error.

        Logs the error based on its type.

        Args:
            request_id: The ID of the request that caused the error.
            error: The `JSONRPCError` or `A2AError` object.

        Returns:
            A `JSONResponse` object formatted as a JSON-RPC error response.
        """
error_resp = JSONRPCErrorResponse(
⋮----
log_level = (
⋮----
async def _handle_requests(self, request: Request) -> Response:  # noqa: PLR0911
⋮----
"""Handles incoming POST requests to the main A2A endpoint.

        Parses the request body as JSON, validates it against A2A request types,
        dispatches it to the appropriate handler method, and returns the response.
        Handles JSON parsing errors, validation errors, and other exceptions,
        returning appropriate JSON-RPC error responses.

        Args:
            request: The incoming Starlette Request object.

        Returns:
            A Starlette Response object (JSONResponse or EventSourceResponse).

        Raises:
            (Implicitly handled): Various exceptions are caught and converted
            into JSON-RPC error responses by this method.
        """
request_id = None
body = None
⋮----
body = await request.json()
⋮----
request_id = body.get('id')
⋮----
# First, validate the basic JSON-RPC structure. This is crucial
# because the A2ARequest model is a discriminated union where some
# request types have default values for the 'method' field
⋮----
a2a_request = A2ARequest.model_validate(body)
⋮----
call_context = self._context_builder.build(request)
⋮----
request_id = a2a_request.root.id
request_obj = a2a_request.root
⋮----
"""Processes streaming requests (message/stream or tasks/resubscribe).

        Args:
            request_id: The ID of the request.
            a2a_request: The validated A2ARequest object.
            context: The ServerCallContext for the request.

        Returns:
            An `EventSourceResponse` object to stream results to the client.
        """
⋮----
handler_result: Any = None
⋮----
handler_result = self.handler.on_message_send_stream(
⋮----
handler_result = self.handler.on_resubscribe_to_task(
⋮----
"""Processes non-streaming requests (message/send, tasks/get, tasks/cancel, tasks/pushNotificationConfig/*).

        Args:
            request_id: The ID of the request.
            a2a_request: The validated A2ARequest object.
            context: The ServerCallContext for the request.

        Returns:
            A `JSONResponse` object containing the result or error.
        """
⋮----
handler_result = await self.handler.on_message_send(
⋮----
handler_result = await self.handler.on_cancel_task(
⋮----
handler_result = await self.handler.on_get_task(
⋮----
handler_result = (
⋮----
error = UnsupportedOperationError(
handler_result = JSONRPCErrorResponse(
⋮----
"""Creates a Starlette Response based on the result from the request handler.

        Handles:
        - AsyncGenerator for Server-Sent Events (SSE).
        - JSONRPCErrorResponse for explicit errors returned by handlers.
        - Pydantic RootModels (like GetTaskResponse) containing success or error
        payloads.

        Args:
            context: The ServerCallContext provided to the request handler.
            handler_result: The result from a request handler method. Can be an
                async generator for streaming or a Pydantic model for non-streaming.

        Returns:
            A Starlette JSONResponse or EventSourceResponse.
        """
headers = {}
⋮----
# Result is a stream of SendStreamingMessageResponse objects
⋮----
async def _handle_get_agent_card(self, request: Request) -> JSONResponse
⋮----
"""Handles GET requests for the agent card endpoint.

        Args:
            request: The incoming Starlette Request object.

        Returns:
            A JSONResponse containing the agent card data.
        """
⋮----
card_to_serve = self.agent_card
⋮----
card_to_serve = self.card_modifier(card_to_serve)
⋮----
"""Handles GET requests for the authenticated extended agent card."""
⋮----
card_to_serve = self.extended_agent_card
⋮----
context = self._context_builder.build(request)
# If no base extended card is provided, pass the public card to the modifier
base_card = card_to_serve if card_to_serve else self.agent_card
card_to_serve = self.extended_card_modifier(base_card, context)
⋮----
# If supports_authenticated_extended_card is true, but no
# extended_agent_card was provided, and no modifier produced a card,
# return a 404.
⋮----
"""Builds and returns the JSONRPC application instance.

        Args:
            agent_card_url: The URL for the agent card endpoint.
            rpc_url: The URL for the A2A JSON-RPC endpoint.
            extended_agent_card_url: The URL for the authenticated extended
              agent card endpoint.
            **kwargs: Additional keyword arguments to pass to the FastAPI constructor.

        Returns:
            A configured JSONRPC application instance.
        """

================
File: src/a2a/server/apps/jsonrpc/starlette_app.py
================
logger = logging.getLogger(__name__)
⋮----
class A2AStarletteApplication(JSONRPCApplication)
⋮----
"""A Starlette application implementing the A2A protocol server endpoints.

    Handles incoming JSON-RPC requests, routes them to the appropriate
    handler methods, and manages response generation including Server-Sent Events
    (SSE).
    """
⋮----
"""Returns the Starlette Routes for handling A2A requests.

        Args:
            agent_card_url: The URL path for the agent card endpoint.
            rpc_url: The URL path for the A2A JSON-RPC endpoint (POST requests).
            extended_agent_card_url: The URL for the authenticated extended agent card endpoint.

        Returns:
            A list of Starlette Route objects.
        """
app_routes = [
⋮----
# For backward compatibility, serve the agent card at the deprecated path as well.
# TODO: remove in a future release
⋮----
# TODO: deprecated endpoint to be removed in a future release
⋮----
"""Adds the routes to the Starlette application.

        Args:
            app: The Starlette application to add the routes to.
            agent_card_url: The URL path for the agent card endpoint.
            rpc_url: The URL path for the A2A JSON-RPC endpoint (POST requests).
            extended_agent_card_url: The URL for the authenticated extended agent card endpoint.
        """
routes = self.routes(
⋮----
"""Builds and returns the Starlette application instance.

        Args:
            agent_card_url: The URL path for the agent card endpoint.
            rpc_url: The URL path for the A2A JSON-RPC endpoint (POST requests).
            extended_agent_card_url: The URL for the authenticated extended agent card endpoint.
            **kwargs: Additional keyword arguments to pass to the Starlette constructor.

        Returns:
            A configured Starlette application instance.
        """
app = Starlette(**kwargs)

================
File: src/a2a/server/apps/rest/__init__.py
================
"""A2A REST Applications."""
⋮----
__all__ = [

================
File: src/a2a/server/apps/rest/fastapi_app.py
================
logger = logging.getLogger(__name__)
⋮----
class A2ARESTFastAPIApplication
⋮----
"""A FastAPI application implementing the A2A protocol server REST endpoints.

    Handles incoming REST requests, routes them to the appropriate
    handler methods, and manages response generation including Server-Sent Events
    (SSE).
    """
⋮----
"""Initializes the A2ARESTFastAPIApplication.

        Args:
            agent_card: The AgentCard describing the agent's capabilities.
            http_handler: The handler instance responsible for processing A2A
              requests via http.
            extended_agent_card: An optional, distinct AgentCard to be served
              at the authenticated extended card endpoint.
            context_builder: The CallContextBuilder used to construct the
              ServerCallContext passed to the http_handler. If None, no
              ServerCallContext is passed.
        """
⋮----
"""Builds and returns the FastAPI application instance.

        Args:
            agent_card_url: The URL for the agent card endpoint.
            rpc_url: The URL for the A2A JSON-RPC endpoint.
            extended_agent_card_url: The URL for the authenticated extended agent card endpoint.
            **kwargs: Additional keyword arguments to pass to the FastAPI constructor.

        Returns:
            A configured FastAPI application instance.
        """
app = FastAPI(**kwargs)
router = APIRouter()
⋮----
@router.get(f'{rpc_url}{agent_card_url}')
        async def get_agent_card(request: Request) -> Response

================
File: src/a2a/server/apps/rest/rest_adapter.py
================
logger = logging.getLogger(__name__)
⋮----
class RESTAdapter
⋮----
"""Adapter to make RequestHandler work with RESTful API.

    Defines REST requests processors and the routes to attach them too, as well as
    manages response generation including Server-Sent Events (SSE).
    """
⋮----
"""Initializes the RESTApplication.

        Args:
            agent_card: The AgentCard describing the agent's capabilities.
            http_handler: The handler instance responsible for processing A2A
              requests via http.
            context_builder: The CallContextBuilder used to construct the
              ServerCallContext passed to the http_handler. If None, no
              ServerCallContext is passed.
        """
⋮----
call_context = self._context_builder.build(request)
response = await method(request, call_context)
⋮----
@rest_error_handler
    async def handle_get_agent_card(self, request: Request) -> JSONResponse
⋮----
"""Handles GET requests for the agent card endpoint.

        Args:
            request: The incoming Starlette Request object.

        Returns:
            A JSONResponse containing the agent card data.
        """
# The public agent card is a direct serialization of the agent_card
# provided at initialization.
⋮----
"""Hook for per credential agent card response.

        If a dynamic card is needed based on the credentials provided in the request
        override this method and return the customized content.

        Args:
            request: The incoming Starlette Request  object.

        Returns:
            A JSONResponse containing the authenticated card.
        """
⋮----
def routes(self) -> dict[tuple[str, str], Callable[[Request], Any]]
⋮----
"""Constructs a dictionary of API routes and their corresponding handlers.

        This method maps URL paths and HTTP methods to the appropriate handler
        functions from the RESTHandler. It can be used by a web framework
        (like Starlette or FastAPI) to set up the application's endpoints.

        Returns:
            A dictionary where each key is a tuple of (path, http_method) and
            the value is the callable handler for that route.
        """
routes: dict[tuple[str, str], Callable[[Request], Any]] = {

================
File: src/a2a/server/apps/__init__.py
================
"""HTTP application components for the A2A server."""
⋮----
__all__ = [

================
File: src/a2a/server/events/__init__.py
================
"""Event handling components for the A2A server."""
⋮----
__all__ = [

================
File: src/a2a/server/events/event_consumer.py
================
# This is an alias to the exception for closed queue
QueueClosed: type[Exception] = asyncio.QueueEmpty
⋮----
# When using python 3.13 or higher, the closed queue signal is QueueShutdown
⋮----
QueueClosed = asyncio.QueueShutDown
⋮----
logger = logging.getLogger(__name__)
⋮----
@trace_class(kind=SpanKind.SERVER)
class EventConsumer
⋮----
"""Consumer to read events from the agent event queue."""
⋮----
def __init__(self, queue: EventQueue)
⋮----
"""Initializes the EventConsumer.

        Args:
            queue: The `EventQueue` instance to consume events from.
        """
⋮----
async def consume_one(self) -> Event
⋮----
"""Consume one event from the agent event queue non-blocking.

        Returns:
            The next event from the queue.

        Raises:
            ServerError: If the queue is empty when attempting to dequeue
                immediately.
        """
⋮----
event = await self.queue.dequeue_event(no_wait=True)
⋮----
async def consume_all(self) -> AsyncGenerator[Event]
⋮----
"""Consume all the generated streaming events from the agent.

        This method yields events as they become available from the queue
        until a final event is received or the queue is closed. It also
        monitors for exceptions set by the `agent_task_callback`.

        Yields:
            Events dequeued from the queue.

        Raises:
            BaseException: If an exception was set by the `agent_task_callback`.
        """
⋮----
# We use a timeout when waiting for an event from the queue.
# This is required because it allows the loop to check if
# `self._exception` has been set by the `agent_task_callback`.
# Without the timeout, loop might hang indefinitely if no events are
# enqueued by the agent and the agent simply threw an exception
event = await asyncio.wait_for(
⋮----
is_final_event = (
⋮----
# Make sure the yield is after the close events, otherwise
# the caller may end up in a blocked state where this
# generator isn't called again to close things out and the
# other part is waiting for an event or a closed queue.
⋮----
# continue polling until there is a final event
⋮----
except asyncio.TimeoutError:  # pyright: ignore [reportUnusedExcept]
# This class was made an alias of build-in TimeoutError after 3.11
⋮----
# Confirm that the queue is closed, e.g. we aren't on
# python 3.12 and get a queue empty error on an open queue
⋮----
def agent_task_callback(self, agent_task: asyncio.Task[None]) -> None
⋮----
"""Callback to handle exceptions from the agent's execution task.

        If the agent's asyncio task raises an exception, this callback is
        invoked, and the exception is stored to be re-raised by the consumer loop.

        Args:
            agent_task: The asyncio.Task that completed.
        """

================
File: src/a2a/server/events/event_queue.py
================
logger = logging.getLogger(__name__)
⋮----
Event = Message | Task | TaskStatusUpdateEvent | TaskArtifactUpdateEvent
"""Type alias for events that can be enqueued."""
⋮----
DEFAULT_MAX_QUEUE_SIZE = 1024
⋮----
@trace_class(kind=SpanKind.SERVER)
class EventQueue
⋮----
"""Event queue for A2A responses from agent.

    Acts as a buffer between the agent's asynchronous execution and the
    server's response handling (e.g., streaming via SSE). Supports tapping
    to create child queues that receive the same events.
    """
⋮----
def __init__(self, max_queue_size: int = DEFAULT_MAX_QUEUE_SIZE) -> None
⋮----
"""Initializes the EventQueue."""
# Make sure the `asyncio.Queue` is bounded.
# If it's unbounded (maxsize=0), then `queue.put()` never needs to wait,
# and so the streaming won't work correctly.
⋮----
async def enqueue_event(self, event: Event) -> None
⋮----
"""Enqueues an event to this queue and all its children.

        Args:
            event: The event object to enqueue.
        """
⋮----
# Make sure to use put instead of put_nowait to avoid blocking the event loop.
⋮----
async def dequeue_event(self, no_wait: bool = False) -> Event
⋮----
"""Dequeues an event from the queue.

        This implementation expects that dequeue to raise an exception when
        the queue has been closed. In python 3.13+ this is naturally provided
        by the QueueShutDown exception generated when the queue has closed and
        the user is awaiting the queue.get method. Python<=3.12 this needs to
        manage this lifecycle itself. The current implementation can lead to
        blocking if the dequeue_event is called before the EventQueue has been
        closed but when there are no events on the queue. Two ways to avoid this
        are to call this with no_wait = True which won't block, but is the
        callers responsibility to retry as appropriate. Alternatively, one can
        use a async Task management solution to cancel the get task if the queue
        has closed or some other condition is met. The implementation of the
        EventConsumer uses an async.wait with a timeout to abort the
        dequeue_event call and retry, when it will return with a closed error.

        Args:
            no_wait: If True, retrieve an event immediately or raise `asyncio.QueueEmpty`.
                     If False (default), wait until an event is available.

        Returns:
            The next event from the queue.

        Raises:
            asyncio.QueueEmpty: If `no_wait` is True and the queue is empty.
            asyncio.QueueShutDown: If the queue has been closed and is empty.
        """
⋮----
event = self.queue.get_nowait()
⋮----
event = await self.queue.get()
⋮----
def task_done(self) -> None
⋮----
"""Signals that a formerly enqueued task is complete.

        Used in conjunction with `dequeue_event` to track processed items.
        """
⋮----
def tap(self) -> 'EventQueue'
⋮----
"""Taps the event queue to create a new child queue that receives all future events.

        Returns:
            A new `EventQueue` instance that will receive all events enqueued
            to this parent queue from this point forward.
        """
⋮----
queue = EventQueue()
⋮----
async def close(self) -> None
⋮----
"""Closes the queue for future push events.

        Once closed, `dequeue_event` will eventually raise `asyncio.QueueShutDown`
        when the queue is empty. Also closes all child queues.
        """
⋮----
# If already closed, just return.
⋮----
# If using python 3.13 or higher, use the shutdown method
⋮----
# Otherwise, join the queue
⋮----
tasks = [asyncio.create_task(self.queue.join())]
⋮----
def is_closed(self) -> bool
⋮----
"""Checks if the queue is closed."""

================
File: src/a2a/server/events/in_memory_queue_manager.py
================
@trace_class(kind=SpanKind.SERVER)
class InMemoryQueueManager(QueueManager)
⋮----
"""InMemoryQueueManager is used for a single binary management.

    This implements the `QueueManager` interface using in-memory storage for event
    queues. It requires all incoming interactions for a given task ID to hit the
    same binary instance.

    This implementation is suitable for single-instance deployments but needs
    a distributed approach for scalable deployments.
    """
⋮----
def __init__(self) -> None
⋮----
"""Initializes the InMemoryQueueManager."""
⋮----
async def add(self, task_id: str, queue: EventQueue) -> None
⋮----
"""Adds a new event queue for a task ID.

        Raises:
            TaskQueueExists: If a queue for the given `task_id` already exists.
        """
⋮----
async def get(self, task_id: str) -> EventQueue | None
⋮----
"""Retrieves the event queue for a task ID.

        Returns:
            The `EventQueue` instance for the `task_id`, or `None` if not found.
        """
⋮----
async def tap(self, task_id: str) -> EventQueue | None
⋮----
"""Taps the event queue for a task ID to create a child queue.

        Returns:
            A new child `EventQueue` instance, or `None` if the task ID is not found.
        """
⋮----
async def close(self, task_id: str) -> None
⋮----
"""Closes and removes the event queue for a task ID.

        Raises:
            NoTaskQueue: If no queue exists for the given `task_id`.
        """
⋮----
queue = self._task_queue.pop(task_id)
⋮----
async def create_or_tap(self, task_id: str) -> EventQueue
⋮----
"""Creates a new event queue for a task ID if one doesn't exist, otherwise taps the existing one.

        Returns:
            A new or child `EventQueue` instance for the `task_id`.
        """
⋮----
queue = EventQueue()

================
File: src/a2a/server/events/queue_manager.py
================
class QueueManager(ABC)
⋮----
"""Interface for managing the event queue lifecycles per task."""
⋮----
@abstractmethod
    async def add(self, task_id: str, queue: EventQueue) -> None
⋮----
"""Adds a new event queue associated with a task ID."""
⋮----
@abstractmethod
    async def get(self, task_id: str) -> EventQueue | None
⋮----
"""Retrieves the event queue for a task ID."""
⋮----
@abstractmethod
    async def tap(self, task_id: str) -> EventQueue | None
⋮----
"""Creates a child event queue (tap) for an existing task ID."""
⋮----
@abstractmethod
    async def close(self, task_id: str) -> None
⋮----
"""Closes and removes the event queue for a task ID."""
⋮----
@abstractmethod
    async def create_or_tap(self, task_id: str) -> EventQueue
⋮----
"""Creates a queue if one doesn't exist, otherwise taps the existing one."""
⋮----
class TaskQueueExists(Exception):  # noqa: N818
⋮----
"""Exception raised when attempting to add a queue for a task ID that already exists."""
⋮----
class NoTaskQueue(Exception):  # noqa: N818
⋮----
"""Exception raised when attempting to access or close a queue for a task ID that does not exist."""

================
File: src/a2a/server/request_handlers/__init__.py
================
"""Request handler components for the A2A server."""
⋮----
logger = logging.getLogger(__name__)
⋮----
GrpcHandler,  # type: ignore
⋮----
_original_error = e
⋮----
class GrpcHandler:  # type: ignore
⋮----
"""Placeholder for GrpcHandler when dependencies are not installed."""
⋮----
def __init__(self, *args, **kwargs)
⋮----
__all__ = [

================
File: src/a2a/server/request_handlers/default_request_handler.py
================
logger = logging.getLogger(__name__)
⋮----
TERMINAL_TASK_STATES = {
⋮----
@trace_class(kind=SpanKind.SERVER)
class DefaultRequestHandler(RequestHandler)
⋮----
"""Default request handler for all incoming requests.

    This handler provides default implementations for all A2A JSON-RPC methods,
    coordinating between the `AgentExecutor`, `TaskStore`, `QueueManager`,
    and optional `PushNotifier`.
    """
⋮----
_running_agents: dict[str, asyncio.Task]
⋮----
def __init__(  # noqa: PLR0913
⋮----
"""Initializes the DefaultRequestHandler.

        Args:
            agent_executor: The `AgentExecutor` instance to run agent logic.
            task_store: The `TaskStore` instance to manage task persistence.
            queue_manager: The `QueueManager` instance to manage event queues. Defaults to `InMemoryQueueManager`.
            push_config_store: The `PushNotificationConfigStore` instance for managing push notification configurations. Defaults to None.
            push_sender: The `PushNotificationSender` instance for sending push notifications. Defaults to None.
            request_context_builder: The `RequestContextBuilder` instance used
              to build request contexts. Defaults to `SimpleRequestContextBuilder`.
        """
⋮----
# TODO: Likely want an interface for managing this, like AgentExecutionManager.
⋮----
"""Default handler for 'tasks/get'."""
task: Task | None = await self.task_store.get(params.id)
⋮----
"""Default handler for 'tasks/cancel'.

        Attempts to cancel the task managed by the `AgentExecutor`.
        """
⋮----
task_manager = TaskManager(
result_aggregator = ResultAggregator(task_manager)
⋮----
queue = await self._queue_manager.tap(task.id)
⋮----
queue = EventQueue()
⋮----
# Cancel the ongoing task, if one exists.
⋮----
consumer = EventConsumer(queue)
result = await result_aggregator.consume_all(consumer)
⋮----
"""Runs the agent's `execute` method and closes the queue afterwards.

        Args:
            request: The request context for the agent.
            queue: The event queue for the agent to publish to.
        """
⋮----
"""Common setup logic for both streaming and non-streaming message handling.

        Returns:
            A tuple of (task_manager, task_id, queue, result_aggregator, producer_task)
        """
# Create task manager and validate existing task
⋮----
task: Task | None = await task_manager.get_task()
⋮----
task = task_manager.update_with_message(params.message, task)
⋮----
# Build request context
request_context = await self._request_context_builder.build(
⋮----
task_id = cast('str', request_context.task_id)
# Always assign a task ID. We may not actually upgrade to a task, but
# dictating the task ID at this layer is useful for tracking running
# agents.
⋮----
queue = await self._queue_manager.create_or_tap(task_id)
⋮----
# TODO: to manage the non-blocking flows.
producer_task = asyncio.create_task(
⋮----
def _validate_task_id_match(self, task_id: str, event_task_id: str) -> None
⋮----
"""Validates that agent-generated task ID matches the expected task ID."""
⋮----
"""Sends push notification if configured and task is available."""
⋮----
latest_task = await result_aggregator.current_result
⋮----
"""Default handler for 'message/send' interface (non-streaming).

        Starts the agent execution for the message and waits for the final
        result (Task or Message).
        """
⋮----
blocking = True  # Default to blocking behavior
⋮----
blocking = False
⋮----
interrupted_or_non_blocking = False
⋮----
# TODO: Track this disconnected cleanup task.
asyncio.create_task(  # noqa: RUF006
⋮----
"""Default handler for 'message/stream' (streaming).

        Starts the agent execution and yields events as they are produced
        by the agent.
        """
⋮----
"""Registers the agent execution task with the handler."""
⋮----
"""Cleans up the agent execution task and queue manager entry."""
⋮----
"""Default handler for 'tasks/pushNotificationConfig/set'.

        Requires a `PushNotifier` to be configured.
        """
⋮----
task: Task | None = await self.task_store.get(params.task_id)
⋮----
"""Default handler for 'tasks/pushNotificationConfig/get'.

        Requires a `PushConfigStore` to be configured.
        """
⋮----
push_notification_config = await self._push_config_store.get_info(
⋮----
"""Default handler for 'tasks/resubscribe'.

        Allows a client to re-attach to a running streaming task's event stream.
        Requires the task and its queue to still be active.
        """
⋮----
"""Default handler for 'tasks/pushNotificationConfig/list'.

        Requires a `PushConfigStore` to be configured.
        """
⋮----
push_notification_config_list = await self._push_config_store.get_info(
⋮----
task_push_notification_config = []
⋮----
"""Default handler for 'tasks/pushNotificationConfig/delete'.

        Requires a `PushConfigStore` to be configured.
        """

================
File: src/a2a/server/request_handlers/grpc_handler.py
================
# ruff: noqa: N802
⋮----
logger = logging.getLogger(__name__)
⋮----
# For now we use a trivial wrapper on the grpc context object
⋮----
class CallContextBuilder(ABC)
⋮----
"""A class for building ServerCallContexts using the Starlette Request."""
⋮----
@abstractmethod
    def build(self, context: grpc.aio.ServicerContext) -> ServerCallContext
⋮----
"""Builds a ServerCallContext from a gRPC Request."""
⋮----
md = context.invocation_metadata
raw_values: list[str | bytes] = []
⋮----
raw_values = md.get_all(key)
⋮----
lower_key = key.lower()
raw_values = [e for (k, e) in md if k.lower() == lower_key]
⋮----
class DefaultCallContextBuilder(CallContextBuilder)
⋮----
"""A default implementation of CallContextBuilder."""
⋮----
def build(self, context: grpc.aio.ServicerContext) -> ServerCallContext
⋮----
"""Builds the ServerCallContext."""
user = UnauthenticatedUser()
state = {}
⋮----
class GrpcHandler(a2a_grpc.A2AServiceServicer)
⋮----
"""Maps incoming gRPC requests to the appropriate request handler method."""
⋮----
"""Initializes the GrpcHandler.

        Args:
            agent_card: The AgentCard describing the agent's capabilities.
            request_handler: The underlying `RequestHandler` instance to
                             delegate requests to.
            context_builder: The CallContextBuilder object. If none the
                             DefaultCallContextBuilder is used.
            card_modifier: An optional callback to dynamically modify the public
              agent card before it is served.
        """
⋮----
"""Handles the 'SendMessage' gRPC method.

        Args:
            request: The incoming `SendMessageRequest` object.
            context: Context provided by the server.

        Returns:
            A `SendMessageResponse` object containing the result (Task or
            Message) or throws an error response if a `ServerError` is raised
            by the handler.
        """
⋮----
# Construct the server context object
server_context = self.context_builder.build(context)
# Transform the proto object to the python internal objects
a2a_request = proto_utils.FromProto.message_send_params(
task_or_message = await self.request_handler.on_message_send(
⋮----
"""Handles the 'StreamMessage' gRPC method.

        Yields response objects as they are produced by the underlying handler's
        stream.

        Args:
            request: The incoming `SendMessageRequest` object.
            context: Context provided by the server.

        Yields:
            `StreamResponse` objects containing streaming events
            (Task, Message, TaskStatusUpdateEvent, TaskArtifactUpdateEvent)
            or gRPC error responses if a `ServerError` is raised.
        """
⋮----
# Transform the proto object to the python internal objects
⋮----
"""Handles the 'CancelTask' gRPC method.

        Args:
            request: The incoming `CancelTaskRequest` object.
            context: Context provided by the server.

        Returns:
            A `Task` object containing the updated Task or a gRPC error.
        """
⋮----
task_id_params = proto_utils.FromProto.task_id_params(request)
task = await self.request_handler.on_cancel_task(
⋮----
"""Handles the 'TaskSubscription' gRPC method.

        Yields response objects as they are produced by the underlying handler's
        stream.

        Args:
            request: The incoming `TaskSubscriptionRequest` object.
            context: Context provided by the server.

        Yields:
            `StreamResponse` objects containing streaming events
        """
⋮----
"""Handles the 'GetTaskPushNotificationConfig' gRPC method.

        Args:
            request: The incoming `GetTaskPushNotificationConfigRequest` object.
            context: Context provided by the server.

        Returns:
            A `TaskPushNotificationConfig` object containing the config.
        """
⋮----
config = (
⋮----
"""Handles the 'CreateTaskPushNotificationConfig' gRPC method.

        Requires the agent to support push notifications.

        Args:
            request: The incoming `CreateTaskPushNotificationConfigRequest` object.
            context: Context provided by the server.

        Returns:
            A `TaskPushNotificationConfig` object

        Raises:
            ServerError: If push notifications are not supported by the agent
                (due to the `@validate` decorator).
        """
⋮----
"""Handles the 'GetTask' gRPC method.

        Args:
            request: The incoming `GetTaskRequest` object.
            context: Context provided by the server.

        Returns:
            A `Task` object.
        """
⋮----
task = await self.request_handler.on_get_task(
⋮----
"""Get the agent card for the agent served."""
card_to_serve = self.agent_card
⋮----
card_to_serve = self.card_modifier(card_to_serve)
⋮----
"""Sets the grpc errors appropriately in the context."""

================
File: src/a2a/server/request_handlers/jsonrpc_handler.py
================
logger = logging.getLogger(__name__)
⋮----
@trace_class(kind=SpanKind.SERVER)
class JSONRPCHandler
⋮----
"""Maps incoming JSON-RPC requests to the appropriate request handler method and formats responses."""
⋮----
"""Initializes the JSONRPCHandler.

        Args:
            agent_card: The AgentCard describing the agent's capabilities.
            request_handler: The underlying `RequestHandler` instance to delegate requests to.
            extended_agent_card: An optional, distinct Extended AgentCard to be served
            extended_card_modifier: An optional callback to dynamically modify
              the extended agent card before it is served. It receives the
              call context.
        """
⋮----
"""Handles the 'message/send' JSON-RPC method.

        Args:
            request: The incoming `SendMessageRequest` object.
            context: Context provided by the server.

        Returns:
            A `SendMessageResponse` object containing the result (Task or Message)
            or a JSON-RPC error response if a `ServerError` is raised by the handler.
        """
# TODO: Wrap in error handler to return error states
⋮----
task_or_message = await self.request_handler.on_message_send(
⋮----
"""Handles the 'message/stream' JSON-RPC method.

        Yields response objects as they are produced by the underlying handler's stream.

        Args:
            request: The incoming `SendStreamingMessageRequest` object.
            context: Context provided by the server.

        Yields:
            `SendStreamingMessageResponse` objects containing streaming events
            (Task, Message, TaskStatusUpdateEvent, TaskArtifactUpdateEvent)
            or JSON-RPC error responses if a `ServerError` is raised.
        """
⋮----
"""Handles the 'tasks/cancel' JSON-RPC method.

        Args:
            request: The incoming `CancelTaskRequest` object.
            context: Context provided by the server.

        Returns:
            A `CancelTaskResponse` object containing the updated Task or a JSON-RPC error.
        """
⋮----
task = await self.request_handler.on_cancel_task(
⋮----
"""Handles the 'tasks/resubscribe' JSON-RPC method.

        Yields response objects as they are produced by the underlying handler's stream.

        Args:
            request: The incoming `TaskResubscriptionRequest` object.
            context: Context provided by the server.

        Yields:
            `SendStreamingMessageResponse` objects containing streaming events
            or JSON-RPC error responses if a `ServerError` is raised.
        """
⋮----
"""Handles the 'tasks/pushNotificationConfig/get' JSON-RPC method.

        Args:
            request: The incoming `GetTaskPushNotificationConfigRequest` object.
            context: Context provided by the server.

        Returns:
            A `GetTaskPushNotificationConfigResponse` object containing the config or a JSON-RPC error.
        """
⋮----
config = (
⋮----
"""Handles the 'tasks/pushNotificationConfig/set' JSON-RPC method.

        Requires the agent to support push notifications.

        Args:
            request: The incoming `SetTaskPushNotificationConfigRequest` object.
            context: Context provided by the server.

        Returns:
            A `SetTaskPushNotificationConfigResponse` object containing the config or a JSON-RPC error.

        Raises:
            ServerError: If push notifications are not supported by the agent
                (due to the `@validate` decorator).
        """
⋮----
"""Handles the 'tasks/get' JSON-RPC method.

        Args:
            request: The incoming `GetTaskRequest` object.
            context: Context provided by the server.

        Returns:
            A `GetTaskResponse` object containing the Task or a JSON-RPC error.
        """
⋮----
task = await self.request_handler.on_get_task(
⋮----
"""Handles the 'tasks/pushNotificationConfig/list' JSON-RPC method.

        Args:
            request: The incoming `ListTaskPushNotificationConfigRequest` object.
            context: Context provided by the server.

        Returns:
            A `ListTaskPushNotificationConfigResponse` object containing the config or a JSON-RPC error.
        """
⋮----
config = await self.request_handler.on_list_task_push_notification_config(
⋮----
"""Handles the 'tasks/pushNotificationConfig/list' JSON-RPC method.

        Args:
            request: The incoming `DeleteTaskPushNotificationConfigRequest` object.
            context: Context provided by the server.

        Returns:
            A `DeleteTaskPushNotificationConfigResponse` object containing the config or a JSON-RPC error.
        """
⋮----
"""Handles the 'agent/authenticatedExtendedCard' JSON-RPC method.

        Args:
            request: The incoming `GetAuthenticatedExtendedCardRequest` object.
            context: Context provided by the server.

        Returns:
            A `GetAuthenticatedExtendedCardResponse` object containing the config or a JSON-RPC error.
        """
⋮----
base_card = self.extended_agent_card
⋮----
base_card = self.agent_card
⋮----
card_to_serve = base_card
⋮----
card_to_serve = self.extended_card_modifier(base_card, context)

================
File: src/a2a/server/request_handlers/request_handler.py
================
class RequestHandler(ABC)
⋮----
"""A2A request handler interface.

    This interface defines the methods that an A2A server implementation must
    provide to handle incoming JSON-RPC requests.
    """
⋮----
"""Handles the 'tasks/get' method.

        Retrieves the state and history of a specific task.

        Args:
            params: Parameters specifying the task ID and optionally history length.
            context: Context provided by the server.

        Returns:
            The `Task` object if found, otherwise `None`.
        """
⋮----
"""Handles the 'tasks/cancel' method.

        Requests the agent to cancel an ongoing task.

        Args:
            params: Parameters specifying the task ID.
            context: Context provided by the server.

        Returns:
            The `Task` object with its status updated to canceled, or `None` if the task was not found.
        """
⋮----
"""Handles the 'message/send' method (non-streaming).

        Sends a message to the agent to create, continue, or restart a task,
        and waits for the final result (Task or Message).

        Args:
            params: Parameters including the message and configuration.
            context: Context provided by the server.

        Returns:
            The final `Task` object or a final `Message` object.
        """
⋮----
"""Handles the 'message/stream' method (streaming).

        Sends a message to the agent and yields stream events as they are
        produced (Task updates, Message chunks, Artifact updates).

        Args:
            params: Parameters including the message and configuration.
            context: Context provided by the server.

        Yields:
            `Event` objects from the agent's execution.

        Raises:
             ServerError(UnsupportedOperationError): By default, if not implemented.
        """
⋮----
"""Handles the 'tasks/pushNotificationConfig/set' method.

        Sets or updates the push notification configuration for a task.

        Args:
            params: Parameters including the task ID and push notification configuration.
            context: Context provided by the server.

        Returns:
            The provided `TaskPushNotificationConfig` upon success.
        """
⋮----
"""Handles the 'tasks/pushNotificationConfig/get' method.

        Retrieves the current push notification configuration for a task.

        Args:
            params: Parameters including the task ID.
            context: Context provided by the server.

        Returns:
            The `TaskPushNotificationConfig` for the task.
        """
⋮----
"""Handles the 'tasks/resubscribe' method.

        Allows a client to re-subscribe to a running streaming task's event stream.

        Args:
            params: Parameters including the task ID.
            context: Context provided by the server.

        Yields:
             `Event` objects from the agent's ongoing execution for the specified task.

        Raises:
             ServerError(UnsupportedOperationError): By default, if not implemented.
        """
⋮----
"""Handles the 'tasks/pushNotificationConfig/list' method.

        Retrieves the current push notification configurations for a task.

        Args:
            params: Parameters including the task ID.
            context: Context provided by the server.

        Returns:
            The `list[TaskPushNotificationConfig]` for the task.
        """
⋮----
"""Handles the 'tasks/pushNotificationConfig/delete' method.

        Deletes a push notification configuration associated with a task.

        Args:
            params: Parameters including the task ID.
            context: Context provided by the server.

        Returns:
            None
        """

================
File: src/a2a/server/request_handlers/response_helpers.py
================
"""Helper functions for building A2A JSON-RPC responses."""
⋮----
# response types
⋮----
RT = TypeVar(
"""Type variable for RootModel response types."""
⋮----
# success types
SPT = TypeVar(
"""Type variable for SuccessResponse types."""
⋮----
# result types
EventTypes = (
"""Type alias for possible event types produced by handlers."""
⋮----
"""Helper method to build a JSONRPCErrorResponse wrapped in the appropriate response type.

    Args:
        request_id: The ID of the request that caused the error.
        error: The A2AError or JSONRPCError object.
        response_wrapper_type: The Pydantic RootModel type that wraps the response
                                for the specific RPC method (e.g., `SendMessageResponse`).

    Returns:
        A Pydantic model representing the JSON-RPC error response,
        wrapped in the specified response type.
    """
⋮----
"""Helper method to build appropriate JSONRPCResponse object for RPC methods.

    Based on the type of the `response` object received from the handler,
    it constructs either a success response wrapped in the appropriate payload type
    or an error response.

    Args:
        request_id: The ID of the request.
        response: The object received from the request handler.
        success_response_types: A tuple of expected Pydantic model types for a successful result.
        success_payload_type: The Pydantic model type for the success payload
                                (e.g., `SendMessageSuccessResponse`).
        response_type: The Pydantic RootModel type that wraps the final response
                       (e.g., `SendMessageResponse`).

    Returns:
        A Pydantic model representing the final JSON-RPC response (success or error).
    """
⋮----
root=success_payload_type(id=request_id, result=response)  # type:ignore
⋮----
# If consumer_data is not an expected success type and not an error,
# it's an invalid type of response from the agent for this specific method.
response = A2AError(

================
File: src/a2a/server/request_handlers/rest_handler.py
================
logger = logging.getLogger(__name__)
⋮----
@trace_class(kind=SpanKind.SERVER)
class RESTHandler
⋮----
"""Maps incoming REST-like (JSON+HTTP) requests to the appropriate request handler method and formats responses.

    This uses the protobuf definitions of the gRPC service as the source of truth. By
    doing this, it ensures that this implementation and the gRPC transcoding
    (via Envoy) are equivalent. This handler should be used if using the gRPC handler
    with Envoy is not feasible for a given deployment solution. Use this handler
    and a related application if you desire to ONLY server the RESTful API.
    """
⋮----
"""Initializes the RESTHandler.

        Args:
          agent_card: The AgentCard describing the agent's capabilities.
          request_handler: The underlying `RequestHandler` instance to delegate requests to.
        """
⋮----
"""Handles the 'message/send' REST method.

        Args:
            request: The incoming `Request` object.
            context: Context provided by the server.

        Returns:
            A `dict` containing the result (Task or Message)
        """
body = await request.body()
params = a2a_pb2.SendMessageRequest()
⋮----
# Transform the proto object to the python internal objects
a2a_request = proto_utils.FromProto.message_send_params(
task_or_message = await self.request_handler.on_message_send(
⋮----
"""Handles the 'message/stream' REST method.

        Yields response objects as they are produced by the underlying handler's stream.

        Args:
            request: The incoming `Request` object.
            context: Context provided by the server.

        Yields:
            JSON serialized objects containing streaming events
            (Task, Message, TaskStatusUpdateEvent, TaskArtifactUpdateEvent) as JSON
        """
⋮----
response = proto_utils.ToProto.stream_response(event)
⋮----
"""Handles the 'tasks/cancel' REST method.

        Args:
            request: The incoming `Request` object.
            context: Context provided by the server.

        Returns:
            A `dict` containing the updated Task
        """
task_id = request.path_params['id']
task = await self.request_handler.on_cancel_task(
⋮----
"""Handles the 'tasks/resubscribe' REST method.

        Yields response objects as they are produced by the underlying handler's stream.

        Args:
            request: The incoming `Request` object.
            context: Context provided by the server.

        Yields:
            JSON serialized objects containing streaming events
        """
⋮----
"""Handles the 'tasks/pushNotificationConfig/get' REST method.

        Args:
            request: The incoming `Request` object.
            context: Context provided by the server.

        Returns:
            A `dict` containing the config
        """
⋮----
push_id = request.path_params['push_id']
params = GetTaskPushNotificationConfigParams(
config = (
⋮----
"""Handles the 'tasks/pushNotificationConfig/set' REST method.

        Requires the agent to support push notifications.

        Args:
            request: The incoming `TaskPushNotificationConfig` object.
            context: Context provided by the server.

        Returns:
            A `dict` containing the config object.

        Raises:
            ServerError: If push notifications are not supported by the agent
                (due to the `@validate` decorator), A2AError if processing error is
                found.
        """
⋮----
params = a2a_pb2.CreateTaskPushNotificationConfigRequest()
⋮----
a2a_request = (
⋮----
"""Handles the 'v1/tasks/{id}' REST method.

        Args:
            request: The incoming `Request` object.
            context: Context provided by the server.

        Returns:
            A `Task` object containing the Task.
        """
⋮----
history_length_str = request.query_params.get('historyLength')
history_length = int(history_length_str) if history_length_str else None
params = TaskQueryParams(id=task_id, history_length=history_length)
task = await self.request_handler.on_get_task(params, context)
⋮----
"""Handles the 'tasks/pushNotificationConfig/list' REST method.

        This method is currently not implemented.

        Args:
            request: The incoming `Request` object.
            context: Context provided by the server.

        Returns:
            A list of `dict` representing the `TaskPushNotificationConfig` objects.

        Raises:
            NotImplementedError: This method is not yet implemented.
        """
⋮----
"""Handles the 'tasks/list' REST method.

        This method is currently not implemented.

        Args:
            request: The incoming `Request` object.
            context: Context provided by the server.

        Returns:
            A list of dict representing the`Task` objects.

        Raises:
            NotImplementedError: This method is not yet implemented.
        """

================
File: src/a2a/server/tasks/__init__.py
================
"""Components for managing tasks within the A2A server."""
⋮----
logger = logging.getLogger(__name__)
⋮----
DatabaseTaskStore,  # type: ignore
⋮----
_original_error = e
# If the database task store is not available, we can still use in-memory stores.
⋮----
class DatabaseTaskStore:  # type: ignore
⋮----
"""Placeholder for DatabaseTaskStore when dependencies are not installed."""
⋮----
def __init__(self, *args, **kwargs)
⋮----
DatabasePushNotificationConfigStore,  # type: ignore
⋮----
# If the database push notification config store is not available, we can still use in-memory stores.
⋮----
class DatabasePushNotificationConfigStore:  # type: ignore
⋮----
"""Placeholder for DatabasePushNotificationConfigStore when dependencies are not installed."""
⋮----
__all__ = [

================
File: src/a2a/server/tasks/base_push_notification_sender.py
================
logger = logging.getLogger(__name__)
⋮----
class BasePushNotificationSender(PushNotificationSender)
⋮----
"""Base implementation of PushNotificationSender interface."""
⋮----
"""Initializes the BasePushNotificationSender.

        Args:
            httpx_client: An async HTTP client instance to send notifications.
            config_store: A PushNotificationConfigStore instance to retrieve configurations.
        """
⋮----
async def send_notification(self, task: Task) -> None
⋮----
"""Sends a push notification for a task if configuration exists."""
push_configs = await self._config_store.get_info(task.id)
⋮----
awaitables = [
results = await asyncio.gather(*awaitables)
⋮----
url = push_info.url
⋮----
headers = None
⋮----
headers = {'X-A2A-Notification-Token': push_info.token}
response = await self._client.post(

================
File: src/a2a/server/tasks/database_push_notification_config_store.py
================
# ruff: noqa: PLC0415
⋮----
logger = logging.getLogger(__name__)
⋮----
class DatabasePushNotificationConfigStore(PushNotificationConfigStore)
⋮----
"""SQLAlchemy-based implementation of PushNotificationConfigStore.

    Stores push notification configurations in a database supported by SQLAlchemy.
    """
⋮----
engine: AsyncEngine
async_session_maker: async_sessionmaker[AsyncSession]
create_table: bool
_initialized: bool
config_model: type[PushNotificationConfigModel]
_fernet: 'Fernet | None'
⋮----
"""Initializes the DatabasePushNotificationConfigStore.

        Args:
            engine: An existing SQLAlchemy AsyncEngine to be used by the store.
            create_table: If true, create the table on initialization.
            table_name: Name of the database table. Defaults to 'push_notification_configs'.
            encryption_key: A key for encrypting sensitive configuration data.
                If provided, `config_data` will be encrypted in the database.
                The key must be a URL-safe base64-encoded 32-byte key.
        """
⋮----
encryption_key = encryption_key.encode('utf-8')
⋮----
async def initialize(self) -> None
⋮----
"""Initialize the database and create the table if needed."""
⋮----
mapper = class_mapper(self.config_model)
tables_to_create = [
⋮----
async def _ensure_initialized(self) -> None
⋮----
"""Ensure the database connection is initialized."""
⋮----
"""Maps a Pydantic PushNotificationConfig to a SQLAlchemy model instance.

        The config data is serialized to JSON bytes, and encrypted if a key is configured.
        """
json_payload = config.model_dump_json().encode('utf-8')
⋮----
data_to_store = self._fernet.encrypt(json_payload)
⋮----
data_to_store = json_payload
⋮----
"""Maps a SQLAlchemy model instance to a Pydantic PushNotificationConfig.

        Handles decryption if a key is configured, with a fallback to plain JSON.
        """
payload = model_instance.config_data
⋮----
decrypted_payload = self._fernet.decrypt(payload)
⋮----
# Decryption failed. This could be because the data is not encrypted.
# We'll log a warning and try to parse it as plain JSON as a fallback.
⋮----
# Fall through to the unencrypted parsing logic below.
⋮----
# Try to parse as plain JSON.
⋮----
# if no key is configured and the payload is not valid JSON.
⋮----
"""Sets or updates the push notification configuration for a task."""
⋮----
config_to_save = notification_config.model_copy()
⋮----
db_config = self._to_orm(task_id, config_to_save)
⋮----
async def get_info(self, task_id: str) -> list[PushNotificationConfig]
⋮----
"""Retrieves all push notification configurations for a task."""
⋮----
stmt = select(self.config_model).where(
result = await session.execute(stmt)
models = result.scalars().all()
⋮----
configs = []
⋮----
"""Deletes push notification configurations for a task.

        If config_id is provided, only that specific configuration is deleted.
        If config_id is None, all configurations for the task are deleted.
        """
⋮----
stmt = delete(self.config_model).where(
⋮----
stmt = stmt.where(self.config_model.config_id == config_id)

================
File: src/a2a/server/tasks/database_task_store.py
================
from a2a.types import Task  # Task is the Pydantic model
⋮----
logger = logging.getLogger(__name__)
⋮----
class DatabaseTaskStore(TaskStore)
⋮----
"""SQLAlchemy-based implementation of TaskStore.

    Stores task objects in a database supported by SQLAlchemy.
    """
⋮----
engine: AsyncEngine
async_session_maker: async_sessionmaker[AsyncSession]
create_table: bool
_initialized: bool
task_model: type[TaskModel]
⋮----
"""Initializes the DatabaseTaskStore.

        Args:
            engine: An existing SQLAlchemy AsyncEngine to be used by Task Store
            create_table: If true, create tasks table on initialization.
            table_name: Name of the database table. Defaults to 'tasks'.
        """
⋮----
async def initialize(self) -> None
⋮----
"""Initialize the database and create the table if needed."""
⋮----
mapper = class_mapper(self.task_model)
tables_to_create = [
⋮----
async def _ensure_initialized(self) -> None
⋮----
"""Ensure the database connection is initialized."""
⋮----
def _to_orm(self, task: Task) -> TaskModel
⋮----
"""Maps a Pydantic Task to a SQLAlchemy TaskModel instance."""
⋮----
def _from_orm(self, task_model: TaskModel) -> Task
⋮----
"""Maps a SQLAlchemy TaskModel to a Pydantic Task instance."""
# Map database columns to Pydantic model fields
task_data_from_db = {
⋮----
'metadata': task_model.task_metadata,  # Map task_metadata column to metadata field
⋮----
# Pydantic's model_validate will parse the nested dicts/lists from JSON
⋮----
async def save(self, task: Task) -> None
⋮----
"""Saves or updates a task in the database."""
⋮----
db_task = self._to_orm(task)
⋮----
async def get(self, task_id: str) -> Task | None
⋮----
"""Retrieves a task from the database by ID."""
⋮----
stmt = select(self.task_model).where(self.task_model.id == task_id)
result = await session.execute(stmt)
task_model = result.scalar_one_or_none()
⋮----
task = self._from_orm(task_model)
⋮----
async def delete(self, task_id: str) -> None
⋮----
"""Deletes a task from the database by ID."""
⋮----
stmt = delete(self.task_model).where(self.task_model.id == task_id)
⋮----
# Commit is automatic when using session.begin()

================
File: src/a2a/server/tasks/inmemory_push_notification_config_store.py
================
logger = logging.getLogger(__name__)
⋮----
class InMemoryPushNotificationConfigStore(PushNotificationConfigStore)
⋮----
"""In-memory implementation of PushNotificationConfigStore interface.

    Stores push notification configurations in memory
    """
⋮----
def __init__(self) -> None
⋮----
"""Initializes the InMemoryPushNotificationConfigStore."""
⋮----
"""Sets or updates the push notification configuration for a task in memory."""
⋮----
async def get_info(self, task_id: str) -> list[PushNotificationConfig]
⋮----
"""Retrieves the push notification configuration for a task from memory."""
⋮----
"""Deletes the push notification configuration for a task from memory."""
⋮----
config_id = task_id
⋮----
configurations = self._push_notification_infos[task_id]

================
File: src/a2a/server/tasks/inmemory_task_store.py
================
logger = logging.getLogger(__name__)
⋮----
class InMemoryTaskStore(TaskStore)
⋮----
"""In-memory implementation of TaskStore.

    Stores task objects in a dictionary in memory. Task data is lost when the
    server process stops.
    """
⋮----
def __init__(self) -> None
⋮----
"""Initializes the InMemoryTaskStore."""
⋮----
async def save(self, task: Task) -> None
⋮----
"""Saves or updates a task in the in-memory store."""
⋮----
async def get(self, task_id: str) -> Task | None
⋮----
"""Retrieves a task from the in-memory store by ID."""
⋮----
task = self.tasks.get(task_id)
⋮----
async def delete(self, task_id: str) -> None
⋮----
"""Deletes a task from the in-memory store by ID."""

================
File: src/a2a/server/tasks/push_notification_config_store.py
================
class PushNotificationConfigStore(ABC)
⋮----
"""Interface for storing and retrieving push notification configurations for tasks."""
⋮----
"""Sets or updates the push notification configuration for a task."""
⋮----
@abstractmethod
    async def get_info(self, task_id: str) -> list[PushNotificationConfig]
⋮----
"""Retrieves the push notification configuration for a task."""
⋮----
"""Deletes the push notification configuration for a task."""

================
File: src/a2a/server/tasks/push_notification_sender.py
================
class PushNotificationSender(ABC)
⋮----
"""Interface for sending push notifications for tasks."""
⋮----
@abstractmethod
    async def send_notification(self, task: Task) -> None
⋮----
"""Sends a push notification containing the latest task state."""

================
File: src/a2a/server/tasks/result_aggregator.py
================
logger = logging.getLogger(__name__)
⋮----
class ResultAggregator
⋮----
"""ResultAggregator is used to process the event streams from an AgentExecutor.

    There are three main ways to use the ResultAggregator:
    1) As part of a processing pipe. consume_and_emit will construct the updated
       task as the events arrive, and re-emit those events for another consumer
    2) As part of a blocking call. consume_all will process the entire stream and
       return the final Task or Message object
    3) As part of a push solution where the latest Task is emitted after processing an event.
       consume_and_emit_task will consume the Event stream, process the events to the current
       Task object and emit that Task object.
    """
⋮----
def __init__(self, task_manager: TaskManager)
⋮----
"""Initializes the ResultAggregator.

        Args:
            task_manager: The `TaskManager` instance to use for processing events
                          and managing the task state.
        """
⋮----
@property
    async def current_result(self) -> Task | Message | None
⋮----
"""Returns the current aggregated result (Task or Message).

        This is the latest state processed from the event stream.

        Returns:
            The current `Task` object managed by the `TaskManager`, or the final
            `Message` if one was received, or `None` if no result has been produced yet.
        """
⋮----
"""Processes the event stream from the consumer, updates the task state, and re-emits the same events.

        Useful for streaming scenarios where the server needs to observe and
        process events (e.g., save task state, send push notifications) while
        forwarding them to the client.

        Args:
            consumer: The `EventConsumer` to read events from.

        Yields:
            The `Event` objects consumed from the `EventConsumer`.
        """
⋮----
"""Processes the entire event stream from the consumer and returns the final result.

        Blocks until the event stream ends (queue is closed after final event or exception).

        Args:
            consumer: The `EventConsumer` to read events from.

        Returns:
            The final `Task` object or `Message` object after the stream is exhausted.
            Returns `None` if the stream ends without producing a final result.

        Raises:
            BaseException: If the `EventConsumer` raises an exception during consumption.
        """
⋮----
"""Processes the event stream until completion or an interruptable state is encountered.

        If `blocking` is False, it returns after the first event that creates a Task or Message.
        If `blocking` is True, it waits for completion unless an `auth_required`
        state is encountered, which is always an interruption.
        If interrupted, consumption continues in a background task.

        Args:
            consumer: The `EventConsumer` to read events from.
            blocking: If `False`, the method returns as soon as a task/message
                      is available. If `True`, it waits for a terminal state.

        Returns:
            A tuple containing:
            - The current aggregated result (`Task` or `Message`) at the point of completion or interruption.
            - A boolean indicating whether the consumption was interrupted (`True`) or completed naturally (`False`).

        Raises:
            BaseException: If the `EventConsumer` raises an exception during consumption.
        """
event_stream = consumer.consume_all()
interrupted = False
⋮----
should_interrupt = False
is_auth_required = (
⋮----
# Always interrupt on auth_required, as it needs external action.
⋮----
# auth-required is a special state: the message should be
# escalated back to the caller, but the agent is expected to
# continue producing events once the authorization is received
# out-of-band. This is in contrast to input-required, where a
# new request is expected in order for the agent to make progress,
# so the agent should exit.
⋮----
should_interrupt = True
# For non-blocking calls, interrupt as soon as a task is available.
⋮----
# Continue consuming the rest of the events in the background.
# TODO: We should track all outstanding tasks to ensure they eventually complete.
asyncio.create_task(self._continue_consuming(event_stream))  # noqa: RUF006
interrupted = True
⋮----
"""Continues processing an event stream in a background task.

        Used after an interruptable state (like auth_required) is encountered
        in the synchronous consumption flow.

        Args:
            event_stream: The remaining `AsyncIterator` of events from the consumer.
        """

================
File: src/a2a/server/tasks/task_manager.py
================
logger = logging.getLogger(__name__)
⋮----
class TaskManager
⋮----
"""Helps manage a task's lifecycle during execution of a request.

    Responsible for retrieving, saving, and updating the `Task` object based on
    events received from the agent.
    """
⋮----
"""Initializes the TaskManager.

        Args:
            task_id: The ID of the task, if known from the request.
            context_id: The ID of the context, if known from the request.
            task_store: The `TaskStore` instance for persistence.
            initial_message: The `Message` that initiated the task, if any.
                             Used when creating a new task object.
        """
⋮----
async def get_task(self) -> Task | None
⋮----
"""Retrieves the current task object, either from memory or the store.

        If `task_id` is set, it first checks the in-memory `_current_task`,
        then attempts to load it from the `task_store`.

        Returns:
            The `Task` object if found, otherwise `None`.
        """
⋮----
"""Processes a task-related event (Task, Status, Artifact) and saves the updated task state.

        Ensures task and context IDs match or are set from the event.

        Args:
            event: The task-related event (`Task`, `TaskStatusUpdateEvent`, or `TaskArtifactUpdateEvent`).

        Returns:
            The updated `Task` object after processing the event.

        Raises:
            ServerError: If the task ID in the event conflicts with the TaskManager's ID
                         when the TaskManager's ID is already set.
        """
task_id_from_event = (
# If task id is known, make sure it is matched
⋮----
task: Task = await self.ensure_task(event)
⋮----
"""Ensures a Task object exists in memory, loading from store or creating new if needed.

        Args:
            event: The task-related event triggering the need for a Task object.

        Returns:
            An existing or newly created `Task` object.
        """
task: Task | None = self._current_task
⋮----
task = await self.task_store.get(self.task_id)
⋮----
# streaming agent did not previously stream task object.
# Create a task object with the available information and persist the event
task = self._init_task_obj(event.task_id, event.context_id)
⋮----
async def process(self, event: Event) -> Event
⋮----
"""Processes an event, updates the task state if applicable, stores it, and returns the event.

        If the event is task-related (`Task`, `TaskStatusUpdateEvent`, `TaskArtifactUpdateEvent`),
        the internal task state is updated and persisted.

        Args:
            event: The event object received from the agent.

        Returns:
            The same event object that was processed.
        """
⋮----
def _init_task_obj(self, task_id: str, context_id: str) -> Task
⋮----
"""Initializes a new task object in memory.

        Args:
            task_id: The ID for the new task.
            context_id: The context ID for the new task.

        Returns:
            A new `Task` object with initial status and potentially the initial message in history.
        """
⋮----
history = [self._initial_message] if self._initial_message else []
⋮----
async def _save_task(self, task: Task) -> None
⋮----
"""Saves the given task to the task store and updates the in-memory `_current_task`.

        Args:
            task: The `Task` object to save.
        """
⋮----
def update_with_message(self, message: Message, task: Task) -> Task
⋮----
"""Updates a task object in memory by adding a new message to its history.

        If the task has a message in its current status, that message is moved
        to the history first.

        Args:
            message: The new `Message` to add to the history.
            task: The `Task` object to update.

        Returns:
            The updated `Task` object (updated in-place).
        """

================
File: src/a2a/server/tasks/task_store.py
================
class TaskStore(ABC)
⋮----
"""Agent Task Store interface.

    Defines the methods for persisting and retrieving `Task` objects.
    """
⋮----
@abstractmethod
    async def save(self, task: Task) -> None
⋮----
"""Saves or updates a task in the store."""
⋮----
@abstractmethod
    async def get(self, task_id: str) -> Task | None
⋮----
"""Retrieves a task from the store by ID."""
⋮----
@abstractmethod
    async def delete(self, task_id: str) -> None
⋮----
"""Deletes a task from the store by ID."""

================
File: src/a2a/server/tasks/task_updater.py
================
class TaskUpdater
⋮----
"""Helper class for agents to publish updates to a task's event queue.

    Simplifies the process of creating and enqueueing standard task events.
    """
⋮----
def __init__(self, event_queue: EventQueue, task_id: str, context_id: str)
⋮----
"""Initializes the TaskUpdater.

        Args:
            event_queue: The `EventQueue` associated with the task.
            task_id: The ID of the task.
            context_id: The context ID of the task.
        """
⋮----
"""Updates the status of the task and publishes a `TaskStatusUpdateEvent`.

        Args:
            state: The new state of the task.
            message: An optional message associated with the status update.
            final: If True, indicates this is the final status update for the task.
            timestamp: Optional ISO 8601 datetime string. Defaults to current time.
            metadata: Optional metadata for extensions.
        """
⋮----
final = True
⋮----
current_timestamp = (
⋮----
async def add_artifact(  # noqa: PLR0913
⋮----
"""Adds an artifact chunk to the task and publishes a `TaskArtifactUpdateEvent`.

        Args:
            parts: A list of `Part` objects forming the artifact chunk.
            artifact_id: The ID of the artifact. A new UUID is generated if not provided.
            name: Optional name for the artifact.
            metadata: Optional metadata for the artifact.
            append: Optional boolean indicating if this chunk appends to a previous one.
            last_chunk: Optional boolean indicating if this is the last chunk.
        """
⋮----
artifact_id = str(uuid.uuid4())
⋮----
async def complete(self, message: Message | None = None) -> None
⋮----
"""Marks the task as completed and publishes a final status update."""
⋮----
async def failed(self, message: Message | None = None) -> None
⋮----
"""Marks the task as failed and publishes a final status update."""
⋮----
async def reject(self, message: Message | None = None) -> None
⋮----
"""Marks the task as rejected and publishes a final status update."""
⋮----
async def submit(self, message: Message | None = None) -> None
⋮----
"""Marks the task as submitted and publishes a status update."""
⋮----
async def start_work(self, message: Message | None = None) -> None
⋮----
"""Marks the task as working and publishes a status update."""
⋮----
async def cancel(self, message: Message | None = None) -> None
⋮----
"""Marks the task as cancelled and publishes a finalstatus update."""
⋮----
"""Marks the task as input required and publishes a status update."""
⋮----
"""Marks the task as auth required and publishes a status update."""
⋮----
"""Creates a new message object sent by the agent for this task/context.

        Note: This method only *creates* the message object. It does not
              automatically enqueue it.

        Args:
            parts: A list of `Part` objects for the message content.
            metadata: Optional metadata for the message.

        Returns:
            A new `Message` object.
        """

================
File: src/a2a/server/__init__.py
================
"""Server-side components for implementing an A2A agent."""

================
File: src/a2a/server/context.py
================
"""Defines the ServerCallContext class."""
⋮----
State = collections.abc.MutableMapping[str, typing.Any]
⋮----
class ServerCallContext(BaseModel)
⋮----
"""A context passed when calling a server method.

    This class allows storing arbitrary user data in the state attribute.
    """
⋮----
model_config = ConfigDict(arbitrary_types_allowed=True)
⋮----
state: State = Field(default={})
user: User = Field(default=UnauthenticatedUser())
requested_extensions: set[str] = Field(default_factory=set)
activated_extensions: set[str] = Field(default_factory=set)

================
File: src/a2a/server/models.py
================
def override(func):  # noqa: ANN001, ANN201
⋮----
"""Override decorator."""
⋮----
T = TypeVar('T', bound=BaseModel)
⋮----
class PydanticType(TypeDecorator[T], Generic[T])
⋮----
"""SQLAlchemy type that handles Pydantic model serialization."""
⋮----
impl = JSON
cache_ok = True
⋮----
def __init__(self, pydantic_type: type[T], **kwargs: dict[str, Any])
⋮----
"""Initialize the PydanticType.

        Args:
            pydantic_type: The Pydantic model type to handle.
            **kwargs: Additional arguments for TypeDecorator.
        """
⋮----
"""Convert Pydantic model to a JSON-serializable dictionary for the database."""
⋮----
"""Convert a JSON-like dictionary from the database back to a Pydantic model."""
⋮----
class PydanticListType(TypeDecorator, Generic[T])
⋮----
"""SQLAlchemy type that handles lists of Pydantic models."""
⋮----
"""Initialize the PydanticListType.

        Args:
            pydantic_type: The Pydantic model type for items in the list.
            **kwargs: Additional arguments for TypeDecorator.
        """
⋮----
"""Convert a list of Pydantic models to a JSON-serializable list for the DB."""
⋮----
"""Convert a JSON-like list from the DB back to a list of Pydantic models."""
⋮----
# Base class for all database models
class Base(DeclarativeBase)
⋮----
"""Base class for declarative models in A2A SDK."""
⋮----
# TaskMixin that can be used with any table name
class TaskMixin
⋮----
"""Mixin providing standard task columns with proper type handling."""
⋮----
id: Mapped[str] = mapped_column(String(36), primary_key=True, index=True)
context_id: Mapped[str] = mapped_column(String(36), nullable=False)
kind: Mapped[str] = mapped_column(
⋮----
# Properly typed Pydantic fields with automatic serialization
status: Mapped[TaskStatus] = mapped_column(PydanticType(TaskStatus))
artifacts: Mapped[list[Artifact] | None] = mapped_column(
history: Mapped[list[Message] | None] = mapped_column(
⋮----
# Using declared_attr to avoid conflict with Pydantic's metadata
⋮----
@declared_attr
@classmethod
    def task_metadata(cls) -> Mapped[dict[str, Any] | None]
⋮----
"""Define the 'metadata' column, avoiding name conflicts with Pydantic."""
⋮----
@override
    def __repr__(self) -> str
⋮----
"""Return a string representation of the task."""
repr_template = (
⋮----
"""Create a TaskModel class with a configurable table name.

    Args:
        table_name: Name of the database table. Defaults to 'tasks'.
        base: Base declarative class to use. Defaults to the SDK's Base class.

    Returns:
        TaskModel class with the specified table name.

    Example:
        # Create a task model with default table name
        TaskModel = create_task_model()

        # Create a task model with custom table name
        CustomTaskModel = create_task_model('my_tasks')

        # Use with a custom base
        from myapp.database import Base as MyBase
        TaskModel = create_task_model('tasks', MyBase)
    """
⋮----
class TaskModel(TaskMixin, base):  # type: ignore
⋮----
__tablename__ = table_name
⋮----
@override
        def __repr__(self) -> str
⋮----
"""Return a string representation of the task."""
repr_template = '<TaskModel[{TABLE}](id="{ID}", context_id="{CTX_ID}", status="{STATUS}")>'
⋮----
# Set a dynamic name for better debugging
⋮----
# Default TaskModel for backward compatibility
class TaskModel(TaskMixin, Base)
⋮----
"""Default task model with standard table name."""
⋮----
__tablename__ = 'tasks'
⋮----
# PushNotificationConfigMixin that can be used with any table name
class PushNotificationConfigMixin
⋮----
"""Mixin providing standard push notification config columns."""
⋮----
task_id: Mapped[str] = mapped_column(String(36), primary_key=True)
config_id: Mapped[str] = mapped_column(String(255), primary_key=True)
config_data: Mapped[bytes] = mapped_column(LargeBinary, nullable=False)
⋮----
"""Return a string representation of the push notification config."""
repr_template = '<{CLS}(task_id="{TID}", config_id="{CID}")>'
⋮----
"""Create a PushNotificationConfigModel class with a configurable table name."""
⋮----
class PushNotificationConfigModel(PushNotificationConfigMixin, base):  # type: ignore
⋮----
"""Return a string representation of the push notification config."""
repr_template = '<PushNotificationConfigModel[{TABLE}](task_id="{TID}", config_id="{CID}")>'
⋮----
# Default PushNotificationConfigModel for backward compatibility
class PushNotificationConfigModel(PushNotificationConfigMixin, Base)
⋮----
"""Default push notification config model with standard table name."""
⋮----
__tablename__ = 'push_notification_configs'

================
File: src/a2a/utils/__init__.py
================
"""Utility functions for the A2A Python SDK."""
⋮----
__all__ = [

================
File: src/a2a/utils/artifact.py
================
"""Utility functions for creating A2A Artifact objects."""
⋮----
"""Creates a new Artifact object.

    Args:
        parts: The list of `Part` objects forming the artifact's content.
        name: The human-readable name of the artifact.
        description: An optional description of the artifact.

    Returns:
        A new `Artifact` object with a generated artifact_id.
    """
⋮----
"""Creates a new Artifact object containing only a single TextPart.

    Args:
        name: The human-readable name of the artifact.
        text: The text content of the artifact.
        description: An optional description of the artifact.

    Returns:
        A new `Artifact` object with a generated artifact_id.
    """
⋮----
"""Creates a new Artifact object containing only a single DataPart.

    Args:
        name: The human-readable name of the artifact.
        data: The structured data content of the artifact.
        description: An optional description of the artifact.

    Returns:
        A new `Artifact` object with a generated artifact_id.
    """

================
File: src/a2a/utils/constants.py
================
"""Constants for well-known URIs used throughout the A2A Python SDK."""
⋮----
AGENT_CARD_WELL_KNOWN_PATH = '/.well-known/agent-card.json'
PREV_AGENT_CARD_WELL_KNOWN_PATH = '/.well-known/agent.json'
EXTENDED_AGENT_CARD_PATH = '/agent/authenticatedExtendedCard'
DEFAULT_RPC_URL = '/'

================
File: src/a2a/utils/error_handlers.py
================
logger = logging.getLogger(__name__)
⋮----
A2AErrorToHttpStatus: dict[type[A2ABaseModel], int] = {
⋮----
"""Decorator to catch ServerError and map it to an appropriate JSONResponse."""
⋮----
@functools.wraps(func)
    async def wrapper(*args: Any, **kwargs: Any) -> Response
⋮----
error = e.error or InternalError(
http_code = A2AErrorToHttpStatus.get(type(error), 500)
⋮----
log_level = (
⋮----
"""Decorator to catch ServerError for a straming method,log it and then rethrow it to be handled by framework."""
⋮----
@functools.wraps(func)
    async def wrapper(*args: Any, **kwargs: Any) -> Any
⋮----
# Since the stream has started, we can't return a JSONResponse.
# Instead, we runt the error handling logic (provides logging)
# and reraise the error and let server framework manage

================
File: src/a2a/utils/errors.py
================
"""Custom exceptions for A2A server-side errors."""
⋮----
class A2AServerError(Exception)
⋮----
"""Base exception for A2A Server errors."""
⋮----
class MethodNotImplementedError(A2AServerError)
⋮----
"""Exception raised for methods that are not implemented by the server handler."""
⋮----
"""Initializes the MethodNotImplementedError.

        Args:
            message: A descriptive error message.
        """
⋮----
class ServerError(Exception)
⋮----
"""Wrapper exception for A2A or JSON-RPC errors originating from the server's logic.

    This exception is used internally by request handlers and other server components
    to signal a specific error that should be formatted as a JSON-RPC error response.
    """
⋮----
"""Initializes the ServerError.

        Args:
            error: The specific A2A or JSON-RPC error model instance.
                   If None, an `InternalError` will be used when formatting the response.
        """

================
File: src/a2a/utils/helpers.py
================
"""General utility functions for the A2A Python SDK."""
⋮----
logger = logging.getLogger(__name__)
⋮----
@trace_function()
def create_task_obj(message_send_params: MessageSendParams) -> Task
⋮----
"""Create a new task object from message send params.

    Generates UUIDs for task and context IDs if they are not already present in the message.

    Args:
        message_send_params: The `MessageSendParams` object containing the initial message.

    Returns:
        A new `Task` object initialized with 'submitted' status and the input message in history.
    """
⋮----
@trace_function()
def append_artifact_to_task(task: Task, event: TaskArtifactUpdateEvent) -> None
⋮----
"""Helper method for updating a Task object with new artifact data from an event.

    Handles creating the artifacts list if it doesn't exist, adding new artifacts,
    and appending parts to existing artifacts based on the `append` flag in the event.

    Args:
        task: The `Task` object to modify.
        event: The `TaskArtifactUpdateEvent` containing the artifact data.
    """
⋮----
new_artifact_data: Artifact = event.artifact
artifact_id: str = new_artifact_data.artifact_id
append_parts: bool = event.append or False
⋮----
existing_artifact: Artifact | None = None
existing_artifact_list_index: int | None = None
⋮----
# Find existing artifact by its id
⋮----
existing_artifact = art
existing_artifact_list_index = i
⋮----
# This represents the first chunk for this artifact index.
⋮----
# Replace the existing artifact entirely with the new data
⋮----
# Append the new artifact since no artifact with this index exists yet
⋮----
# Append new parts to the existing artifact's part list
⋮----
# We received a chunk to append, but we don't have an existing artifact.
# we will ignore this chunk
⋮----
def build_text_artifact(text: str, artifact_id: str) -> Artifact
⋮----
"""Helper to create a text artifact.

    Args:
        text: The text content for the artifact.
        artifact_id: The ID for the artifact.

    Returns:
        An `Artifact` object containing a single `TextPart`.
    """
text_part = TextPart(text=text)
part = Part(root=text_part)
⋮----
"""Decorator that validates if a given expression evaluates to True.

    Typically used on class methods to check capabilities or configuration
    before executing the method's logic. If the expression is False,
    a `ServerError` with an `UnsupportedOperationError` is raised.

    Args:
        expression: A callable that takes the instance (`self`) as its argument
                    and returns a boolean.
        error_message: An optional custom error message for the `UnsupportedOperationError`.
                       If None, the string representation of the expression will be used.
    """
⋮----
def decorator(function: Callable) -> Callable
⋮----
@functools.wraps(function)
            async def async_wrapper(self: Any, *args, **kwargs) -> Any
⋮----
final_message = error_message or str(expression)
⋮----
@functools.wraps(function)
        def sync_wrapper(self: Any, *args, **kwargs) -> Any
⋮----
def decorator(function)
⋮----
@functools.wraps(function)
        async def wrapper(self, *args, **kwargs)
⋮----
"""Checks if server and client output modalities (MIME types) are compatible.

    Modalities are compatible if:
    1. The client specifies no preferred output modes (client_output_modes is None or empty).
    2. The server specifies no supported output modes (server_output_modes is None or empty).
    3. There is at least one common modality between the server's supported list and the client's preferred list.

    Args:
        server_output_modes: A list of MIME types supported by the server/agent for output.
                             Can be None or empty if the server doesn't specify.
        client_output_modes: A list of MIME types preferred by the client for output.
                             Can be None or empty if the client accepts any.

    Returns:
        True if the modalities are compatible, False otherwise.
    """

================
File: src/a2a/utils/message.py
================
"""Utility functions for creating and handling A2A Message objects."""
⋮----
"""Creates a new agent message containing a single TextPart.

    Args:
        text: The text content of the message.
        context_id: The context ID for the message.
        task_id: The task ID for the message.

    Returns:
        A new `Message` object with role 'agent'.
    """
⋮----
"""Creates a new agent message containing a list of Parts.

    Args:
        parts: The list of `Part` objects for the message content.
        context_id: The context ID for the message.
        task_id: The task ID for the message.

    Returns:
        A new `Message` object with role 'agent'.
    """
⋮----
def get_text_parts(parts: list[Part]) -> list[str]
⋮----
"""Extracts text content from all TextPart objects in a list of Parts.

    Args:
        parts: A list of `Part` objects.

    Returns:
        A list of strings containing the text content from any `TextPart` objects found.
    """
⋮----
def get_data_parts(parts: list[Part]) -> list[dict[str, Any]]
⋮----
"""Extracts dictionary data from all DataPart objects in a list of Parts.

    Args:
        parts: A list of `Part` objects.

    Returns:
        A list of dictionaries containing the data from any `DataPart` objects found.
    """
⋮----
def get_file_parts(parts: list[Part]) -> list[FileWithBytes | FileWithUri]
⋮----
"""Extracts file data from all FilePart objects in a list of Parts.

    Args:
        parts: A list of `Part` objects.

    Returns:
        A list of `FileWithBytes` or `FileWithUri` objects containing the file data from any `FilePart` objects found.
    """
⋮----
def get_message_text(message: Message, delimiter: str = '\n') -> str
⋮----
"""Extracts and joins all text content from a Message's parts.

    Args:
        message: The `Message` object.
        delimiter: The string to use when joining text from multiple TextParts.

    Returns:
        A single string containing all text content, or an empty string if no text parts are found.
    """

================
File: src/a2a/utils/proto_utils.py
================
# mypy: disable-error-code="arg-type"
"""Utils for converting between proto and Python types."""
⋮----
logger = logging.getLogger(__name__)
⋮----
# Regexp patterns for matching
_TASK_NAME_MATCH = r'tasks/([\w-]+)'
_TASK_PUSH_CONFIG_NAME_MATCH = (
⋮----
class ToProto
⋮----
"""Converts Python types to proto types."""
⋮----
@classmethod
    def message(cls, message: types.Message | None) -> a2a_pb2.Message | None
⋮----
# TODO: Add support for other types.
⋮----
@classmethod
    def part(cls, part: types.Part) -> a2a_pb2.Part
⋮----
@classmethod
    def data(cls, data: dict[str, Any]) -> a2a_pb2.DataPart
⋮----
json_data = json.dumps(data)
⋮----
@classmethod
    def task(cls, task: types.Task) -> a2a_pb2.Task
⋮----
[ToProto.message(h) for h in task.history]  # type: ignore[misc]
⋮----
@classmethod
    def task_status(cls, status: types.TaskStatus) -> a2a_pb2.TaskStatus
⋮----
@classmethod
    def task_state(cls, state: types.TaskState) -> a2a_pb2.TaskState
⋮----
@classmethod
    def artifact(cls, artifact: types.Artifact) -> a2a_pb2.Artifact
⋮----
auth_info = (
⋮----
"""Converts a task, message, or task update event to a StreamResponse."""
⋮----
rval: list[a2a_pb2.Security] = []
⋮----
@classmethod
    def oauth2_flows(cls, flows: types.OAuthFlows) -> a2a_pb2.OAuthFlows
⋮----
@classmethod
    def skill(cls, skill: types.AgentSkill) -> a2a_pb2.AgentSkill
⋮----
@classmethod
    def role(cls, role: types.Role) -> a2a_pb2.Role
⋮----
class FromProto
⋮----
"""Converts proto types to Python types."""
⋮----
@classmethod
    def message(cls, message: a2a_pb2.Message) -> types.Message
⋮----
@classmethod
    def metadata(cls, metadata: struct_pb2.Struct) -> dict[str, Any]
⋮----
@classmethod
    def part(cls, part: a2a_pb2.Part) -> types.Part
⋮----
@classmethod
    def data(cls, data: a2a_pb2.DataPart) -> dict[str, Any]
⋮----
json_data = json_format.MessageToJson(data.data)
⋮----
@classmethod
    def task(cls, task: a2a_pb2.Task) -> types.Task
⋮----
@classmethod
    def task_status(cls, status: a2a_pb2.TaskStatus) -> types.TaskStatus
⋮----
@classmethod
    def task_state(cls, state: a2a_pb2.TaskState) -> types.TaskState
⋮----
@classmethod
    def artifact(cls, artifact: a2a_pb2.Artifact) -> types.Artifact
⋮----
# This is currently incomplete until the core sdk supports multiple
# configs for a single task.
⋮----
m = re.match(_TASK_PUSH_CONFIG_NAME_MATCH, request.name)
⋮----
m = re.match(_TASK_NAME_MATCH, request.name)
⋮----
m = re.match(_TASK_NAME_MATCH, request.parent)
⋮----
m = re.match(_TASK_PUSH_CONFIG_NAME_MATCH, config.name)
⋮----
rval: list[dict[str, list[str]]] = []
⋮----
in_=types.In(scheme.api_key_security_scheme.location),  # type: ignore[call-arg]
⋮----
@classmethod
    def oauth2_flows(cls, flows: a2a_pb2.OAuthFlows) -> types.OAuthFlows
⋮----
@classmethod
    def skill(cls, skill: a2a_pb2.AgentSkill) -> types.AgentSkill
⋮----
@classmethod
    def role(cls, role: a2a_pb2.Role) -> types.Role

================
File: src/a2a/utils/task.py
================
"""Utility functions for creating A2A Task objects."""
⋮----
def new_task(request: Message) -> Task
⋮----
"""Creates a new Task object from an initial user message.

    Generates task and context IDs if not provided in the message.

    Args:
        request: The initial `Message` object from the user.

    Returns:
        A new `Task` object initialized with 'submitted' status and the input message in history.

    Raises:
        TypeError: If the message role is None.
        ValueError: If the message parts are empty, if any part has empty content, or if the provided context_id is invalid.
    """
⋮----
context_id_str = request.context_id
⋮----
context_id = context_id_str
⋮----
context_id = str(uuid.uuid4())
⋮----
"""Creates a Task object in the 'completed' state.

    Useful for constructing a final Task representation when the agent
    finishes and produces artifacts.

    Args:
        task_id: The ID of the task.
        context_id: The context ID of the task.
        artifacts: A list of `Artifact` objects produced by the task.
        history: An optional list of `Message` objects representing the task history.

    Returns:
        A `Task` object with status set to 'completed'.
    """
⋮----
history = []

================
File: src/a2a/utils/telemetry.py
================
"""OpenTelemetry Tracing Utilities for A2A Python SDK.

This module provides decorators to simplify the integration of OpenTelemetry
tracing into Python applications. It offers `trace_function` for instrumenting
individual functions (both synchronous and asynchronous) and `trace_class`
for instrumenting multiple methods within a class.

The tracer is initialized with the module name and version defined by
`INSTRUMENTING_MODULE_NAME` ('a2a-python-sdk') and
`INSTRUMENTING_MODULE_VERSION` ('1.0.0').

Features:
- Automatic span creation for decorated functions/methods.
- Support for both synchronous and asynchronous functions.
- Default span naming based on module and function/class/method name.
- Customizable span names, kinds, and static attributes.
- Dynamic attribute setting via an `attribute_extractor` callback.
- Automatic recording of exceptions and setting of span status.
- Selective method tracing in classes using include/exclude lists.

Usage:
    For a single function:
    ```python
    from your_module import trace_function


    @trace_function
    def my_function():
        # ...
        pass


    @trace_function(span_name='custom.op', kind=SpanKind.CLIENT)
    async def my_async_function():
        # ...
        pass
    ```

    For a class:
    ```python
    from your_module import trace_class


    @trace_class(exclude_list=['internal_method'])
    class MyService:
        def public_api(self, user_id):
            # This method will be traced
            pass

        def internal_method(self):
            # This method will not be traced
            pass
    ```
"""
⋮----
SpanKindType = object
⋮----
logger = logging.getLogger(__name__)
⋮----
class _NoOp
⋮----
"""A no-op object that absorbs all tracing calls when OpenTelemetry is not installed."""
⋮----
def __call__(self, *args: Any, **kwargs: Any) -> Any
⋮----
def __enter__(self) -> '_NoOp'
⋮----
def __exit__(self, *args: object, **kwargs: Any) -> None
⋮----
def __getattr__(self, name: str) -> Any
⋮----
trace = _NoOp()  # type: ignore
_SpanKind = _NoOp()  # type: ignore
StatusCode = _NoOp()  # type: ignore
⋮----
SpanKind = _SpanKind
__all__ = ['SpanKind']
⋮----
INSTRUMENTING_MODULE_NAME = 'a2a-python-sdk'
INSTRUMENTING_MODULE_VERSION = '1.0.0'
⋮----
def trace_function(  # noqa: PLR0915
⋮----
"""A decorator to automatically trace a function call with OpenTelemetry.

    This decorator can be used to wrap both sync and async functions.
    When applied, it creates a new span for each call to the decorated function.
    The span will record the execution time, status (OK or ERROR), and any
    exceptions that occur.

    It can be used in two ways:

    1. As a direct decorator: `@trace_function`
    2. As a decorator factory to provide arguments: `@trace_function(span_name="custom.name")`

    Args:
        func (callable, optional): The function to be decorated. If None,
            the decorator returns a partial function, allowing it to be called
            with arguments. Defaults to None.
        span_name (str, optional): Custom name for the span. If None,
            it defaults to ``f'{func.__module__}.{func.__name__}'``.
            Defaults to None.
        kind (SpanKind, optional): The ``opentelemetry.trace.SpanKind`` for the
            created span. Defaults to ``SpanKind.INTERNAL``.
        attributes (dict, optional): A dictionary of static attributes to be
            set on the span. Keys are attribute names (str) and values are
            the corresponding attribute values. Defaults to None.
        attribute_extractor (callable, optional): A function that can be used
            to dynamically extract and set attributes on the span.
            It is called within a ``finally`` block, ensuring it runs even if
            the decorated function raises an exception.
            The function signature should be:
            ``attribute_extractor(span, args, kwargs, result, exception)``
            where:
                - ``span`` : the OpenTelemetry ``Span`` object.
                - ``args`` : a tuple of positional arguments passed
                - ``kwargs`` : a dictionary of keyword arguments passed
                - ``result`` : return value (None if an exception occurred)
                - ``exception`` : exception object if raised (None otherwise).
            Any exception raised by the ``attribute_extractor`` itself will be
            caught and logged. Defaults to None.

    Returns:
        callable: The wrapped function that includes tracing, or a partial
            decorator if ``func`` is None.
    """
⋮----
actual_span_name = span_name or f'{func.__module__}.{func.__name__}'
⋮----
is_async_func = inspect.iscoroutinefunction(func)
⋮----
@functools.wraps(func)
    async def async_wrapper(*args, **kwargs) -> Any
⋮----
"""Async Wrapper for the decorator."""
⋮----
tracer = trace.get_tracer(
⋮----
result = None
exception = None
⋮----
# Async wrapper, await for the function call to complete.
result = await func(*args, **kwargs)
⋮----
# asyncio.CancelledError extends from BaseException
⋮----
exception = e
⋮----
@functools.wraps(func)
    def sync_wrapper(*args, **kwargs) -> Any
⋮----
"""Sync Wrapper for the decorator."""
tracer = trace.get_tracer(INSTRUMENTING_MODULE_NAME)
⋮----
# Sync wrapper, execute the function call.
result = func(*args, **kwargs)
⋮----
"""A class decorator to automatically trace specified methods of a class.

    This decorator iterates over the methods of a class and applies the
    `trace_function` decorator to them, based on the `include_list` and
    `exclude_list` criteria. Methods starting or ending with double underscores
    (dunder methods, e.g., `__init__`, `__call__`) are always excluded by default.

    Args:
        include_list (list[str], optional): A list of method names to
            explicitly include for tracing. If provided, only methods in this
            list (that are not dunder methods) will be traced.
            Defaults to None (trace all non-dunder methods).
        exclude_list (list[str], optional): A list of method names to exclude
            from tracing. This is only considered if `include_list` is not
            provided. Dunder methods are implicitly excluded.
            Defaults to an empty list.
        kind (SpanKind, optional): The `opentelemetry.trace.SpanKind` for the
            created spans on the methods. Defaults to `SpanKind.INTERNAL`.

    Returns:
        callable: A decorator function that, when applied to a class,
                  modifies the class to wrap its specified methods with tracing.

    Example:
        To trace all methods except 'internal_method':
        ```python
        @trace_class(exclude_list=['internal_method'])
        class MyService:
            def public_api(self):
                pass

            def internal_method(self):
                pass
        ```

        To trace only 'method_one' and 'method_two':
        ```python
        @trace_class(include_list=['method_one', 'method_two'])
        class AnotherService:
            def method_one(self):
                pass

            def method_two(self):
                pass

            def not_traced_method(self):
                pass
        ```
    """
⋮----
exclude_list = exclude_list or []
⋮----
def decorator(cls: Any) -> Any
⋮----
span_name = f'{cls.__module__}.{cls.__name__}.{name}'

================
File: src/a2a/__init__.py
================
"""The A2A Python SDK."""

================
File: src/a2a/_base.py
================
def to_camel_custom(snake: str) -> str
⋮----
"""Convert a snake_case string to camelCase.

    Args:
        snake: The string to convert.

    Returns:
        The converted camelCase string.
    """
# First, remove any trailing underscores. This is common for names that
# conflict with Python keywords, like 'in_' or 'from_'.
⋮----
snake = snake.rstrip('_')
⋮----
class A2ABaseModel(BaseModel)
⋮----
"""Base class for shared behavior across A2A data models.

    Provides a common configuration (e.g., alias-based population) and
    serves as the foundation for future extensions or shared utilities.

    This implementation provides backward compatibility for camelCase aliases
    by lazy-loading an alias map upon first use. Accessing or setting
    attributes via their camelCase alias will raise a DeprecationWarning.
    """
⋮----
model_config = ConfigDict(
⋮----
# SEE: https://docs.pydantic.dev/latest/api/config/#pydantic.config.ConfigDict.populate_by_name

================
File: src/a2a/types.py
================
# generated by datamodel-codegen:
#   filename:  https://raw.githubusercontent.com/a2aproject/A2A/refs/heads/main/specification/json/a2a.json
⋮----
class A2A(RootModel[Any])
⋮----
root: Any
⋮----
class In(str, Enum)
⋮----
"""
    The location of the API key.
    """
⋮----
cookie = 'cookie'
header = 'header'
query = 'query'
⋮----
class APIKeySecurityScheme(A2ABaseModel)
⋮----
"""
    Defines a security scheme using an API key.
    """
⋮----
description: str | None = None
"""
    An optional description for the security scheme.
    """
in_: In
⋮----
name: str
"""
    The name of the header, query, or cookie parameter to be used.
    """
type: Literal['apiKey'] = 'apiKey'
"""
    The type of the security scheme. Must be 'apiKey'.
    """
⋮----
class AgentCardSignature(A2ABaseModel)
⋮----
"""
    AgentCardSignature represents a JWS signature of an AgentCard.
    This follows the JSON format of an RFC 7515 JSON Web Signature (JWS).
    """
⋮----
header: dict[str, Any] | None = None
"""
    The unprotected JWS header values.
    """
protected: str
"""
    The protected JWS header for the signature. This is a Base64url-encoded
    JSON object, as per RFC 7515.
    """
signature: str
"""
    The computed signature, Base64url-encoded.
    """
⋮----
class AgentExtension(A2ABaseModel)
⋮----
"""
    A declaration of a protocol extension supported by an Agent.
    """
⋮----
"""
    A human-readable description of how this agent uses the extension.
    """
params: dict[str, Any] | None = None
"""
    Optional, extension-specific configuration parameters.
    """
required: bool | None = None
"""
    If true, the client must understand and comply with the extension's requirements
    to interact with the agent.
    """
uri: str
"""
    The unique URI identifying the extension.
    """
⋮----
class AgentInterface(A2ABaseModel)
⋮----
"""
    Declares a combination of a target URL and a transport protocol for interacting with the agent.
    This allows agents to expose the same functionality over multiple transport mechanisms.
    """
⋮----
transport: str = Field(..., examples=['JSONRPC', 'GRPC', 'HTTP+JSON'])
"""
    The transport protocol supported at this URL.
    """
url: str = Field(
"""
    The URL where this interface is available. Must be a valid absolute HTTPS URL in production.
    """
⋮----
class AgentProvider(A2ABaseModel)
⋮----
"""
    Represents the service provider of an agent.
    """
⋮----
organization: str
"""
    The name of the agent provider's organization.
    """
url: str
"""
    A URL for the agent provider's website or relevant documentation.
    """
⋮----
class AgentSkill(A2ABaseModel)
⋮----
"""
    Represents a distinct capability or function that an agent can perform.
    """
⋮----
description: str
"""
    A detailed description of the skill, intended to help clients or users
    understand its purpose and functionality.
    """
examples: list[str] | None = Field(
"""
    Example prompts or scenarios that this skill can handle. Provides a hint to
    the client on how to use the skill.
    """
id: str
"""
    A unique identifier for the agent's skill.
    """
input_modes: list[str] | None = None
"""
    The set of supported input MIME types for this skill, overriding the agent's defaults.
    """
⋮----
"""
    A human-readable name for the skill.
    """
output_modes: list[str] | None = None
"""
    The set of supported output MIME types for this skill, overriding the agent's defaults.
    """
security: list[dict[str, list[str]]] | None = Field(
"""
    Security schemes necessary for the agent to leverage this skill.
    As in the overall AgentCard.security, this list represents a logical OR of security
    requirement objects. Each object is a set of security schemes that must be used together
    (a logical AND).
    """
tags: list[str] = Field(
"""
    A set of keywords describing the skill's capabilities.
    """
⋮----
class AuthenticatedExtendedCardNotConfiguredError(A2ABaseModel)
⋮----
"""
    An A2A-specific error indicating that the agent does not have an Authenticated Extended Card configured
    """
⋮----
code: Literal[-32007] = -32007
"""
    The error code for when an authenticated extended card is not configured.
    """
data: Any | None = None
"""
    A primitive or structured value containing additional information about the error.
    This may be omitted.
    """
message: str | None = 'Authenticated Extended Card is not configured'
"""
    The error message.
    """
⋮----
class AuthorizationCodeOAuthFlow(A2ABaseModel)
⋮----
"""
    Defines configuration details for the OAuth 2.0 Authorization Code flow.
    """
⋮----
authorization_url: str
"""
    The authorization URL to be used for this flow.
    This MUST be a URL and use TLS.
    """
refresh_url: str | None = None
"""
    The URL to be used for obtaining refresh tokens.
    This MUST be a URL and use TLS.
    """
scopes: dict[str, str]
"""
    The available scopes for the OAuth2 security scheme. A map between the scope
    name and a short description for it.
    """
token_url: str
"""
    The token URL to be used for this flow.
    This MUST be a URL and use TLS.
    """
⋮----
class ClientCredentialsOAuthFlow(A2ABaseModel)
⋮----
"""
    Defines configuration details for the OAuth 2.0 Client Credentials flow.
    """
⋮----
"""
    The URL to be used for obtaining refresh tokens. This MUST be a URL.
    """
⋮----
"""
    The token URL to be used for this flow. This MUST be a URL.
    """
⋮----
class ContentTypeNotSupportedError(A2ABaseModel)
⋮----
"""
    An A2A-specific error indicating an incompatibility between the requested
    content types and the agent's capabilities.
    """
⋮----
code: Literal[-32005] = -32005
"""
    The error code for an unsupported content type.
    """
⋮----
message: str | None = 'Incompatible content types'
⋮----
class DataPart(A2ABaseModel)
⋮----
"""
    Represents a structured data segment (e.g., JSON) within a message or artifact.
    """
⋮----
data: dict[str, Any]
"""
    The structured data content.
    """
kind: Literal['data'] = 'data'
"""
    The type of this part, used as a discriminator. Always 'data'.
    """
metadata: dict[str, Any] | None = None
"""
    Optional metadata associated with this part.
    """
⋮----
class DeleteTaskPushNotificationConfigParams(A2ABaseModel)
⋮----
"""
    Defines parameters for deleting a specific push notification configuration for a task.
    """
⋮----
"""
    The unique identifier of the task.
    """
⋮----
"""
    Optional metadata associated with the request.
    """
push_notification_config_id: str
"""
    The ID of the push notification configuration to delete.
    """
⋮----
class DeleteTaskPushNotificationConfigRequest(A2ABaseModel)
⋮----
"""
    Represents a JSON-RPC request for the `tasks/pushNotificationConfig/delete` method.
    """
⋮----
id: str | int
"""
    The identifier for this request.
    """
jsonrpc: Literal['2.0'] = '2.0'
"""
    The version of the JSON-RPC protocol. MUST be exactly "2.0".
    """
method: Literal['tasks/pushNotificationConfig/delete'] = (
"""
    The method name. Must be 'tasks/pushNotificationConfig/delete'.
    """
params: DeleteTaskPushNotificationConfigParams
"""
    The parameters identifying the push notification configuration to delete.
    """
⋮----
class DeleteTaskPushNotificationConfigSuccessResponse(A2ABaseModel)
⋮----
"""
    Represents a successful JSON-RPC response for the `tasks/pushNotificationConfig/delete` method.
    """
⋮----
id: str | int | None = None
"""
    The identifier established by the client.
    """
⋮----
result: None
"""
    The result is null on successful deletion.
    """
⋮----
class FileBase(A2ABaseModel)
⋮----
"""
    Defines base properties for a file.
    """
⋮----
mime_type: str | None = None
"""
    The MIME type of the file (e.g., "application/pdf").
    """
name: str | None = None
"""
    An optional name for the file (e.g., "document.pdf").
    """
⋮----
class FileWithBytes(A2ABaseModel)
⋮----
"""
    Represents a file with its content provided directly as a base64-encoded string.
    """
⋮----
bytes: str
"""
    The base64-encoded content of the file.
    """
⋮----
class FileWithUri(A2ABaseModel)
⋮----
"""
    Represents a file with its content located at a specific URI.
    """
⋮----
"""
    A URL pointing to the file's content.
    """
⋮----
class GetAuthenticatedExtendedCardRequest(A2ABaseModel)
⋮----
"""
    Represents a JSON-RPC request for the `agent/getAuthenticatedExtendedCard` method.
    """
⋮----
method: Literal['agent/getAuthenticatedExtendedCard'] = (
"""
    The method name. Must be 'agent/getAuthenticatedExtendedCard'.
    """
⋮----
class GetTaskPushNotificationConfigParams(A2ABaseModel)
⋮----
"""
    Defines parameters for fetching a specific push notification configuration for a task.
    """
⋮----
push_notification_config_id: str | None = None
"""
    The ID of the push notification configuration to retrieve.
    """
⋮----
class HTTPAuthSecurityScheme(A2ABaseModel)
⋮----
"""
    Defines a security scheme using HTTP authentication.
    """
⋮----
bearer_format: str | None = None
"""
    A hint to the client to identify how the bearer token is formatted (e.g., "JWT").
    This is primarily for documentation purposes.
    """
⋮----
scheme: str
"""
    The name of the HTTP Authentication scheme to be used in the Authorization header,
    as defined in RFC7235 (e.g., "Bearer").
    This value should be registered in the IANA Authentication Scheme registry.
    """
type: Literal['http'] = 'http'
"""
    The type of the security scheme. Must be 'http'.
    """
⋮----
class ImplicitOAuthFlow(A2ABaseModel)
⋮----
"""
    Defines configuration details for the OAuth 2.0 Implicit flow.
    """
⋮----
"""
    The authorization URL to be used for this flow. This MUST be a URL.
    """
⋮----
class InternalError(A2ABaseModel)
⋮----
"""
    An error indicating an internal error on the server.
    """
⋮----
code: Literal[-32603] = -32603
"""
    The error code for an internal server error.
    """
⋮----
message: str | None = 'Internal error'
⋮----
class InvalidAgentResponseError(A2ABaseModel)
⋮----
"""
    An A2A-specific error indicating that the agent returned a response that
    does not conform to the specification for the current method.
    """
⋮----
code: Literal[-32006] = -32006
"""
    The error code for an invalid agent response.
    """
⋮----
message: str | None = 'Invalid agent response'
⋮----
class InvalidParamsError(A2ABaseModel)
⋮----
"""
    An error indicating that the method parameters are invalid.
    """
⋮----
code: Literal[-32602] = -32602
"""
    The error code for an invalid parameters error.
    """
⋮----
message: str | None = 'Invalid parameters'
⋮----
class InvalidRequestError(A2ABaseModel)
⋮----
"""
    An error indicating that the JSON sent is not a valid Request object.
    """
⋮----
code: Literal[-32600] = -32600
"""
    The error code for an invalid request.
    """
⋮----
message: str | None = 'Request payload validation error'
⋮----
class JSONParseError(A2ABaseModel)
⋮----
"""
    An error indicating that the server received invalid JSON.
    """
⋮----
code: Literal[-32700] = -32700
"""
    The error code for a JSON parse error.
    """
⋮----
message: str | None = 'Invalid JSON payload'
⋮----
class JSONRPCError(A2ABaseModel)
⋮----
"""
    Represents a JSON-RPC 2.0 Error object, included in an error response.
    """
⋮----
code: int
"""
    A number that indicates the error type that occurred.
    """
⋮----
message: str
"""
    A string providing a short description of the error.
    """
⋮----
class JSONRPCMessage(A2ABaseModel)
⋮----
"""
    Defines the base structure for any JSON-RPC 2.0 request, response, or notification.
    """
⋮----
"""
    A unique identifier established by the client. It must be a String, a Number, or null.
    The server must reply with the same value in the response. This property is omitted for notifications.
    """
⋮----
class JSONRPCRequest(A2ABaseModel)
⋮----
"""
    Represents a JSON-RPC 2.0 Request object.
    """
⋮----
method: str
"""
    A string containing the name of the method to be invoked.
    """
⋮----
"""
    A structured value holding the parameter values to be used during the method invocation.
    """
⋮----
class JSONRPCSuccessResponse(A2ABaseModel)
⋮----
"""
    Represents a successful JSON-RPC 2.0 Response object.
    """
⋮----
result: Any
"""
    The value of this member is determined by the method invoked on the Server.
    """
⋮----
class ListTaskPushNotificationConfigParams(A2ABaseModel)
⋮----
"""
    Defines parameters for listing all push notification configurations associated with a task.
    """
⋮----
class ListTaskPushNotificationConfigRequest(A2ABaseModel)
⋮----
"""
    Represents a JSON-RPC request for the `tasks/pushNotificationConfig/list` method.
    """
⋮----
method: Literal['tasks/pushNotificationConfig/list'] = (
"""
    The method name. Must be 'tasks/pushNotificationConfig/list'.
    """
params: ListTaskPushNotificationConfigParams
"""
    The parameters identifying the task whose configurations are to be listed.
    """
⋮----
class Role(str, Enum)
⋮----
"""
    Identifies the sender of the message. `user` for the client, `agent` for the service.
    """
⋮----
agent = 'agent'
user = 'user'
⋮----
class MethodNotFoundError(A2ABaseModel)
⋮----
"""
    An error indicating that the requested method does not exist or is not available.
    """
⋮----
code: Literal[-32601] = -32601
"""
    The error code for a method not found error.
    """
⋮----
message: str | None = 'Method not found'
⋮----
class MutualTLSSecurityScheme(A2ABaseModel)
⋮----
"""
    Defines a security scheme using mTLS authentication.
    """
⋮----
type: Literal['mutualTLS'] = 'mutualTLS'
"""
    The type of the security scheme. Must be 'mutualTLS'.
    """
⋮----
class OpenIdConnectSecurityScheme(A2ABaseModel)
⋮----
"""
    Defines a security scheme using OpenID Connect.
    """
⋮----
open_id_connect_url: str
"""
    The OpenID Connect Discovery URL for the OIDC provider's metadata.
    """
type: Literal['openIdConnect'] = 'openIdConnect'
"""
    The type of the security scheme. Must be 'openIdConnect'.
    """
⋮----
class PartBase(A2ABaseModel)
⋮----
"""
    Defines base properties common to all message or artifact parts.
    """
⋮----
class PasswordOAuthFlow(A2ABaseModel)
⋮----
"""
    Defines configuration details for the OAuth 2.0 Resource Owner Password flow.
    """
⋮----
class PushNotificationAuthenticationInfo(A2ABaseModel)
⋮----
"""
    Defines authentication details for a push notification endpoint.
    """
⋮----
credentials: str | None = None
"""
    Optional credentials required by the push notification endpoint.
    """
schemes: list[str]
"""
    A list of supported authentication schemes (e.g., 'Basic', 'Bearer').
    """
⋮----
class PushNotificationConfig(A2ABaseModel)
⋮----
"""
    Defines the configuration for setting up push notifications for task updates.
    """
⋮----
authentication: PushNotificationAuthenticationInfo | None = None
"""
    Optional authentication details for the agent to use when calling the notification URL.
    """
id: str | None = None
"""
    A unique ID for the push notification configuration, set by the client
    to support multiple notification callbacks.
    """
token: str | None = None
"""
    A unique token for this task or session to validate incoming push notifications.
    """
⋮----
"""
    The callback URL where the agent should send push notifications.
    """
⋮----
class PushNotificationNotSupportedError(A2ABaseModel)
⋮----
"""
    An A2A-specific error indicating that the agent does not support push notifications.
    """
⋮----
code: Literal[-32003] = -32003
"""
    The error code for when push notifications are not supported.
    """
⋮----
message: str | None = 'Push Notification is not supported'
⋮----
class SecuritySchemeBase(A2ABaseModel)
⋮----
"""
    Defines base properties shared by all security scheme objects.
    """
⋮----
class TaskIdParams(A2ABaseModel)
⋮----
"""
    Defines parameters containing a task ID, used for simple task operations.
    """
⋮----
class TaskNotCancelableError(A2ABaseModel)
⋮----
"""
    An A2A-specific error indicating that the task is in a state where it cannot be canceled.
    """
⋮----
code: Literal[-32002] = -32002
"""
    The error code for a task that cannot be canceled.
    """
⋮----
message: str | None = 'Task cannot be canceled'
⋮----
class TaskNotFoundError(A2ABaseModel)
⋮----
"""
    An A2A-specific error indicating that the requested task ID was not found.
    """
⋮----
code: Literal[-32001] = -32001
"""
    The error code for a task not found error.
    """
⋮----
message: str | None = 'Task not found'
⋮----
class TaskPushNotificationConfig(A2ABaseModel)
⋮----
"""
    A container associating a push notification configuration with a specific task.
    """
⋮----
push_notification_config: PushNotificationConfig
"""
    The push notification configuration for this task.
    """
task_id: str
"""
    The ID of the task.
    """
⋮----
class TaskQueryParams(A2ABaseModel)
⋮----
"""
    Defines parameters for querying a task, with an option to limit history length.
    """
⋮----
history_length: int | None = None
"""
    The number of most recent messages from the task's history to retrieve.
    """
⋮----
class TaskResubscriptionRequest(A2ABaseModel)
⋮----
"""
    Represents a JSON-RPC request for the `tasks/resubscribe` method, used to resume a streaming connection.
    """
⋮----
method: Literal['tasks/resubscribe'] = 'tasks/resubscribe'
"""
    The method name. Must be 'tasks/resubscribe'.
    """
params: TaskIdParams
"""
    The parameters identifying the task to resubscribe to.
    """
⋮----
class TaskState(str, Enum)
⋮----
"""
    Defines the lifecycle states of a Task.
    """
⋮----
submitted = 'submitted'
working = 'working'
input_required = 'input-required'
completed = 'completed'
canceled = 'canceled'
failed = 'failed'
rejected = 'rejected'
auth_required = 'auth-required'
unknown = 'unknown'
⋮----
class TextPart(A2ABaseModel)
⋮----
"""
    Represents a text segment within a message or artifact.
    """
⋮----
kind: Literal['text'] = 'text'
"""
    The type of this part, used as a discriminator. Always 'text'.
    """
⋮----
text: str
"""
    The string content of the text part.
    """
⋮----
class TransportProtocol(str, Enum)
⋮----
"""
    Supported A2A transport protocols.
    """
⋮----
jsonrpc = 'JSONRPC'
grpc = 'GRPC'
http_json = 'HTTP+JSON'
⋮----
class UnsupportedOperationError(A2ABaseModel)
⋮----
"""
    An A2A-specific error indicating that the requested operation is not supported by the agent.
    """
⋮----
code: Literal[-32004] = -32004
"""
    The error code for an unsupported operation.
    """
⋮----
message: str | None = 'This operation is not supported'
⋮----
class A2AError(
⋮----
root: (
"""
    A discriminated union of all standard JSON-RPC and A2A-specific error types.
    """
⋮----
class AgentCapabilities(A2ABaseModel)
⋮----
"""
    Defines optional capabilities supported by an agent.
    """
⋮----
extensions: list[AgentExtension] | None = None
"""
    A list of protocol extensions supported by the agent.
    """
push_notifications: bool | None = None
"""
    Indicates if the agent supports sending push notifications for asynchronous task updates.
    """
state_transition_history: bool | None = None
"""
    Indicates if the agent provides a history of state transitions for a task.
    """
streaming: bool | None = None
"""
    Indicates if the agent supports Server-Sent Events (SSE) for streaming responses.
    """
⋮----
class CancelTaskRequest(A2ABaseModel)
⋮----
"""
    Represents a JSON-RPC request for the `tasks/cancel` method.
    """
⋮----
method: Literal['tasks/cancel'] = 'tasks/cancel'
"""
    The method name. Must be 'tasks/cancel'.
    """
⋮----
"""
    The parameters identifying the task to cancel.
    """
⋮----
class FilePart(A2ABaseModel)
⋮----
"""
    Represents a file segment within a message or artifact. The file content can be
    provided either directly as bytes or as a URI.
    """
⋮----
file: FileWithBytes | FileWithUri
"""
    The file content, represented as either a URI or as base64-encoded bytes.
    """
kind: Literal['file'] = 'file'
"""
    The type of this part, used as a discriminator. Always 'file'.
    """
⋮----
class GetTaskPushNotificationConfigRequest(A2ABaseModel)
⋮----
"""
    Represents a JSON-RPC request for the `tasks/pushNotificationConfig/get` method.
    """
⋮----
method: Literal['tasks/pushNotificationConfig/get'] = (
"""
    The method name. Must be 'tasks/pushNotificationConfig/get'.
    """
params: TaskIdParams | GetTaskPushNotificationConfigParams
"""
    The parameters for getting a push notification configuration.
    """
⋮----
class GetTaskPushNotificationConfigSuccessResponse(A2ABaseModel)
⋮----
"""
    Represents a successful JSON-RPC response for the `tasks/pushNotificationConfig/get` method.
    """
⋮----
result: TaskPushNotificationConfig
"""
    The result, containing the requested push notification configuration.
    """
⋮----
class GetTaskRequest(A2ABaseModel)
⋮----
"""
    Represents a JSON-RPC request for the `tasks/get` method.
    """
⋮----
method: Literal['tasks/get'] = 'tasks/get'
"""
    The method name. Must be 'tasks/get'.
    """
params: TaskQueryParams
"""
    The parameters for querying a task.
    """
⋮----
class JSONRPCErrorResponse(A2ABaseModel)
⋮----
"""
    Represents a JSON-RPC 2.0 Error Response object.
    """
⋮----
error: (
"""
    An object describing the error that occurred.
    """
⋮----
class ListTaskPushNotificationConfigSuccessResponse(A2ABaseModel)
⋮----
"""
    Represents a successful JSON-RPC response for the `tasks/pushNotificationConfig/list` method.
    """
⋮----
result: list[TaskPushNotificationConfig]
"""
    The result, containing an array of all push notification configurations for the task.
    """
⋮----
class MessageSendConfiguration(A2ABaseModel)
⋮----
"""
    Defines configuration options for a `message/send` or `message/stream` request.
    """
⋮----
accepted_output_modes: list[str] | None = None
"""
    A list of output MIME types the client is prepared to accept in the response.
    """
blocking: bool | None = None
"""
    If true, the client will wait for the task to complete. The server may reject this if the task is long-running.
    """
⋮----
"""
    The number of most recent messages from the task's history to retrieve in the response.
    """
push_notification_config: PushNotificationConfig | None = None
"""
    Configuration for the agent to send push notifications for updates after the initial response.
    """
⋮----
class OAuthFlows(A2ABaseModel)
⋮----
"""
    Defines the configuration for the supported OAuth 2.0 flows.
    """
⋮----
authorization_code: AuthorizationCodeOAuthFlow | None = None
"""
    Configuration for the OAuth Authorization Code flow. Previously called accessCode in OpenAPI 2.0.
    """
client_credentials: ClientCredentialsOAuthFlow | None = None
"""
    Configuration for the OAuth Client Credentials flow. Previously called application in OpenAPI 2.0.
    """
implicit: ImplicitOAuthFlow | None = None
"""
    Configuration for the OAuth Implicit flow.
    """
password: PasswordOAuthFlow | None = None
"""
    Configuration for the OAuth Resource Owner Password flow.
    """
⋮----
class Part(RootModel[TextPart | FilePart | DataPart])
⋮----
root: TextPart | FilePart | DataPart
"""
    A discriminated union representing a part of a message or artifact, which can
    be text, a file, or structured data.
    """
⋮----
class SetTaskPushNotificationConfigRequest(A2ABaseModel)
⋮----
"""
    Represents a JSON-RPC request for the `tasks/pushNotificationConfig/set` method.
    """
⋮----
method: Literal['tasks/pushNotificationConfig/set'] = (
"""
    The method name. Must be 'tasks/pushNotificationConfig/set'.
    """
params: TaskPushNotificationConfig
"""
    The parameters for setting the push notification configuration.
    """
⋮----
class SetTaskPushNotificationConfigSuccessResponse(A2ABaseModel)
⋮----
"""
    Represents a successful JSON-RPC response for the `tasks/pushNotificationConfig/set` method.
    """
⋮----
"""
    The result, containing the configured push notification settings.
    """
⋮----
class Artifact(A2ABaseModel)
⋮----
"""
    Represents a file, data structure, or other resource generated by an agent during a task.
    """
⋮----
artifact_id: str
"""
    A unique identifier for the artifact within the scope of the task.
    """
⋮----
"""
    An optional, human-readable description of the artifact.
    """
extensions: list[str] | None = None
"""
    The URIs of extensions that are relevant to this artifact.
    """
⋮----
"""
    Optional metadata for extensions. The key is an extension-specific identifier.
    """
⋮----
"""
    An optional, human-readable name for the artifact.
    """
parts: list[Part]
"""
    An array of content parts that make up the artifact.
    """
⋮----
class DeleteTaskPushNotificationConfigResponse(
⋮----
root: JSONRPCErrorResponse | DeleteTaskPushNotificationConfigSuccessResponse
"""
    Represents a JSON-RPC response for the `tasks/pushNotificationConfig/delete` method.
    """
⋮----
class GetTaskPushNotificationConfigResponse(
⋮----
root: JSONRPCErrorResponse | GetTaskPushNotificationConfigSuccessResponse
"""
    Represents a JSON-RPC response for the `tasks/pushNotificationConfig/get` method.
    """
⋮----
class ListTaskPushNotificationConfigResponse(
⋮----
root: JSONRPCErrorResponse | ListTaskPushNotificationConfigSuccessResponse
"""
    Represents a JSON-RPC response for the `tasks/pushNotificationConfig/list` method.
    """
⋮----
class Message(A2ABaseModel)
⋮----
"""
    Represents a single message in the conversation between a user and an agent.
    """
⋮----
context_id: str | None = None
"""
    The context identifier for this message, used to group related interactions.
    """
⋮----
"""
    The URIs of extensions that are relevant to this message.
    """
kind: Literal['message'] = 'message'
"""
    The type of this object, used as a discriminator. Always 'message' for a Message.
    """
message_id: str
"""
    A unique identifier for the message, typically a UUID, generated by the sender.
    """
⋮----
"""
    An array of content parts that form the message body. A message can be
    composed of multiple parts of different types (e.g., text and files).
    """
reference_task_ids: list[str] | None = None
"""
    A list of other task IDs that this message references for additional context.
    """
role: Role
⋮----
task_id: str | None = None
"""
    The identifier of the task this message is part of. Can be omitted for the first message of a new task.
    """
⋮----
class MessageSendParams(A2ABaseModel)
⋮----
"""
    Defines the parameters for a request to send a message to an agent. This can be used
    to create a new task, continue an existing one, or restart a task.
    """
⋮----
configuration: MessageSendConfiguration | None = None
"""
    Optional configuration for the send request.
    """
message: Message
"""
    The message object being sent to the agent.
    """
⋮----
"""
    Optional metadata for extensions.
    """
⋮----
class OAuth2SecurityScheme(A2ABaseModel)
⋮----
"""
    Defines a security scheme using OAuth 2.0.
    """
⋮----
flows: OAuthFlows
"""
    An object containing configuration information for the supported OAuth 2.0 flows.
    """
oauth2_metadata_url: str | None = None
"""
    URL to the oauth2 authorization server metadata
    [RFC8414](https://datatracker.ietf.org/doc/html/rfc8414). TLS is required.
    """
type: Literal['oauth2'] = 'oauth2'
"""
    The type of the security scheme. Must be 'oauth2'.
    """
⋮----
class SecurityScheme(
⋮----
"""
    Defines a security scheme that can be used to secure an agent's endpoints.
    This is a discriminated union type based on the OpenAPI 3.0 Security Scheme Object.
    """
⋮----
class SendMessageRequest(A2ABaseModel)
⋮----
"""
    Represents a JSON-RPC request for the `message/send` method.
    """
⋮----
method: Literal['message/send'] = 'message/send'
"""
    The method name. Must be 'message/send'.
    """
params: MessageSendParams
"""
    The parameters for sending a message.
    """
⋮----
class SendStreamingMessageRequest(A2ABaseModel)
⋮----
"""
    Represents a JSON-RPC request for the `message/stream` method.
    """
⋮----
method: Literal['message/stream'] = 'message/stream'
"""
    The method name. Must be 'message/stream'.
    """
⋮----
class SetTaskPushNotificationConfigResponse(
⋮----
root: JSONRPCErrorResponse | SetTaskPushNotificationConfigSuccessResponse
"""
    Represents a JSON-RPC response for the `tasks/pushNotificationConfig/set` method.
    """
⋮----
class TaskArtifactUpdateEvent(A2ABaseModel)
⋮----
"""
    An event sent by the agent to notify the client that an artifact has been
    generated or updated. This is typically used in streaming models.
    """
⋮----
append: bool | None = None
"""
    If true, the content of this artifact should be appended to a previously sent artifact with the same ID.
    """
artifact: Artifact
"""
    The artifact that was generated or updated.
    """
context_id: str
"""
    The context ID associated with the task.
    """
kind: Literal['artifact-update'] = 'artifact-update'
"""
    The type of this event, used as a discriminator. Always 'artifact-update'.
    """
last_chunk: bool | None = None
"""
    If true, this is the final chunk of the artifact.
    """
⋮----
"""
    The ID of the task this artifact belongs to.
    """
⋮----
class TaskStatus(A2ABaseModel)
⋮----
"""
    Represents the status of a task at a specific point in time.
    """
⋮----
message: Message | None = None
"""
    An optional, human-readable message providing more details about the current status.
    """
state: TaskState
"""
    The current state of the task's lifecycle.
    """
timestamp: str | None = Field(
"""
    An ISO 8601 datetime string indicating when this status was recorded.
    """
⋮----
class TaskStatusUpdateEvent(A2ABaseModel)
⋮----
"""
    An event sent by the agent to notify the client of a change in a task's status.
    This is typically used in streaming or subscription models.
    """
⋮----
final: bool
"""
    If true, this is the final event in the stream for this interaction.
    """
kind: Literal['status-update'] = 'status-update'
"""
    The type of this event, used as a discriminator. Always 'status-update'.
    """
⋮----
status: TaskStatus
"""
    The new status of the task.
    """
⋮----
"""
    The ID of the task that was updated.
    """
⋮----
class A2ARequest(
⋮----
"""
    A discriminated union representing all possible JSON-RPC 2.0 requests supported by the A2A specification.
    """
⋮----
class AgentCard(A2ABaseModel)
⋮----
"""
    The AgentCard is a self-describing manifest for an agent. It provides essential
    metadata including the agent's identity, capabilities, skills, supported
    communication methods, and security requirements.
    """
⋮----
additional_interfaces: list[AgentInterface] | None = None
"""
    A list of additional supported interfaces (transport and URL combinations).
    This allows agents to expose multiple transports, potentially at different URLs.

    Best practices:
    - SHOULD include all supported transports for completeness
    - SHOULD include an entry matching the main 'url' and 'preferredTransport'
    - MAY reuse URLs if multiple transports are available at the same endpoint
    - MUST accurately declare the transport available at each URL

    Clients can select any interface from this list based on their transport capabilities
    and preferences. This enables transport negotiation and fallback scenarios.
    """
capabilities: AgentCapabilities
"""
    A declaration of optional capabilities supported by the agent.
    """
default_input_modes: list[str]
"""
    Default set of supported input MIME types for all skills, which can be
    overridden on a per-skill basis.
    """
default_output_modes: list[str]
"""
    Default set of supported output MIME types for all skills, which can be
    overridden on a per-skill basis.
    """
description: str = Field(
"""
    A human-readable description of the agent, assisting users and other agents
    in understanding its purpose.
    """
documentation_url: str | None = None
"""
    An optional URL to the agent's documentation.
    """
icon_url: str | None = None
"""
    An optional URL to an icon for the agent.
    """
name: str = Field(..., examples=['Recipe Agent'])
"""
    A human-readable name for the agent.
    """
preferred_transport: str | None = Field(
"""
    The transport protocol for the preferred endpoint (the main 'url' field).
    If not specified, defaults to 'JSONRPC'.

    IMPORTANT: The transport specified here MUST be available at the main 'url'.
    This creates a binding between the main URL and its supported transport protocol.
    Clients should prefer this transport and URL combination when both are supported.
    """
protocol_version: str | None = '0.3.0'
"""
    The version of the A2A protocol this agent supports.
    """
provider: AgentProvider | None = None
"""
    Information about the agent's service provider.
    """
⋮----
"""
    A list of security requirement objects that apply to all agent interactions. Each object
    lists security schemes that can be used. Follows the OpenAPI 3.0 Security Requirement Object.
    This list can be seen as an OR of ANDs. Each object in the list describes one possible
    set of security requirements that must be present on a request. This allows specifying,
    for example, "callers must either use OAuth OR an API Key AND mTLS."
    """
security_schemes: dict[str, SecurityScheme] | None = None
"""
    A declaration of the security schemes available to authorize requests. The key is the
    scheme name. Follows the OpenAPI 3.0 Security Scheme Object.
    """
signatures: list[AgentCardSignature] | None = None
"""
    JSON Web Signatures computed for this AgentCard.
    """
skills: list[AgentSkill]
"""
    The set of skills, or distinct capabilities, that the agent can perform.
    """
supports_authenticated_extended_card: bool | None = None
"""
    If true, the agent can provide an extended agent card with additional details
    to authenticated users. Defaults to false.
    """
url: str = Field(..., examples=['https://api.example.com/a2a/v1'])
"""
    The preferred endpoint URL for interacting with the agent.
    This URL MUST support the transport specified by 'preferredTransport'.
    """
version: str = Field(..., examples=['1.0.0'])
"""
    The agent's own version number. The format is defined by the provider.
    """
⋮----
class GetAuthenticatedExtendedCardSuccessResponse(A2ABaseModel)
⋮----
"""
    Represents a successful JSON-RPC response for the `agent/getAuthenticatedExtendedCard` method.
    """
⋮----
result: AgentCard
"""
    The result is an Agent Card object.
    """
⋮----
class Task(A2ABaseModel)
⋮----
"""
    Represents a single, stateful operation or conversation between a client and an agent.
    """
⋮----
artifacts: list[Artifact] | None = None
"""
    A collection of artifacts generated by the agent during the execution of the task.
    """
⋮----
"""
    A server-generated identifier for maintaining context across multiple related tasks or interactions.
    """
history: list[Message] | None = None
"""
    An array of messages exchanged during the task, representing the conversation history.
    """
⋮----
"""
    A unique identifier for the task, generated by the server for a new task.
    """
kind: Literal['task'] = 'task'
"""
    The type of this object, used as a discriminator. Always 'task' for a Task.
    """
⋮----
"""
    The current status of the task, including its state and a descriptive message.
    """
⋮----
class CancelTaskSuccessResponse(A2ABaseModel)
⋮----
"""
    Represents a successful JSON-RPC response for the `tasks/cancel` method.
    """
⋮----
result: Task
"""
    The result, containing the final state of the canceled Task object.
    """
⋮----
class GetAuthenticatedExtendedCardResponse(
⋮----
root: JSONRPCErrorResponse | GetAuthenticatedExtendedCardSuccessResponse
"""
    Represents a JSON-RPC response for the `agent/getAuthenticatedExtendedCard` method.
    """
⋮----
class GetTaskSuccessResponse(A2ABaseModel)
⋮----
"""
    Represents a successful JSON-RPC response for the `tasks/get` method.
    """
⋮----
"""
    The result, containing the requested Task object.
    """
⋮----
class SendMessageSuccessResponse(A2ABaseModel)
⋮----
"""
    Represents a successful JSON-RPC response for the `message/send` method.
    """
⋮----
result: Task | Message
"""
    The result, which can be a direct reply Message or the initial Task object.
    """
⋮----
class SendStreamingMessageSuccessResponse(A2ABaseModel)
⋮----
"""
    Represents a successful JSON-RPC response for the `message/stream` method.
    The server may send multiple response objects for a single request.
    """
⋮----
result: Task | Message | TaskStatusUpdateEvent | TaskArtifactUpdateEvent
"""
    The result, which can be a Message, Task, or a streaming update event.
    """
⋮----
class CancelTaskResponse(
⋮----
root: JSONRPCErrorResponse | CancelTaskSuccessResponse
"""
    Represents a JSON-RPC response for the `tasks/cancel` method.
    """
⋮----
class GetTaskResponse(RootModel[JSONRPCErrorResponse | GetTaskSuccessResponse])
⋮----
root: JSONRPCErrorResponse | GetTaskSuccessResponse
"""
    Represents a JSON-RPC response for the `tasks/get` method.
    """
⋮----
class JSONRPCResponse(
⋮----
"""
    A discriminated union representing all possible JSON-RPC 2.0 responses
    for the A2A specification methods.
    """
⋮----
class SendMessageResponse(
⋮----
root: JSONRPCErrorResponse | SendMessageSuccessResponse
"""
    Represents a JSON-RPC response for the `message/send` method.
    """
⋮----
class SendStreamingMessageResponse(
⋮----
root: JSONRPCErrorResponse | SendStreamingMessageSuccessResponse
"""
    Represents a JSON-RPC response for the `message/stream` method.
    """




================================================================
End of Codebase
================================================================
