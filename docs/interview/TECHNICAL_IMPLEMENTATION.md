# MCP ì„œë²„ ê¸°ìˆ  êµ¬í˜„ ìƒì„¸

## ğŸ—ï¸ **ì•„í‚¤í…ì²˜ ì„¤ê³„**

### **1. ì „ì²´ ì‹œìŠ¤í…œ êµ¬ì¡°**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    AI MCP A2A ì‹œìŠ¤í…œ                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”‚
â”‚  â”‚   ê±°ì‹œê²½ì œ   â”‚  â”‚   ì£¼ì‹ë¶„ì„   â”‚  â”‚  ì½˜í…ì¸ ìˆ˜ì§‘  â”‚        â”‚
â”‚  â”‚   MCPì„œë²„   â”‚  â”‚   MCPì„œë²„   â”‚  â”‚   MCPì„œë²„   â”‚        â”‚
â”‚  â”‚   (8001)    â”‚  â”‚   (8002)    â”‚  â”‚   (8003)    â”‚        â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â”‚
â”‚                                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”‚
â”‚  â”‚    ê²€ìƒ‰     â”‚  â”‚   ì¬ë¬´ë¶„ì„   â”‚  â”‚   í‚¤ì›€API   â”‚        â”‚
â”‚  â”‚   MCPì„œë²„   â”‚  â”‚   MCPì„œë²„   â”‚  â”‚   MCPì„œë²„   â”‚        â”‚
â”‚  â”‚   (8004)    â”‚  â”‚   (8005)    â”‚  â”‚   (8006)    â”‚        â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### **2. ê° MCP ì„œë²„ì˜ ë…ë¦½ì  ì„¤ê³„**

- **í¬íŠ¸ ë¶„ë¦¬**: ê° ì„œë²„ê°€ ê³ ìœ í•œ í¬íŠ¸ì—ì„œ ë™ì‘
- **ë…ë¦½ì  ì‹¤í–‰**: ê°œë³„ì ìœ¼ë¡œ ì‹œì‘/ì¤‘ì§€ ê°€ëŠ¥
- **ëª¨ë“ˆí™”**: ê³µí†µ ê¸°ëŠ¥ì€ ë³„ë„ ëª¨ë“ˆë¡œ ë¶„ë¦¬

## ğŸ”§ **í•µì‹¬ ê¸°ìˆ  êµ¬í˜„**

### **1. FastMCP í”„ë ˆì„ì›Œí¬ í™œìš©**

#### **ì„œë²„ ì´ˆê¸°í™”**

```python
from fastmcp import FastMCP

class MacroeconomicServer:
    def __init__(self, port: int = 8001):
        self.port = port
        self.fastmcp = FastMCP(
            name="macroeconomic_processor",
            description="ê±°ì‹œê²½ì œ ë°ì´í„° ì²˜ë¦¬ ì‹œìŠ¤í…œ",
            instructions="""
            ì´ ì„œë²„ëŠ” ê±°ì‹œê²½ì œ ë°ì´í„°ë¥¼ ì²˜ë¦¬í•˜ê³  ë¶„ì„í•©ë‹ˆë‹¤.
            GDP, ì¸í”Œë ˆì´ì…˜, ê³ ìš©ë¥  ë“±ì˜ ê²½ì œ ì§€í‘œë¥¼ ì œê³µí•©ë‹ˆë‹¤.
            """
        )
        self._register_tools()
```

#### **ë„êµ¬ ë“±ë¡ íŒ¨í„´**

```python
def _register_tools(self):
    @self.fastmcp.tool()
    async def get_gdp_data(params: dict) -> dict:
        """GDP ë°ì´í„° ì¡°íšŒ ë° ë¶„ì„"""
        try:
            result = await self.client.get_gdp_data(params)
            return {
                "success": True,
                "data": result,
                "message": "GDP ë°ì´í„° ì¡°íšŒ ì™„ë£Œ"
            }
        except Exception as e:
            return {
                "success": False,
                "error": str(e),
                "message": "GDP ë°ì´í„° ì¡°íšŒ ì‹¤íŒ¨"
            }
```

### **2. ë¹„ë™ê¸° í”„ë¡œê·¸ë˜ë° íŒ¨í„´**

#### **ë¹„ë™ê¸° HTTP í´ë¼ì´ì–¸íŠ¸**

```python
import httpx
import asyncio

class DataClient:
    def __init__(self):
        self._client = None
        self.timeout = 30.0

    async def _ensure_client(self):
        """HTTP í´ë¼ì´ì–¸íŠ¸ ìƒì„± ë³´ì¥"""
        if self._client is None:
            self._client = httpx.AsyncClient(
                timeout=self.timeout,
                headers={"User-Agent": "AI-MCP-System/1.0"}
            )

    async def get_data(self, url: str, params: dict = None) -> dict:
        """ë¹„ë™ê¸° ë°ì´í„° ì¡°íšŒ"""
        await self._ensure_client()
        try:
            response = await self._client.get(url, params=params)
            response.raise_for_status()
            return response.json()
        except httpx.HTTPStatusError as e:
            raise DataFetchError(f"HTTP ì˜¤ë¥˜: {e.response.status_code}") from e
        except httpx.RequestError as e:
            raise DataFetchError(f"ìš”ì²­ ì˜¤ë¥˜: {e}") from e
```

#### **ë¹„ë™ê¸° ë°°ì¹˜ ì²˜ë¦¬**

```python
async def process_batch(self, items: list, batch_size: int = 100) -> list:
    """ë°°ì¹˜ ë‹¨ìœ„ ë¹„ë™ê¸° ì²˜ë¦¬"""
    results = []

    for i in range(0, len(items), batch_size):
        batch = items[i:i + batch_size]

        # ë°°ì¹˜ ë‹¨ìœ„ë¡œ ë™ì‹œ ì²˜ë¦¬
        batch_tasks = [self._process_item(item) for item in batch]
        batch_results = await asyncio.gather(*batch_tasks, return_exceptions=True)

        # ì„±ê³µí•œ ê²°ê³¼ë§Œ ìˆ˜ì§‘
        for result in batch_results:
            if not isinstance(result, Exception):
                results.append(result)

        self.logger.info(f"ë°°ì¹˜ ì²˜ë¦¬ ì§„í–‰ë¥ : {min(i + batch_size, len(items))}/{len(items)}")

    return results
```

### **3. ì¬ì‹œë„ ë° ì—ëŸ¬ ì²˜ë¦¬**

#### **ì§€ìˆ˜ ë°±ì˜¤í”„ ì¬ì‹œë„**

```python
async def _retry_with_backoff(self, func, *args, max_retries: int = 3, **kwargs):
    """ì§€ìˆ˜ ë°±ì˜¤í”„ë¥¼ ì‚¬ìš©í•œ ì¬ì‹œë„ ë¡œì§"""
    for attempt in range(max_retries):
        try:
            return await func(*args, **kwargs)
        except Exception as e:
            if attempt == max_retries - 1:
                raise RetryExhaustedError(f"ìµœëŒ€ ì¬ì‹œë„ íšŸìˆ˜ ì´ˆê³¼: {e}") from e

            # ì§€ìˆ˜ ë°±ì˜¤í”„: 1ì´ˆ, 2ì´ˆ, 4ì´ˆ...
            delay = self.retry_delay * (2 ** attempt)
            self.logger.warning(
                f"ì¬ì‹œë„ {attempt + 1}/{max_retries}, "
                f"{delay}ì´ˆ í›„ ì¬ì‹œë„: {e}"
            )
            await asyncio.sleep(delay)
```

#### **ì»¤ìŠ¤í…€ ì˜ˆì™¸ í´ë˜ìŠ¤**

```python
class DataProcessingError(Exception):
    """ë°ì´í„° ì²˜ë¦¬ ì „ìš© ì˜ˆì™¸"""
    def __init__(self, message: str, error_code: str = None, details: dict = None):
        super().__init__(message)
        self.error_code = error_code
        self.details = details or {}

    def to_dict(self) -> dict:
        """ì˜ˆì™¸ë¥¼ ë”•ì…”ë„ˆë¦¬ë¡œ ë³€í™˜"""
        return {
            "error": str(self),
            "error_code": self.error_code,
            "details": self.details,
            "timestamp": datetime.now().isoformat()
        }

class ValidationError(DataProcessingError):
    """ë°ì´í„° ê²€ì¦ ì˜¤ë¥˜"""
    pass

class APIError(DataProcessingError):
    """API í˜¸ì¶œ ì˜¤ë¥˜"""
    pass
```

### **4. ìºì‹± ì‹œìŠ¤í…œ**

#### **ë©”ëª¨ë¦¬ ê¸°ë°˜ ìºì‹±**

```python
import hashlib
from datetime import datetime, timedelta

class CacheManager:
    def __init__(self, default_ttl: int = 300):
        self._cache = {}
        self._timestamps = {}
        self.default_ttl = default_ttl

    def _generate_key(self, operation: str, params: dict) -> str:
        """ìºì‹œ í‚¤ ìƒì„± (MD5 í•´ì‹œ)"""
        key_data = f"{operation}:{str(sorted(params.items()))}"
        return hashlib.md5(key_data.encode()).hexdigest()

    def get(self, operation: str, params: dict):
        """ìºì‹œì—ì„œ ë°ì´í„° ì¡°íšŒ"""
        cache_key = self._generate_key(operation, params)

        if cache_key in self._cache:
            if self._is_valid(cache_key):
                self.logger.info(f"ìºì‹œ íˆíŠ¸: {operation}")
                return self._cache[cache_key]
            else:
                # ë§Œë£Œëœ ìºì‹œ ì œê±°
                del self._cache[cache_key]
                del self._timestamps[cache_key]

        return None

    def set(self, operation: str, params: dict, data: any, ttl: int = None):
        """ìºì‹œì— ë°ì´í„° ì €ì¥"""
        cache_key = self._generate_key(operation, params)
        ttl = ttl or self.default_ttl

        self._cache[cache_key] = data
        self._timestamps[cache_key] = datetime.now()

        self.logger.info(f"ìºì‹œ ì—…ë°ì´íŠ¸: {operation}, TTL: {ttl}ì´ˆ")

    def _is_valid(self, cache_key: str) -> bool:
        """ìºì‹œ ìœ íš¨ì„± ê²€ì‚¬"""
        if cache_key not in self._timestamps:
            return False

        age = datetime.now() - self._timestamps[cache_key]
        return age.total_seconds() < self.default_ttl
```

### **5. ë°ì´í„° ê²€ì¦ ë° ë³€í™˜**

#### **Pydantic ëª¨ë¸ í™œìš©**

```python
from pydantic import BaseModel, Field, validator
from typing import List, Optional

class GDPData(BaseModel):
    country: str = Field(..., description="êµ­ê°€ ì½”ë“œ")
    year: int = Field(..., ge=1900, le=2100, description="ì—°ë„")
    gdp_value: float = Field(..., gt=0, description="GDP ê°’")
    currency: str = Field(default="USD", description="í†µí™”")

    @validator('country')
    def validate_country(cls, v):
        valid_countries = ['KOR', 'USA', 'JPN', 'CHN']
        if v not in valid_countries:
            raise ValueError(f"ì§€ì›í•˜ì§€ ì•ŠëŠ” êµ­ê°€: {v}")
        return v

    @validator('gdp_value')
    def validate_gdp(cls, v):
        if v <= 0:
            raise ValueError("GDPëŠ” 0ë³´ë‹¤ ì»¤ì•¼ í•©ë‹ˆë‹¤")
        return v

class GDPRequest(BaseModel):
    country: str
    start_year: int = Field(..., ge=1900, le=2100)
    end_year: int = Field(..., ge=1900, le=2100)

    @validator('end_year')
    def validate_year_range(cls, v, values):
        if 'start_year' in values and v < values['start_year']:
            raise ValueError("ì¢…ë£Œ ì—°ë„ëŠ” ì‹œì‘ ì—°ë„ë³´ë‹¤ ì»¤ì•¼ í•©ë‹ˆë‹¤")
        return v
```

#### **ë°ì´í„° ë³€í™˜ ë° ì •ê·œí™”**

```python
class DataTransformer:
    @staticmethod
    def normalize_gdp_data(raw_data: dict) -> GDPData:
        """ì›ì‹œ ë°ì´í„°ë¥¼ ì •ê·œí™”ëœ í˜•íƒœë¡œ ë³€í™˜"""
        try:
            return GDPData(
                country=raw_data.get('country_code', 'KOR'),
                year=int(raw_data.get('year', 2024)),
                gdp_value=float(raw_data.get('gdp', 0)),
                currency=raw_data.get('currency', 'USD')
            )
        except (ValueError, TypeError) as e:
            raise DataTransformationError(f"GDP ë°ì´í„° ë³€í™˜ ì‹¤íŒ¨: {e}") from e

    @staticmethod
    def convert_currency(amount: float, from_currency: str, to_currency: str) -> float:
        """í†µí™” ë³€í™˜ (ê°„ë‹¨í•œ ì˜ˆì‹œ)"""
        # ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” ì™¸ë¶€ í™˜ìœ¨ API ì‚¬ìš©
        exchange_rates = {
            'USD': 1.0,
            'KRW': 1300.0,
            'JPY': 150.0,
            'CNY': 7.2
        }

        if from_currency not in exchange_rates or to_currency not in exchange_rates:
            raise ValueError(f"ì§€ì›í•˜ì§€ ì•ŠëŠ” í†µí™”: {from_currency} -> {to_currency}")

        usd_amount = amount / exchange_rates[from_currency]
        return usd_amount * exchange_rates[to_currency]
```

## ğŸ“Š **ì„±ëŠ¥ ìµœì í™” ê¸°ë²•**

### **1. ì—°ê²° í’€ë§**

```python
class ConnectionPool:
    def __init__(self, max_connections: int = 10):
        self.max_connections = max_connections
        self._connections = []
        self._semaphore = asyncio.Semaphore(max_connections)

    async def get_connection(self):
        """ì—°ê²° íšë“"""
        await self._semaphore.acquire()
        if self._connections:
            return self._connections.pop()
        return await self._create_connection()

    async def return_connection(self, connection):
        """ì—°ê²° ë°˜í™˜"""
        if len(self._connections) < self.max_connections:
            self._connections.append(connection)
        else:
            await self._close_connection(connection)
        self._semaphore.release()
```

### **2. ë©”ëª¨ë¦¬ ê´€ë¦¬**

```python
import gc
import psutil
import os

class MemoryManager:
    def __init__(self, memory_threshold: float = 0.8):
        self.memory_threshold = memory_threshold

    def check_memory_usage(self) -> bool:
        """ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ í™•ì¸"""
        process = psutil.Process(os.getpid())
        memory_percent = process.memory_percent()

        if memory_percent > self.memory_threshold * 100:
            self.logger.warning(f"ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ë†’ìŒ: {memory_percent:.1f}%")
            return False
        return True

    def cleanup_memory(self):
        """ë©”ëª¨ë¦¬ ì •ë¦¬"""
        # ê°€ë¹„ì§€ ì»¬ë ‰ì…˜ ì‹¤í–‰
        collected = gc.collect()
        self.logger.info(f"ê°€ë¹„ì§€ ì»¬ë ‰ì…˜ ì™„ë£Œ: {collected}ê°œ ê°ì²´ ì •ë¦¬")

        # ìºì‹œ í¬ê¸° ì¡°ì •
        if hasattr(self, '_cache'):
            cache_size = len(self._cache)
            if cache_size > 1000:
                # ì˜¤ë˜ëœ ìºì‹œ í•­ëª© ì œê±°
                self._cleanup_old_cache()
```

## ğŸ§ª **í…ŒìŠ¤íŠ¸ ì „ëµ**

### **1. ë‹¨ìœ„ í…ŒìŠ¤íŠ¸**

```python
import pytest
from unittest.mock import AsyncMock, patch

class TestDataProcessor:
    @pytest.fixture
    def processor(self):
        return DataProcessor()

    @pytest.mark.asyncio
    async def test_data_fetch_success(self, processor):
        """ë°ì´í„° ì¡°íšŒ ì„±ê³µ í…ŒìŠ¤íŠ¸"""
        with patch.object(processor.client, 'fetch_data') as mock_fetch:
            mock_fetch.return_value = {"gdp": 1000000, "year": 2024}

            result = await processor.get_gdp_data({"country": "KOR"})

            assert result["success"] is True
            assert result["data"]["gdp"] == 1000000
            mock_fetch.assert_called_once()

    @pytest.mark.asyncio
    async def test_data_fetch_failure(self, processor):
        """ë°ì´í„° ì¡°íšŒ ì‹¤íŒ¨ í…ŒìŠ¤íŠ¸"""
        with patch.object(processor.client, 'fetch_data') as mock_fetch:
            mock_fetch.side_effect = Exception("API ì˜¤ë¥˜")

            result = await processor.get_gdp_data({"country": "KOR"})

            assert result["success"] is False
            assert "API ì˜¤ë¥˜" in result["error"]
```

### **2. í†µí•© í…ŒìŠ¤íŠ¸**

```python
class TestIntegration:
    @pytest.mark.asyncio
    async def test_full_data_pipeline(self):
        """ì „ì²´ ë°ì´í„° íŒŒì´í”„ë¼ì¸ í…ŒìŠ¤íŠ¸"""
        # 1. ë°ì´í„° ì¡°íšŒ
        raw_data = await self.fetch_raw_data()
        assert raw_data is not None

        # 2. ë°ì´í„° ê²€ì¦
        validated_data = self.validate_data(raw_data)
        assert validated_data is not None

        # 3. ë°ì´í„° ë³€í™˜
        transformed_data = self.transform_data(validated_data)
        assert transformed_data is not None

        # 4. ê²°ê³¼ ì €ì¥
        saved_result = await self.save_data(transformed_data)
        assert saved_result["success"] is True
```

## ğŸ” **ëª¨ë‹ˆí„°ë§ ë° ë¡œê¹…**

### **1. êµ¬ì¡°í™”ëœ ë¡œê¹…**

```python
import logging
import json
from datetime import datetime

class StructuredLogger:
    def __init__(self, name: str):
        self.logger = logging.getLogger(name)
        self._setup_logging()

    def _setup_logging(self):
        """ë¡œê¹… ì„¤ì •"""
        formatter = logging.Formatter(
            '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
        )

        handler = logging.StreamHandler()
        handler.setFormatter(formatter)

        self.logger.addHandler(handler)
        self.logger.setLevel(logging.INFO)

    def log_operation(self, operation: str, params: dict, result: dict, duration: float):
        """ì‘ì—… ë¡œê·¸ ê¸°ë¡"""
        log_data = {
            "operation": operation,
            "params": params,
            "result": result,
            "duration_ms": round(duration * 1000, 2),
            "timestamp": datetime.now().isoformat()
        }

        if result.get("success"):
            self.logger.info(f"ì‘ì—… ì„±ê³µ: {json.dumps(log_data, ensure_ascii=False)}")
        else:
            self.logger.error(f"ì‘ì—… ì‹¤íŒ¨: {json.dumps(log_data, ensure_ascii=False)}")
```

### **2. ì„±ëŠ¥ ë©”íŠ¸ë¦­**

```python
import time
from functools import wraps

def measure_performance(func):
    """ì„±ëŠ¥ ì¸¡ì • ë°ì½”ë ˆì´í„°"""
    @wraps(func)
    async def wrapper(*args, **kwargs):
        start_time = time.time()

        try:
            result = await func(*args, **kwargs)
            duration = time.time() - start_time

            # ì„±ê³µ ë©”íŠ¸ë¦­ ê¸°ë¡
            if hasattr(args[0], 'logger'):
                args[0].logger.info(
                    f"í•¨ìˆ˜ {func.__name__} ì‹¤í–‰ ì™„ë£Œ: {duration:.3f}ì´ˆ"
                )

            return result

        except Exception as e:
            duration = time.time() - start_time

            # ì‹¤íŒ¨ ë©”íŠ¸ë¦­ ê¸°ë¡
            if hasattr(args[0], 'logger'):
                args[0].logger.error(
                    f"í•¨ìˆ˜ {func.__name__} ì‹¤í–‰ ì‹¤íŒ¨: {duration:.3f}ì´ˆ, ì—ëŸ¬: {e}"
                )
            raise

    return wrapper
```

---

**ì´ ë¬¸ì„œëŠ” MCP ì„œë²„ êµ¬í˜„ì˜ ê¸°ìˆ ì  ì„¸ë¶€ì‚¬í•­ì„ ìƒì„¸íˆ ì„¤ëª…í•©ë‹ˆë‹¤. ê° ê¸°ìˆ ì˜ êµ¬í˜„ ë°©ë²•ê³¼ ì‹¤ì œ ì½”ë“œ ì˜ˆì‹œë¥¼ í†µí•´ ê°œë°œ ì—­ëŸ‰ì„ ì–´í•„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.** ğŸš€
