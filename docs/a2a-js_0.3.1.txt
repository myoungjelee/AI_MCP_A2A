This file is a merged representation of the entire codebase, combined into a single document by Repomix.
The content has been processed where content has been compressed (code blocks are separated by ‚ãÆ---- delimiter), security check has been disabled.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Content has been compressed - code blocks are separated by ‚ãÆ---- delimiter
- Security check has been disabled - content may contain sensitive information
- Files are sorted by Git change count (files with more changes are at the bottom)


================================================================
Directory Structure
================================================================
.github/
  ISSUE_TEMPLATE/
    bug-report.yml
    feature-request.yml
  workflows/
    conventional-commits.yml
    npm-publish.yml
    release-please.yml
    unit-tests.yml
  CODEOWNERS
  PULL_REQUEST_TEMPLATE.md
scripts/
  generateTypes.js
src/
  client/
    client.ts
    index.ts
  samples/
    agents/
      movie-agent/
        genkit.ts
        index.ts
        movie_agent.prompt
        README.md
        tmdb.ts
        tools.ts
    cli.ts
  server/
    agent_execution/
      agent_executor.ts
      request_context.ts
    events/
      execution_event_bus_manager.ts
      execution_event_bus.ts
      execution_event_queue.ts
    express/
      a2a_express_app.ts
      index.ts
    request_handler/
      a2a_request_handler.ts
      default_request_handler.ts
    transports/
      jsonrpc_transport_handler.ts
    error.ts
    index.ts
    result_manager.ts
    store.ts
    utils.ts
  a2a_response.ts
  constants.ts
  index.ts
  types.ts
test/
  server/
    default_request_handler.spec.ts
.gitignore
CHANGELOG.md
CODE_OF_CONDUCT.md
CONTRIBUTING.md
LICENSE
package.json
README.md
SECURITY.md
tsconfig.json
tsup.config.ts

================================================================
Files
================================================================

================
File: .github/ISSUE_TEMPLATE/bug-report.yml
================
name: üêû Bug Report
description: File a bug report
title: "[Bug]: "
type: "Bug"
body:
  - type: markdown
    attributes:
      value: |
        Thanks for stopping by to let us know something could be better!
        Private Feedback? Please use this [Google form](https://goo.gle/a2a-feedback)
  - type: textarea
    id: what-happened
    attributes:
      label: What happened?
      description: Also tell us what you expected to happen and how to reproduce the issue.
      placeholder: Tell us what you see!
      value: "A bug happened!"
    validations:
      required: true
  - type: textarea
    id: logs
    attributes:
      label: Relevant log output
      description: Please copy and paste any relevant log output. This will be automatically formatted into code, so no need for backticks.
      render: shell
  - type: checkboxes
    id: terms
    attributes:
      label: Code of Conduct
      description: By submitting this issue, you agree to follow our [Code of Conduct](https://github.com/google-a2a/A2A?tab=coc-ov-file#readme)
      options:
        - label: I agree to follow this project's Code of Conduct
          required: true

================
File: .github/ISSUE_TEMPLATE/feature-request.yml
================
name: üí° Feature Request
description: Suggest an idea for this repository
title: "[Feat]: "
type: "Feature"
body:
  - type: markdown
    attributes:
      value: |
        Thanks for stopping by to let us know something could be better!
        Private Feedback? Please use this [Google form](https://goo.gle/a2a-feedback)
  - type: textarea
    id: problem
    attributes:
      label: Is your feature request related to a problem? Please describe.
      description: A clear and concise description of what the problem is.
      placeholder: Ex. I'm always frustrated when [...]
  - type: textarea
    id: describe
    attributes:
      label: Describe the solution you'd like
      description: A clear and concise description of what you want to happen.
    validations:
      required: true
  - type: textarea
    id: alternatives
    attributes:
      label: Describe alternatives you've considered
      description: A clear and concise description of any alternative solutions or features you've considered.
  - type: textarea
    id: context
    attributes:
      label: Additional context
      description: Add any other context or screenshots about the feature request here.
  - type: checkboxes
    id: terms
    attributes:
      label: Code of Conduct
      description: By submitting this issue, you agree to follow our [Code of Conduct](https://github.com/google-a2a/A2A?tab=coc-ov-file#readme)
      options:
        - label: I agree to follow this project's Code of Conduct
          required: true

================
File: .github/workflows/conventional-commits.yml
================
name: "Conventional Commits"

on:
  pull_request:
    types:
      - opened
      - edited
      - synchronize

permissions:
  contents: read

jobs:
  main:
    permissions:
      pull-requests: read
      statuses: write
    name: Validate PR Title
    runs-on: ubuntu-latest
    steps:
      - name: semantic-pull-request
        uses: amannn/action-semantic-pull-request@v5.5.3
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          validateSingleCommit: false

================
File: .github/workflows/npm-publish.yml
================
# This workflow will run tests using node and then publish a package to GitHub Packages when a release is created
# For more information see: https://docs.github.com/en/actions/publishing-packages/publishing-nodejs-packages

name: Publish to NPM

on:
  release:
    types: [created]

jobs:
  publish-npm:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: 18
          registry-url: 'https://registry.npmjs.org'
      - run: npm ci
      - run: npm run build
      
      # Now configure with the publish service for install.
      - uses: actions/setup-node@v4
        with:
          node-version: 18
          registry-url: 'https://wombat-dressing-room.appspot.com/'
      - run: npm publish --provenance --access public
        env:
          NODE_AUTH_TOKEN: ${{secrets.NPM_TOKEN}}

================
File: .github/workflows/release-please.yml
================
on:
  push:
    branches:
      - main

permissions:
  contents: write
  pull-requests: write

name: release-please

jobs:
  release-please:
    runs-on: ubuntu-latest
    steps:
      - uses: googleapis/release-please-action@v4
        with:
          token: ${{ secrets.A2A_BOT_PAT }}
          release-type: node

================
File: .github/workflows/unit-tests.yml
================
# This workflow will do a clean installation of node dependencies, cache/restore them, build the source code and run tests across different versions of node
# For more information see: https://docs.github.com/en/actions/automating-builds-and-tests/building-and-testing-nodejs

name: Run Unit Tests

on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]

jobs:
  test:

    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v4
    - uses: actions/setup-node@v4
      with:
        node-version: 18
        registry-url: 'https://registry.npmjs.org'
        cache: 'npm'
    - run: npm ci
    - run: npm test

================
File: .github/CODEOWNERS
================
# Code owners file.
# This file controls who is tagged for review for any given pull request.
#
# For syntax help see:
# https://help.github.com/en/github/creating-cloning-and-archiving-repositories/about-code-owners#codeowners-syntax

*   @google-a2a/googlers

================
File: .github/PULL_REQUEST_TEMPLATE.md
================
# Description

Thank you for opening a Pull Request!
Before submitting your PR, there are a few things you can do to make sure it goes smoothly:

- [ ] Follow the [`CONTRIBUTING` Guide](https://github.com/google-a2a/a2a-js/blob/main/CONTRIBUTING.md).
- [ ] Make your Pull Request title in the <https://www.conventionalcommits.org/> specification.
  - Important Prefixes for [release-please](https://github.com/googleapis/release-please):
    - `fix:` which represents bug fixes, and correlates to a [SemVer](https://semver.org/) patch.
    - `feat:` represents a new feature, and correlates to a SemVer minor.
    - `feat!:`, or `fix!:`, `refactor!:`, etc., which represent a breaking change (indicated by the `!`) and will result in a SemVer major.
- [ ] Ensure the tests and linter pass
- [ ] Appropriate docs were updated (if necessary)

Fixes #<issue_number_goes_here> ü¶ï

================
File: scripts/generateTypes.js
================
const typeSchemaContents = fs.readFileSync(path.join(process.cwd(), 'spec.json'), 'utf8');
const typeSchema = JSON.parse(typeSchemaContents.toString());
‚ãÆ----
compile(typeSchema, 'MySchema', {
‚ãÆ----
.then(ts => fs.writeFileSync('src/types.ts', ts))

================
File: src/client/client.ts
================
import {
  AgentCard,
  AgentCapabilities,
  JSONRPCRequest,
  JSONRPCResponse,
  JSONRPCSuccessResponse,
  JSONRPCError,
  JSONRPCErrorResponse,
  Message,
  Task,
  TaskStatusUpdateEvent,
  TaskArtifactUpdateEvent,
  MessageSendParams,
  SendMessageResponse,
  SendStreamingMessageResponse,
  SendStreamingMessageSuccessResponse,
  TaskQueryParams,
  GetTaskResponse,
  GetTaskSuccessResponse,
  TaskIdParams,
  CancelTaskResponse,
  CancelTaskSuccessResponse,
  TaskPushNotificationConfig, // Renamed from PushNotificationConfigParams for direct schema alignment
  SetTaskPushNotificationConfigRequest,
  SetTaskPushNotificationConfigResponse,
  SetTaskPushNotificationConfigSuccessResponse,
  GetTaskPushNotificationConfigRequest,
  GetTaskPushNotificationConfigResponse,
  GetTaskPushNotificationConfigSuccessResponse,
  TaskResubscriptionRequest,
  A2AError,
  SendMessageSuccessResponse
} from '../types.js'; // Assuming schema.ts is in the same directory or appropriately pathed
‚ãÆ----
TaskPushNotificationConfig, // Renamed from PushNotificationConfigParams for direct schema alignment
‚ãÆ----
} from '../types.js'; // Assuming schema.ts is in the same directory or appropriately pathed
import { AGENT_CARD_PATH } from "../constants.js";
‚ãÆ----
// Helper type for the data yielded by streaming methods
type A2AStreamEventData = Message | Task | TaskStatusUpdateEvent | TaskArtifactUpdateEvent;
‚ãÆ----
/**
 * A2AClient is a TypeScript HTTP client for interacting with A2A-compliant agents.
 */
export class A2AClient
‚ãÆ----
private serviceEndpointUrl?: string; // To be populated from AgentCard after fetching
‚ãÆ----
/**
   * Constructs an A2AClient instance.
   * It initiates fetching the agent card from the provided agent baseUrl.
   * The Agent Card is fetched from a path relative to the agentBaseUrl, which defaults to '.well-known/agent-card.json'.
   * The `url` field from the Agent Card will be used as the RPC service endpoint.
   * @param agentBaseUrl The base URL of the A2A agent (e.g., https://agent.example.com)
   * @param agentCardPath path to the agent card, defaults to .well-known/agent-card.json
   */
constructor(agentBaseUrl: string, agentCardPath: string = AGENT_CARD_PATH)
‚ãÆ----
this.agentBaseUrl = agentBaseUrl.replace(/\/$/, ""); // Remove trailing slash if any
this.agentCardPath = agentCardPath.replace(/^\//, ""); // Remove leading slash if any
‚ãÆ----
/**
   * Fetches the Agent Card from the agent's well-known URI and caches its service endpoint URL.
   * This method is called by the constructor.
   * @returns A Promise that resolves to the AgentCard.
   */
private async _fetchAndCacheAgentCard(): Promise<AgentCard>
‚ãÆ----
this.serviceEndpointUrl = agentCard.url; // Cache the service endpoint URL from the agent card
‚ãÆ----
// Allow the promise to reject so users of agentCardPromise can handle it.
‚ãÆ----
/**
   * Retrieves the Agent Card.
   * If an `agentBaseUrl` is provided, it fetches the card from that specific URL.
   * Otherwise, it returns the card fetched and cached during client construction.
   * @param agentBaseUrl Optional. The base URL of the agent to fetch the card from.
   * @param agentCardPath path to the agent card, defaults to .well-known/agent-card.json
   * If provided, this will fetch a new card, not use the cached one from the constructor's URL.
   * @returns A Promise that resolves to the AgentCard.
   */
public async getAgentCard(agentBaseUrl?: string, agentCardPath: string = AGENT_CARD_PATH): Promise<AgentCard>
‚ãÆ----
// If no specific URL is given, return the promise for the initially configured agent's card.
‚ãÆ----
/**
   * Gets the RPC service endpoint URL. Ensures the agent card has been fetched first.
   * @returns A Promise that resolves to the service endpoint URL string.
   */
private async _getServiceEndpoint(): Promise<string>
‚ãÆ----
// If serviceEndpointUrl is not set, it means the agent card fetch is pending or failed.
// Awaiting agentCardPromise will either resolve it or throw if fetching failed.
‚ãÆ----
// This case should ideally be covered by the error handling in _fetchAndCacheAgentCard
‚ãÆ----
/**
   * Helper method to make a generic JSON-RPC POST request.
   * @param method The RPC method name.
   * @param params The parameters for the RPC method.
   * @returns A Promise that resolves to the RPC response.
   */
private async _postRpcRequest<TParams, TResponse extends JSONRPCResponse>(
    method: string,
    params: TParams
): Promise<TResponse>
‚ãÆ----
params: params as { [key: string]: any; }, // Cast because TParams structure varies per method
‚ãÆ----
"Accept": "application/json", // Expect JSON response for non-streaming requests
‚ãÆ----
// If the body is a valid JSON-RPC error response, let it be handled by the standard parsing below.
// However, if it's not even a JSON-RPC structure but still an error, throw based on HTTP status.
if (!errorJson.jsonrpc && errorJson.error) { // Check if it's a JSON-RPC error structure
‚ãÆ----
// If parsing the error body fails or it's not a JSON-RPC error, throw a generic HTTP error.
// If it was already an error thrown from within the try block, rethrow it.
‚ãÆ----
// This is a significant issue for request-response matching.
‚ãÆ----
// Depending on strictness, one might throw an error here.
// throw new Error(`RPC response ID mismatch for method ${method}. Expected ${requestId}, got ${rpcResponse.id}`);
‚ãÆ----
/**
   * Sends a message to the agent.
   * The behavior (blocking/non-blocking) and push notification configuration
   * are specified within the `params.configuration` object.
   * Optionally, `params.message.contextId` or `params.message.taskId` can be provided.
   * @param params The parameters for sending the message, including the message content and configuration.
   * @returns A Promise resolving to SendMessageResponse, which can be a Message, Task, or an error.
   */
public async sendMessage(params: MessageSendParams): Promise<SendMessageResponse>
‚ãÆ----
/**
   * Sends a message to the agent and streams back responses using Server-Sent Events (SSE).
   * Push notification configuration can be specified in `params.configuration`.
   * Optionally, `params.message.contextId` or `params.message.taskId` can be provided.
   * Requires the agent to support streaming (`capabilities.streaming: true` in AgentCard).
   * @param params The parameters for sending the message.
   * @returns An AsyncGenerator yielding A2AStreamEventData (Message, Task, TaskStatusUpdateEvent, or TaskArtifactUpdateEvent).
   * The generator throws an error if streaming is not supported or if an HTTP/SSE error occurs.
   */
public async *sendMessageStream(params: MessageSendParams): AsyncGenerator<A2AStreamEventData, void, undefined>
‚ãÆ----
const agentCard = await this.agentCardPromise; // Ensure agent card is fetched
‚ãÆ----
const clientRequestId = this.requestIdCounter++; // Use a unique ID for this stream request
const rpcRequest: JSONRPCRequest = { // This is the initial JSON-RPC request to establish the stream
‚ãÆ----
"Accept": "text/event-stream", // Crucial for SSE
‚ãÆ----
// Attempt to read error body for more details
‚ãÆ----
// Fallback if body is not JSON or parsing fails
‚ãÆ----
// Server should explicitly set this content type for SSE.
‚ãÆ----
// Yield events from the parsed SSE stream.
// Each event's 'data' field is a JSON-RPC response.
‚ãÆ----
/**
   * Sets or updates the push notification configuration for a given task.
   * Requires the agent to support push notifications (`capabilities.pushNotifications: true` in AgentCard).
   * @param params Parameters containing the taskId and the TaskPushNotificationConfig.
   * @returns A Promise resolving to SetTaskPushNotificationConfigResponse.
   */
public async setTaskPushNotificationConfig(params: TaskPushNotificationConfig): Promise<SetTaskPushNotificationConfigResponse>
‚ãÆ----
// The 'params' directly matches the structure expected by the RPC method.
‚ãÆ----
/**
   * Gets the push notification configuration for a given task.
   * @param params Parameters containing the taskId.
   * @returns A Promise resolving to GetTaskPushNotificationConfigResponse.
   */
public async getTaskPushNotificationConfig(params: TaskIdParams): Promise<GetTaskPushNotificationConfigResponse>
‚ãÆ----
// The 'params' (TaskIdParams) directly matches the structure expected by the RPC method.
‚ãÆ----
/**
   * Retrieves a task by its ID.
   * @param params Parameters containing the taskId and optional historyLength.
   * @returns A Promise resolving to GetTaskResponse, which contains the Task object or an error.
   */
public async getTask(params: TaskQueryParams): Promise<GetTaskResponse>
‚ãÆ----
/**
   * Cancels a task by its ID.
   * @param params Parameters containing the taskId.
   * @returns A Promise resolving to CancelTaskResponse, which contains the updated Task object or an error.
   */
public async cancelTask(params: TaskIdParams): Promise<CancelTaskResponse>
‚ãÆ----
/**
   * Resubscribes to a task's event stream using Server-Sent Events (SSE).
   * This is used if a previous SSE connection for an active task was broken.
   * Requires the agent to support streaming (`capabilities.streaming: true` in AgentCard).
   * @param params Parameters containing the taskId.
   * @returns An AsyncGenerator yielding A2AStreamEventData (Message, Task, TaskStatusUpdateEvent, or TaskArtifactUpdateEvent).
   */
public async *resubscribeTask(params: TaskIdParams): AsyncGenerator<A2AStreamEventData, void, undefined>
‚ãÆ----
const clientRequestId = this.requestIdCounter++; // Unique ID for this resubscribe request
const rpcRequest: JSONRPCRequest = { // Initial JSON-RPC request to establish the stream
‚ãÆ----
// The events structure for resubscribe is assumed to be the same as message/stream.
// Each event's 'data' field is a JSON-RPC response.
‚ãÆ----
/**
   * Parses an HTTP response body as an A2A Server-Sent Event stream.
   * Each 'data' field of an SSE event is expected to be a JSON-RPC 2.0 Response object,
   * specifically a SendStreamingMessageResponse (or similar structure for resubscribe).
   * @param response The HTTP Response object whose body is the SSE stream.
   * @param originalRequestId The ID of the client's JSON-RPC request that initiated this stream.
   * Used to validate the `id` in the streamed JSON-RPC responses.
   * @returns An AsyncGenerator yielding the `result` field of each valid JSON-RPC success response from the stream.
   */
private async *_parseA2ASseStream<TStreamItem>(
    response: Response,
    originalRequestId: number | string | null
): AsyncGenerator<TStreamItem, void, undefined>
‚ãÆ----
let buffer = ""; // Holds incomplete lines from the stream
let eventDataBuffer = ""; // Holds accumulated 'data:' lines for the current event
‚ãÆ----
// Process any final buffered event data if the stream ends abruptly after a 'data:' line
‚ãÆ----
break; // Stream finished
‚ãÆ----
buffer += value; // Append new chunk to buffer
‚ãÆ----
// Process all complete lines in the buffer
‚ãÆ----
const line = buffer.substring(0, lineEndIndex).trim(); // Get and trim the line
buffer = buffer.substring(lineEndIndex + 1); // Remove processed line from buffer
‚ãÆ----
if (line === "") { // Empty line: signifies the end of an event
if (eventDataBuffer) { // If we have accumulated data for an event
‚ãÆ----
eventDataBuffer = ""; // Reset buffer for the next event
‚ãÆ----
eventDataBuffer += line.substring(5).trimStart() + "\n"; // Append data (multi-line data is possible)
‚ãÆ----
// This is a comment line in SSE, ignore it.
‚ãÆ----
// Other SSE fields like 'event:', 'id:', 'retry:'.
// The A2A spec primarily focuses on the 'data' field for JSON-RPC payloads.
// For now, we don't specifically handle these other SSE fields unless required by spec.
‚ãÆ----
// Log and re-throw errors encountered during stream processing
‚ãÆ----
reader.releaseLock(); // Ensure the reader lock is released
‚ãÆ----
/**
   * Processes a single SSE event's data string, expecting it to be a JSON-RPC response.
   * @param jsonData The string content from one or more 'data:' lines of an SSE event.
   * @param originalRequestId The ID of the client's request that initiated the stream.
   * @returns The `result` field of the parsed JSON-RPC success response.
   * @throws Error if data is not valid JSON, not a valid JSON-RPC response, an error response, or ID mismatch.
   */
private _processSseEventData<TStreamItem>(
    jsonData: string,
    originalRequestId: number | string | null
): TStreamItem
‚ãÆ----
// SSE data can be multi-line, ensure it's treated as a single JSON string.
const sseJsonRpcResponse = JSON.parse(jsonData.replace(/\n$/, '')); // Remove trailing newline if any
‚ãÆ----
// Type assertion to SendStreamingMessageResponse, as this is the expected structure for A2A streams.
‚ãÆ----
// According to JSON-RPC spec, notifications (which SSE events can be seen as) might not have an ID,
// or if they do, it should match. A2A spec implies streamed events are tied to the initial request.
‚ãÆ----
// Depending on strictness, this could be an error. For now, it's a warning.
‚ãÆ----
// Check if 'result' exists, as it's mandatory for successful JSON-RPC responses
‚ãÆ----
// Catch errors from JSON.parse or if it's an error response that was thrown by this function
‚ãÆ----
throw e; // Re-throw errors already processed/identified by this function
‚ãÆ----
// For other parsing errors or unexpected structures:
‚ãÆ----
isErrorResponse(response: JSONRPCResponse): response is JSONRPCErrorResponse

================
File: src/client/index.ts
================
/**
 * Client entry point for the A2A Server V2 library.
 */

================
File: src/samples/agents/movie-agent/genkit.ts
================
import { googleAI } from "@genkit-ai/googleai";
import { genkit } from "genkit";
import { dirname } from "path";
import { fileURLToPath } from "url";

================
File: src/samples/agents/movie-agent/index.ts
================
import express from "express";
import { v4 as uuidv4 } from 'uuid'; // For generating unique IDs
‚ãÆ----
import {
  AgentCard,
  Task,
  TaskState,
  TaskStatusUpdateEvent,
  TextPart,
  Message
} from "../../../index.js";
import {
  InMemoryTaskStore,
  TaskStore,
  AgentExecutor,
  RequestContext,
  ExecutionEventBus,
  DefaultRequestHandler
} from "../../../server/index.js";
import { A2AExpressApp } from "../../../server/express/index.js";
import { MessageData } from "genkit";
import { ai } from "./genkit.js";
import { searchMovies, searchPeople } from "./tools.js";
‚ãÆ----
// Simple store for contexts
‚ãÆ----
// Load the Genkit prompt
‚ãÆ----
/**
 * MovieAgentExecutor implements the agent's core logic.
 */
class MovieAgentExecutor implements AgentExecutor
‚ãÆ----
// The execute loop is responsible for publishing the final state
‚ãÆ----
async execute(
    requestContext: RequestContext,
    eventBus: ExecutionEventBus
): Promise<void>
‚ãÆ----
// Determine IDs for the task and context
‚ãÆ----
// 1. Publish initial Task event if it's a new task
‚ãÆ----
history: [userMessage], // Start history with the current user message
metadata: userMessage.metadata, // Carry over metadata from message if any
‚ãÆ----
// 2. Publish "working" status update
‚ãÆ----
// 3. Prepare messages for Genkit prompt
‚ãÆ----
// 4. Run the Genkit prompt
‚ãÆ----
// Check if the request has been cancelled
‚ãÆ----
final: true, // Cancellation is a final state
‚ãÆ----
const responseText = response.text; // Access the text property using .text()
‚ãÆ----
finalA2AState = 'completed'; // Default if LLM deviates
‚ãÆ----
// 5. Publish final task status update
‚ãÆ----
parts: [{ kind: 'text', text: agentReplyText || "Completed." }], // Ensure some text
‚ãÆ----
// --- Server Setup ---
‚ãÆ----
// Adjust the base URL and port as needed. /a2a is the default base in A2AExpressApp
url: 'http://localhost:41241/', // Example: if baseUrl in A2AExpressApp
‚ãÆ----
url: 'https://example.com/a2a-samples' // Added provider URL
‚ãÆ----
version: '0.0.2', // Incremented version
‚ãÆ----
streaming: true, // The new framework supports streaming
pushNotifications: false, // Assuming not implemented for this agent yet
stateTransitionHistory: true, // Agent uses history
‚ãÆ----
// authentication: null, // Property 'authentication' does not exist on type 'AgentCard'.
securitySchemes: undefined, // Or define actual security schemes if any
‚ãÆ----
defaultOutputModes: ['text', 'task-status'], // task-status is a common output mode
‚ãÆ----
inputModes: ['text'], // Explicitly defining for skill
outputModes: ['text', 'task-status'] // Explicitly defining for skill
‚ãÆ----
async function main()
‚ãÆ----
// 1. Create TaskStore
‚ãÆ----
// 2. Create AgentExecutor
‚ãÆ----
// 3. Create DefaultRequestHandler
‚ãÆ----
// 4. Create and setup A2AExpressApp
‚ãÆ----
// 5. Start the server

================
File: src/samples/agents/movie-agent/movie_agent.prompt
================
{{role "system"}}
You are a movie expert. Answer the user's question about movies and film industry personalities, using the searchMovies and searchPeople tools to find out more information as needed. Feel free to call them multiple times in parallel if necessary.{{#if goal}}

Your goal in this task is: {{goal}}{{/if}}

The current date and time is: {{now}}

If the user asks you for specific information about a movie or person (such as the plot or a specific role an actor played), do a search for that movie/actor using the available functions before responding.

## Output Instructions

ALWAYS end your response with either "COMPLETED" or "AWAITING_USER_INPUT" on its own line. If you have answered the user's question, use COMPLETED. If you need more information to answer the question, use AWAITING_USER_INPUT.

<example>
<question>
when was [some_movie] released?
</question>
<output>
[some_movie] was released on October 3, 1992.
COMPLETED
</output>
</example>

================
File: src/samples/agents/movie-agent/README.md
================
# Movie Info Agent

This agent uses the TMDB API to answer questions about movies. To run:

```bash
export TMDB_API_KEY=<api_key> # see https://developer.themoviedb.org/docs/getting-started
export GEMINI_API_KEY=<api_key>
npm run agents:movie-agent
```

The agent will start on `http://localhost:41241`.

================
File: src/samples/agents/movie-agent/tmdb.ts
================
/**
 * Utility function to call the TMDB API
 * @param endpoint The TMDB API endpoint (e.g., 'movie', 'person')
 * @param query The search query
 * @returns Promise that resolves to the API response data
 */
export async function callTmdbApi(endpoint: string, query: string)
‚ãÆ----
// Validate API key
‚ãÆ----
// Make request to TMDB API

================
File: src/samples/agents/movie-agent/tools.ts
================
import { ai, z } from "./genkit.js";
import { callTmdbApi } from "./tmdb.js";
‚ãÆ----
// Only modify image paths to be full URLs
‚ãÆ----
// Re-throwing allows Genkit/the caller to handle it appropriately
‚ãÆ----
// Only modify image paths to be full URLs
‚ãÆ----
// Also modify poster paths in known_for works
‚ãÆ----
// Re-throwing allows Genkit/the caller to handle it appropriately

================
File: src/samples/cli.ts
================
import readline from "node:readline";
import crypto from "node:crypto";
‚ãÆ----
import {
  // Specific Params/Payload types used by the CLI
  MessageSendParams, // Changed from TaskSendParams
  TaskStatusUpdateEvent,
  TaskArtifactUpdateEvent,
  Message,
  Task, // Added for direct Task events
  // Other types needed for message/part handling
  TaskState,
  FilePart,
  DataPart,
  // Type for the agent card
  AgentCard,
  Part // Added for explicit Part typing
} from "../index.js";
‚ãÆ----
// Specific Params/Payload types used by the CLI
MessageSendParams, // Changed from TaskSendParams
‚ãÆ----
Task, // Added for direct Task events
// Other types needed for message/part handling
‚ãÆ----
// Type for the agent card
‚ãÆ----
Part // Added for explicit Part typing
‚ãÆ----
import { A2AClient } from "../client/index.js";
‚ãÆ----
// --- ANSI Colors ---
‚ãÆ----
// --- Helper Functions ---
function colorize(color: keyof typeof colors, text: string): string
‚ãÆ----
function generateId(): string { // Renamed for more general use
  return crypto.randomUUID();
‚ãÆ----
// --- State ---
let currentTaskId: string | undefined = undefined; // Initialize as undefined
let currentContextId: string | undefined = undefined; // Initialize as undefined
const serverUrl = process.argv[2] || "http://localhost:41241"; // Agent's base URL
‚ãÆ----
let agentName = "Agent"; // Default, try to get from agent card later
‚ãÆ----
// --- Readline Setup ---
‚ãÆ----
// --- Response Handling ---
// Function now accepts the unwrapped event payload directly
function printAgentEvent(
  event: TaskStatusUpdateEvent | TaskArtifactUpdateEvent
)
‚ãÆ----
// Check if it's a TaskStatusUpdateEvent
‚ãÆ----
const update = event as TaskStatusUpdateEvent; // Cast for type safety
‚ãÆ----
stateEmoji = "‚ÑπÔ∏è"; // For other states like submitted, rejected etc.
‚ãÆ----
// Check if it's a TaskArtifactUpdateEvent
‚ãÆ----
const update = event as TaskArtifactUpdateEvent; // Cast for type safety
‚ãÆ----
// Create a temporary message-like structure to reuse printMessageContent
‚ãÆ----
messageId: generateId(), // Dummy messageId
kind: "message", // Dummy kind
role: "agent", // Assuming artifact parts are from agent
‚ãÆ----
// This case should ideally not be reached if called correctly
‚ãÆ----
function printMessageContent(message: Message)
‚ãÆ----
message.parts.forEach((part: Part, index: number) => { // Added explicit Part type
‚ãÆ----
if (part.kind === "text") { // Check kind property
‚ãÆ----
} else if (part.kind === "file") { // Check kind property
‚ãÆ----
} else if (part.kind === "data") { // Check kind property
‚ãÆ----
// --- Agent Card Fetching ---
async function fetchAndDisplayAgentCard()
‚ãÆ----
// Use the client's getAgentCard method.
// The client was initialized with serverUrl, which is the agent's base URL.
‚ãÆ----
// client.getAgentCard() uses the agentBaseUrl provided during client construction
‚ãÆ----
agentName = card.name || "Agent"; // Update global agent name
‚ãÆ----
// Update prompt prefix to use the fetched name
// The prompt is set dynamically before each rl.prompt() call in the main loop
// to reflect the current agentName if it changes (though unlikely after initial fetch).
‚ãÆ----
// --- Main Loop ---
async function main()
‚ãÆ----
await fetchAndDisplayAgentCard(); // Fetch the card before starting the loop
‚ãÆ----
rl.setPrompt(colorize("cyan", `${agentName} > You: `)); // Set initial prompt
‚ãÆ----
rl.setPrompt(colorize("cyan", `${agentName} > You: `)); // Ensure prompt reflects current agentName
‚ãÆ----
currentContextId = undefined; // Reset contextId on /new
‚ãÆ----
// Construct params for sendMessageStream
const messageId = generateId(); // Generate a unique message ID
‚ãÆ----
kind: "message", // Required by Message interface
‚ãÆ----
kind: "text", // Required by TextPart interface
‚ãÆ----
// Conditionally add taskId to the message payload
‚ãÆ----
// Conditionally add contextId to the message payload
‚ãÆ----
// Optional: configuration for streaming, blocking, etc.
// configuration: {
//   acceptedOutputModes: ['text/plain', 'application/json'], // Example
//   blocking: false // Default for streaming is usually non-blocking
// }
‚ãÆ----
// Use sendMessageStream
‚ãÆ----
// Iterate over the events from the stream
‚ãÆ----
const timestamp = new Date().toLocaleTimeString(); // Get fresh timestamp for each event
‚ãÆ----
// If the event is a TaskStatusUpdateEvent and it's final, reset currentTaskId
‚ãÆ----
// Optionally, you might want to clear currentContextId as well if a task ending implies context ending.
// currentContextId = undefined;
// console.log(colorize("dim", `   Context ID also cleared as task is final.`));
‚ãÆ----
// --- Start ---

================
File: src/server/agent_execution/agent_executor.ts
================
import { ExecutionEventBus } from "../events/execution_event_bus.js";
import { RequestContext } from "./request_context.js";
‚ãÆ----
export interface AgentExecutor {
    /**
     * Executes the agent logic based on the request context and publishes events.
     * @param requestContext The context of the current request.
     * @param eventBus The bus to publish execution events to.
     */
    execute: (
        requestContext: RequestContext,
        eventBus: ExecutionEventBus
    ) => Promise<void>;

    /**
     * Method to explicitly cancel a running task.
     * The implementation should handle the logic of stopping the execution
     * and publishing the final 'canceled' status event on the provided event bus.
     * @param taskId The ID of the task to cancel.
     * @param eventBus The event bus associated with the task's execution.
     */
    cancelTask: (
        taskId: string,
        eventBus: ExecutionEventBus
    ) => Promise<void>;
}
‚ãÆ----
/**
     * Executes the agent logic based on the request context and publishes events.
     * @param requestContext The context of the current request.
     * @param eventBus The bus to publish execution events to.
     */
‚ãÆ----
/**
     * Method to explicitly cancel a running task.
     * The implementation should handle the logic of stopping the execution
     * and publishing the final 'canceled' status event on the provided event bus.
     * @param taskId The ID of the task to cancel.
     * @param eventBus The event bus associated with the task's execution.
     */

================
File: src/server/agent_execution/request_context.ts
================
import {
    Message,
    Task,
} from "../../types.js";
‚ãÆ----
export class RequestContext
‚ãÆ----
constructor(
        userMessage: Message,
        taskId: string,
        contextId: string,
        task?: Task,
        referenceTasks?: Task[],
)

================
File: src/server/events/execution_event_bus_manager.ts
================
import { DefaultExecutionEventBus, ExecutionEventBus } from "./execution_event_bus.js";
‚ãÆ----
export interface ExecutionEventBusManager {
    createOrGetByTaskId(taskId: string): ExecutionEventBus;
    getByTaskId(taskId: string): ExecutionEventBus | undefined;
    cleanupByTaskId(taskId: string): void;
}
‚ãÆ----
createOrGetByTaskId(taskId: string): ExecutionEventBus;
getByTaskId(taskId: string): ExecutionEventBus | undefined;
cleanupByTaskId(taskId: string): void;
‚ãÆ----
export class DefaultExecutionEventBusManager implements ExecutionEventBusManager
‚ãÆ----
/**
     * Creates or retrieves an existing ExecutionEventBus based on the taskId.
     * @param taskId The ID of the task.
     * @returns An instance of IExecutionEventBus.
     */
public createOrGetByTaskId(taskId: string): ExecutionEventBus
‚ãÆ----
/**
     * Retrieves an existing ExecutionEventBus based on the taskId.
     * @param taskId The ID of the task.
     * @returns An instance of IExecutionEventBus or undefined if not found.
     */
public getByTaskId(taskId: string): ExecutionEventBus | undefined
‚ãÆ----
/**
     * Removes the event bus for a given taskId.
     * This should be called when an execution flow is complete to free resources.
     * @param taskId The ID of the task.
     */
public cleanupByTaskId(taskId: string): void

================
File: src/server/events/execution_event_bus.ts
================
import { EventEmitter } from 'events';
‚ãÆ----
import {
    Message,
    Task,
    TaskStatusUpdateEvent,
    TaskArtifactUpdateEvent,
} from "../../types.js";
‚ãÆ----
export type AgentExecutionEvent =
    | Message
    | Task
    | TaskStatusUpdateEvent
    | TaskArtifactUpdateEvent;
‚ãÆ----
export interface ExecutionEventBus {
    publish(event: AgentExecutionEvent): void;
    on(eventName: 'event' | 'finished', listener: (event: AgentExecutionEvent) => void): this;
    off(eventName: 'event' | 'finished', listener: (event: AgentExecutionEvent) => void): this;
    once(eventName: 'event' | 'finished', listener: (event: AgentExecutionEvent) => void): this;
    removeAllListeners(eventName?: 'event' | 'finished'): this;
    finished(): void;
}
‚ãÆ----
publish(event: AgentExecutionEvent): void;
on(eventName: 'event' | 'finished', listener: (event: AgentExecutionEvent)
off(eventName: 'event' | 'finished', listener: (event: AgentExecutionEvent)
once(eventName: 'event' | 'finished', listener: (event: AgentExecutionEvent)
removeAllListeners(eventName?: 'event' | 'finished'): this;
finished(): void;
‚ãÆ----
export class DefaultExecutionEventBus extends EventEmitter implements ExecutionEventBus
‚ãÆ----
constructor()
‚ãÆ----
publish(event: AgentExecutionEvent): void
‚ãÆ----
finished(): void

================
File: src/server/events/execution_event_queue.ts
================
import {
    TaskStatusUpdateEvent,
} from "../../types.js";
import { ExecutionEventBus, AgentExecutionEvent } from "./execution_event_bus.js";
‚ãÆ----
/**
 * An async queue that subscribes to an ExecutionEventBus for events
 * and provides an async generator to consume them.
 */
export class ExecutionEventQueue
‚ãÆ----
constructor(eventBus: ExecutionEventBus)
‚ãÆ----
/**
     * Provides an async generator that yields events from the event bus.
     * Stops when a Message event is received or a TaskStatusUpdateEvent with final=true is received.
     */
public async *events(): AsyncGenerator<AgentExecutionEvent, void, undefined>
‚ãÆ----
/**
     * Stops the event queue from processing further events.
     */
public stop(): void
‚ãÆ----
this.resolvePromise(); // Unblock any pending await

================
File: src/server/express/a2a_express_app.ts
================
import express, { Request, Response, Express, RequestHandler, ErrorRequestHandler } from 'express';
‚ãÆ----
import { A2AError } from "../error.js";
import { JSONRPCErrorResponse, JSONRPCSuccessResponse, JSONRPCResponse } from "../../index.js";
import { A2ARequestHandler } from "../request_handler/a2a_request_handler.js";
import { JsonRpcTransportHandler } from "../transports/jsonrpc_transport_handler.js";
import { AGENT_CARD_PATH } from "../../constants.js";
‚ãÆ----
export class A2AExpressApp
‚ãÆ----
private requestHandler: A2ARequestHandler; // Kept for getAgentCard
‚ãÆ----
constructor(requestHandler: A2ARequestHandler)
‚ãÆ----
this.requestHandler = requestHandler; // DefaultRequestHandler instance
‚ãÆ----
/**
     * Adds A2A routes to an existing Express app.
     * @param app Optional existing Express app.
     * @param baseUrl The base URL for A2A endpoints (e.g., "/a2a/api").
     * @param middlewares Optional array of Express middlewares to apply to the A2A routes.
     * @param agentCardPath Optional custom path for the agent card endpoint (defaults to /.well-known/agent-card.json).
     * @returns The Express app with A2A routes.
     */
public setupRoutes(
        app: Express,
        baseUrl: string = "",
        middlewares?: Array<RequestHandler | ErrorRequestHandler>,
        agentCardPath: string = AGENT_CARD_PATH
): Express
‚ãÆ----
// getAgentCard is on A2ARequestHandler, which DefaultRequestHandler implements
‚ãÆ----
// Check if it's an AsyncGenerator (stream)
‚ãÆ----
// Each event from the stream is already a JSONRPCResult
‚ãÆ----
// If the stream itself throws an error, send a final JSONRPCErrorResponse
‚ãÆ----
id: req.body?.id || null, // Use original request ID if available
‚ãÆ----
if (!res.headersSent) { // Should not happen if flushHeaders worked
res.status(500).json(errorResponse); // Should be JSON, not SSE here
‚ãÆ----
// Try to send as last SSE event if possible, though client might have disconnected
‚ãÆ----
res.write(`event: error\n`); // Custom event type for client-side handling
‚ãÆ----
} else { // Single JSON-RPC response
‚ãÆ----
} catch (error: any) { // Catch errors from jsonRpcTransportHandler.handle itself (e.g., initial parse error)
‚ãÆ----
// If headers sent (likely during a stream attempt that failed early), try to end gracefully
‚ãÆ----
// The separate /stream endpoint is no longer needed.

================
File: src/server/express/index.ts
================
/**
 * Express integration for the A2A Server library.
 * This module provides Express.js specific functionality.
 */

================
File: src/server/request_handler/a2a_request_handler.ts
================
import {
    Message,
    AgentCard,
    MessageSendParams,
    Task,
    TaskStatusUpdateEvent,
    TaskArtifactUpdateEvent,
    TaskQueryParams,
    TaskIdParams,
    TaskPushNotificationConfig,
    GetTaskPushNotificationConfigParams,
    ListTaskPushNotificationConfigParams,
    DeleteTaskPushNotificationConfigParams,
} from "../../types.js";
‚ãÆ----
export interface A2ARequestHandler {
    getAgentCard(): Promise<AgentCard>;

    getAuthenticatedExtendedAgentCard(): Promise<AgentCard>;

    sendMessage(
        params: MessageSendParams
    ): Promise<Message | Task>;

    sendMessageStream(
        params: MessageSendParams
    ): AsyncGenerator<
        | Message
        | Task
        | TaskStatusUpdateEvent
        | TaskArtifactUpdateEvent,
        void,
        undefined
    >;

    getTask(params: TaskQueryParams): Promise<Task>;
    cancelTask(params: TaskIdParams): Promise<Task>;

    setTaskPushNotificationConfig(
        params: TaskPushNotificationConfig
    ): Promise<TaskPushNotificationConfig>;

    getTaskPushNotificationConfig(
        params: TaskIdParams | GetTaskPushNotificationConfigParams
    ): Promise<TaskPushNotificationConfig>;

    listTaskPushNotificationConfigs(
        params: ListTaskPushNotificationConfigParams
    ): Promise<TaskPushNotificationConfig[]>;

    deleteTaskPushNotificationConfig(
        params: DeleteTaskPushNotificationConfigParams
    ): Promise<void>;

    resubscribe(
        params: TaskIdParams
    ): AsyncGenerator<
        | Task
        | TaskStatusUpdateEvent
        | TaskArtifactUpdateEvent,
        void,
        undefined
    >;
}
‚ãÆ----
getAgentCard(): Promise<AgentCard>;
‚ãÆ----
getAuthenticatedExtendedAgentCard(): Promise<AgentCard>;
‚ãÆ----
sendMessage(
        params: MessageSendParams
    ): Promise<Message | Task>;
‚ãÆ----
sendMessageStream(
‚ãÆ----
getTask(params: TaskQueryParams): Promise<Task>;
cancelTask(params: TaskIdParams): Promise<Task>;
‚ãÆ----
setTaskPushNotificationConfig(
        params: TaskPushNotificationConfig
    ): Promise<TaskPushNotificationConfig>;
‚ãÆ----
getTaskPushNotificationConfig(
        params: TaskIdParams | GetTaskPushNotificationConfigParams
    ): Promise<TaskPushNotificationConfig>;
‚ãÆ----
listTaskPushNotificationConfigs(
        params: ListTaskPushNotificationConfigParams
    ): Promise<TaskPushNotificationConfig[]>;
‚ãÆ----
deleteTaskPushNotificationConfig(
        params: DeleteTaskPushNotificationConfigParams
    ): Promise<void>;
‚ãÆ----
resubscribe(

================
File: src/server/request_handler/default_request_handler.ts
================
import { v4 as uuidv4 } from 'uuid'; // For generating unique IDs
‚ãÆ----
import { Message, AgentCard, PushNotificationConfig, Task, MessageSendParams, TaskState, TaskStatusUpdateEvent, TaskArtifactUpdateEvent, TaskQueryParams, TaskIdParams, TaskPushNotificationConfig, DeleteTaskPushNotificationConfigParams, GetTaskPushNotificationConfigParams, ListTaskPushNotificationConfigParams } from "../../types.js";
import { AgentExecutor } from "../agent_execution/agent_executor.js";
import { RequestContext } from "../agent_execution/request_context.js";
import { A2AError } from "../error.js";
import { ExecutionEventBusManager, DefaultExecutionEventBusManager } from "../events/execution_event_bus_manager.js";
import { ExecutionEventBus } from "../events/execution_event_bus.js";
import { ExecutionEventQueue } from "../events/execution_event_queue.js";
import { ResultManager } from "../result_manager.js";
import { TaskStore } from "../store.js";
import { A2ARequestHandler } from "./a2a_request_handler.js";
‚ãÆ----
export class DefaultRequestHandler implements A2ARequestHandler
‚ãÆ----
// Store for push notification configurations (could be part of TaskStore or separate)
‚ãÆ----
constructor(
        agentCard: AgentCard,
        taskStore: TaskStore,
        agentExecutor: AgentExecutor,
        eventBusManager: ExecutionEventBusManager = new DefaultExecutionEventBusManager(),
        extendedAgentCard?: AgentCard,
)
‚ãÆ----
async getAgentCard(): Promise<AgentCard>
‚ãÆ----
async getAuthenticatedExtendedAgentCard(): Promise<AgentCard>
‚ãÆ----
private async _createRequestContext(
        incomingMessage: Message,
        taskId: string,
        isStream: boolean,
): Promise<RequestContext>
‚ãÆ----
// incomingMessage would contain taskId, if a task already exists.
‚ãÆ----
// Throw an error that conforms to the JSON-RPC Invalid Request error specification.
‚ãÆ----
// Optionally, throw an error or handle as per specific requirements
‚ãÆ----
// Ensure contextId is present
‚ãÆ----
private async _processEvents(
        taskId: string,
        resultManager: ResultManager,
        eventQueue: ExecutionEventQueue,
        options?: {
firstResultResolver?: (value: Message | Task | PromiseLike<Message | Task>)
‚ãÆ----
// re-throw error for blocking case to catch
‚ãÆ----
async sendMessage(
        params: MessageSendParams
): Promise<Message | Task>
‚ãÆ----
// Default to blocking behavior if 'blocking' is not explicitly false.
‚ãÆ----
// Instantiate ResultManager before creating RequestContext
‚ãÆ----
resultManager.setContext(incomingMessage); // Set context for ResultManager
‚ãÆ----
// Use the (potentially updated) contextId from requestContext
‚ãÆ----
// EventQueue should be attached to the bus, before the agent execution begins.
‚ãÆ----
// Start agent execution (non-blocking).
// It runs in the background and publishes events to the eventBus.
‚ãÆ----
// Publish a synthetic error event, which will be handled by the ResultManager
// and will also settle the firstResultPromise for non-blocking calls.
‚ãÆ----
id: requestContext.task?.id || uuidv4(), // Use existing task ID or generate new
‚ãÆ----
if (finalMessageForAgent) { // Add incoming message to history
‚ãÆ----
eventBus.publish({ // And publish a final status update
‚ãÆ----
// In blocking mode, wait for the full processing to complete.
‚ãÆ----
// In non-blocking mode, return a promise that will be settled by fullProcessing.
‚ãÆ----
async *sendMessageStream(
        params: MessageSendParams
    ): AsyncGenerator<
        | Message
        | Task
        | TaskStatusUpdateEvent
        | TaskArtifactUpdateEvent,
        void,
        undefined
    > {
        const incomingMessage = params.message;
if (!incomingMessage.messageId)
‚ãÆ----
// For streams, messageId might be set by client, or server can generate if not present.
// Let's assume client provides it or throw for now.
‚ãÆ----
// Instantiate ResultManager before creating RequestContext
‚ãÆ----
resultManager.setContext(incomingMessage); // Set context for ResultManager
‚ãÆ----
// Start agent execution (non-blocking)
‚ãÆ----
// Publish a synthetic error event if needed
‚ãÆ----
taskId: requestContext.task?.id || uuidv4(), // Use existing or a placeholder
‚ãÆ----
final: true, // This will terminate the stream for the client
‚ãÆ----
await resultManager.processEvent(event); // Update store in background
yield event; // Stream the event to the client
‚ãÆ----
// Cleanup when the stream is fully consumed or breaks
‚ãÆ----
async getTask(params: TaskQueryParams): Promise<Task>
‚ãÆ----
// Negative or invalid historyLength means no history
‚ãÆ----
async cancelTask(params: TaskIdParams): Promise<Task>
‚ãÆ----
// Check if task is in a cancelable state
‚ãÆ----
// Here we are marking task as cancelled. We are not waiting for the executor to actually cancel processing.
‚ãÆ----
message: { // Optional: Add a system message indicating cancellation
‚ãÆ----
// Add cancellation message to history
‚ãÆ----
async setTaskPushNotificationConfig(
        params: TaskPushNotificationConfig
): Promise<TaskPushNotificationConfig>
‚ãÆ----
// Default the config ID to the task ID if not provided for backward compatibility.
‚ãÆ----
// Remove existing config with the same ID to replace it
‚ãÆ----
async getTaskPushNotificationConfig(
        params: TaskIdParams | GetTaskPushNotificationConfigParams
): Promise<TaskPushNotificationConfig>
‚ãÆ----
// For backward compatibility, if no config ID is given, assume it's the task ID.
‚ãÆ----
async listTaskPushNotificationConfigs(
        params: ListTaskPushNotificationConfigParams
): Promise<TaskPushNotificationConfig[]>
‚ãÆ----
async deleteTaskPushNotificationConfig(
        params: DeleteTaskPushNotificationConfigParams
): Promise<void>
‚ãÆ----
async *resubscribe(
        params: TaskIdParams
    ): AsyncGenerator<
        | Task // Initial task state
        | TaskStatusUpdateEvent
        | TaskArtifactUpdateEvent,
        void,
        undefined
    > {
if (!this.agentCard.capabilities.streaming)
‚ãÆ----
| Task // Initial task state
‚ãÆ----
// Yield the current task state first
‚ãÆ----
// If task is already in a final state, no more events will come.
‚ãÆ----
// No active execution for this task, so no live events.
‚ãÆ----
// Attach a new queue to the existing bus for this resubscription
‚ãÆ----
// Note: The ResultManager part is already handled by the original execution flow.
// Resubscribe just listens for new events.
‚ãÆ----
// We only care about updates related to *this* task.
// The event bus might be shared if messageId was reused, though
// ExecutionEventBusManager tries to give one bus per original message.
‚ãÆ----
// This implies the task was re-emitted, yield it.
‚ãÆ----
// We don't yield 'message' events on resubscribe typically,
// as those signal the end of an interaction for the *original* request.
// If a 'message' event for the original request terminates the bus, this loop will also end.

================
File: src/server/transports/jsonrpc_transport_handler.ts
================
import { JSONRPCErrorResponse, MessageSendParams, TaskQueryParams, TaskIdParams, TaskPushNotificationConfig, A2ARequest, JSONRPCResponse, DeleteTaskPushNotificationConfigParams, ListTaskPushNotificationConfigParams } from "../../types.js";
import { A2AError } from "../error.js";
import { A2ARequestHandler } from "../request_handler/a2a_request_handler.js";
‚ãÆ----
/**
 * Handles JSON-RPC transport layer, routing requests to A2ARequestHandler.
 */
export class JsonRpcTransportHandler
‚ãÆ----
constructor(requestHandler: A2ARequestHandler)
‚ãÆ----
/**
     * Handles an incoming JSON-RPC request.
     * For streaming methods, it returns an AsyncGenerator of JSONRPCResult.
     * For non-streaming methods, it returns a Promise of a single JSONRPCMessage (Result or ErrorResponse).
     */
public async handle(
        requestBody: any
): Promise<JSONRPCResponse | AsyncGenerator<JSONRPCResponse, void, undefined>>
‚ãÆ----
// Wrap the agent event stream into a JSON-RPC result stream
‚ãÆ----
id: requestId, // Use the original request ID for all streamed responses
‚ãÆ----
// If the underlying agent stream throws an error, we need to yield a JSONRPCErrorResponse.
// However, an AsyncGenerator is expected to yield JSONRPCResult.
// This indicates an issue with how errors from the agent's stream are propagated.
// For now, log it. The Express layer will handle the generator ending.
‚ãÆ----
// Ideally, the Express layer should catch this and send a final error to the client if the stream breaks.
// Or, the agentEventStream itself should yield a final error event that gets wrapped.
// For now, we re-throw so it can be caught by A2AExpressApp's stream handling.
‚ãÆ----
// Handle non-streaming methods

================
File: src/server/error.ts
================
/**
 * Custom error class for A2A server operations, incorporating JSON-RPC error codes.
 */
export class A2AError extends Error
‚ãÆ----
public taskId?: string; // Optional task ID context
‚ãÆ----
constructor(
    code: number,
    message: string,
    data?: Record<string, unknown>,
    taskId?: string
)
‚ãÆ----
this.taskId = taskId; // Store associated task ID if provided
‚ãÆ----
/**
   * Formats the error into a standard JSON-RPC error object structure.
   */
toJSONRPCError(): schema.JSONRPCError
‚ãÆ----
// Static factory methods for common errors
‚ãÆ----
static parseError(message: string, data?: Record<string, unknown>): A2AError
‚ãÆ----
static invalidRequest(message: string, data?: Record<string, unknown>): A2AError
‚ãÆ----
static methodNotFound(method: string): A2AError
‚ãÆ----
static invalidParams(message: string, data?: Record<string, unknown>): A2AError
‚ãÆ----
static internalError(message: string, data?: Record<string, unknown>): A2AError
‚ãÆ----
static taskNotFound(taskId: string): A2AError
‚ãÆ----
static taskNotCancelable(taskId: string): A2AError
‚ãÆ----
static pushNotificationNotSupported(): A2AError
‚ãÆ----
static unsupportedOperation(operation: string): A2AError
‚ãÆ----
static authenticatedExtendedCardNotConfigured(): A2AError

================
File: src/server/index.ts
================
/**
 * Server entry point for the A2A Server V2 library.
 * Exports the server-only codebase.
 */

================
File: src/server/result_manager.ts
================
import {
    Message,
    Task,
    TaskArtifactUpdateEvent,
    TaskStatusUpdateEvent
} from "../types.js";
import { AgentExecutionEvent } from "./events/execution_event_bus.js";
import { TaskStore } from "./store.js";
‚ãÆ----
export class ResultManager
‚ãÆ----
private latestUserMessage?: Message; // To add to history if a new task is created
private finalMessageResult?: Message; // Stores the message if it's the final result
‚ãÆ----
constructor(taskStore: TaskStore)
‚ãÆ----
public setContext(latestUserMessage: Message): void
‚ãÆ----
/**
     * Processes an agent execution event and updates the task store.
     * @param event The agent execution event.
     */
public async processEvent(event: AgentExecutionEvent): Promise<void>
‚ãÆ----
// If a message is received, it's usually the final result,
// but we continue processing to ensure task state (if any) is also saved.
// The ExecutionEventQueue will stop after a message event.
‚ãÆ----
this.currentTask = { ...taskEvent }; // Make a copy
‚ãÆ----
// Ensure the latest user message is in history if not already present
‚ãÆ----
// Add message to history if not already present
‚ãÆ----
// Potentially an update for a task we haven't seen the 'task' event for yet,
// or we are rehydrating. Attempt to load.
‚ãÆ----
// If it's a final status update, the ExecutionEventQueue will stop.
// The final result will be the currentTask.
‚ãÆ----
// Basic append logic, assuming parts are compatible
// More sophisticated merging might be needed for specific part types
‚ãÆ----
// Similar to status update, try to load if task not in memory
‚ãÆ----
// Apply artifact update logic (as above)
‚ãÆ----
private async saveCurrentTask(): Promise<void>
‚ãÆ----
/**
     * Gets the final result, which could be a Message or a Task.
     * This should be called after the event stream has been fully processed.
     * @returns The final Message or the current Task.
     */
public getFinalResult(): Message | Task | undefined
‚ãÆ----
/**
     * Gets the task currently being managed by this ResultManager instance.
     * This task could be one that was started with or one created during agent execution.
     * @returns The current Task or undefined if no task is active.
     */
public getCurrentTask(): Task | undefined

================
File: src/server/store.ts
================
import fs from "fs/promises";
import path from "path";
import {Task} from "../types.js";
import { A2AError } from "./error.js";
import {
  getCurrentTimestamp,
  isArtifactUpdate,
  isTaskStatusUpdate,
} from "./utils.js";
‚ãÆ----
/**
 * Simplified interface for task storage providers.
 * Stores and retrieves the task.
 */
export interface TaskStore {
  /**
   * Saves a task.
   * Overwrites existing data if the task ID exists.
   * @param data An object containing the task.
   * @returns A promise resolving when the save operation is complete.
   */
  save(task: Task): Promise<void>;

  /**
   * Loads a task by task ID.
   * @param taskId The ID of the task to load.
   * @returns A promise resolving to an object containing the Task, or undefined if not found.
   */
  load(taskId: string): Promise<Task | undefined>;
}
‚ãÆ----
/**
   * Saves a task.
   * Overwrites existing data if the task ID exists.
   * @param data An object containing the task.
   * @returns A promise resolving when the save operation is complete.
   */
save(task: Task): Promise<void>;
‚ãÆ----
/**
   * Loads a task by task ID.
   * @param taskId The ID of the task to load.
   * @returns A promise resolving to an object containing the Task, or undefined if not found.
   */
load(taskId: string): Promise<Task | undefined>;
‚ãÆ----
// ========================
// InMemoryTaskStore
// ========================
‚ãÆ----
// Use Task directly for storage
export class InMemoryTaskStore implements TaskStore
‚ãÆ----
async load(taskId: string): Promise<Task | undefined>
‚ãÆ----
// Return copies to prevent external mutation
‚ãÆ----
async save(task: Task): Promise<void>
‚ãÆ----
// Store copies to prevent internal mutation if caller reuses objects

================
File: src/server/utils.ts
================
import { TaskStatus, Artifact } from "../types.js";
‚ãÆ----
/**
 * Generates a timestamp in ISO 8601 format.
 * @returns The current timestamp as a string.
 */
export function getCurrentTimestamp(): string
‚ãÆ----
/**
 * Checks if a value is a plain object (excluding arrays and null).
 * @param value The value to check.
 * @returns True if the value is a plain object, false otherwise.
 */
export function isObject(value: unknown): value is Record<string, any>
‚ãÆ----
/**
 * Type guard to check if an object is a TaskStatus update (lacks 'parts').
 * Used to differentiate yielded updates from the handler.
 */
export function isTaskStatusUpdate(
  update: any // eslint-disable-line @typescript-eslint/no-explicit-any
): update is Omit<TaskStatus, "timestamp">
‚ãÆ----
update: any // eslint-disable-line @typescript-eslint/no-explicit-any
‚ãÆ----
// Check if it has 'state' and NOT 'parts' (which Artifacts have)
‚ãÆ----
/**
 * Type guard to check if an object is an Artifact update (has 'parts').
 * Used to differentiate yielded updates from the handler.
 */
export function isArtifactUpdate(
  update: any // eslint-disable-line @typescript-eslint/no-explicit-any
): update is Artifact
‚ãÆ----
update: any // eslint-disable-line @typescript-eslint/no-explicit-any
‚ãÆ----
// Check if it has 'parts'

================
File: src/a2a_response.ts
================
import { SendMessageResponse, SendStreamingMessageResponse, GetTaskResponse, CancelTaskResponse, SetTaskPushNotificationConfigResponse, GetTaskPushNotificationConfigResponse, JSONRPCErrorResponse, ListTaskPushNotificationConfigSuccessResponse, DeleteTaskPushNotificationConfigSuccessResponse, GetAuthenticatedExtendedCardSuccessResponse } from "./types.js";
‚ãÆ----
/**
 * Represents any valid JSON-RPC response defined in the A2A protocol.
 */
export type A2AResponse =
  | SendMessageResponse
  | SendStreamingMessageResponse
  | GetTaskResponse
  | CancelTaskResponse
  | SetTaskPushNotificationConfigResponse
  | GetTaskPushNotificationConfigResponse
  | ListTaskPushNotificationConfigSuccessResponse
  | DeleteTaskPushNotificationConfigSuccessResponse
  | GetAuthenticatedExtendedCardSuccessResponse
  | JSONRPCErrorResponse; // Catch-all for other error responses
‚ãÆ----
| JSONRPCErrorResponse; // Catch-all for other error responses

================
File: src/constants.ts
================
/**
 * Shared constants for the A2A library
 */
‚ãÆ----
/**
 * The well-known path for the agent card
 */

================
File: src/index.ts
================
/**
 * Main entry point for the A2A Server V2 library.
 * Exports the common types.
 */

================
File: src/types.ts
================
/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */
‚ãÆ----
/**
 * A discriminated union of all standard JSON-RPC and A2A-specific error types.
 *
 * This interface was referenced by `MySchema`'s JSON-Schema
 * via the `definition` "A2AError".
 */
export type A2AError =
  | JSONParseError
  | InvalidRequestError
  | MethodNotFoundError
  | InvalidParamsError
  | InternalError
  | TaskNotFoundError
  | TaskNotCancelableError
  | PushNotificationNotSupportedError
  | UnsupportedOperationError
  | ContentTypeNotSupportedError
  | InvalidAgentResponseError
  | AuthenticatedExtendedCardNotConfiguredError;
/**
 * A discriminated union representing all possible JSON-RPC 2.0 requests supported by the A2A specification.
 *
 * This interface was referenced by `MySchema`'s JSON-Schema
 * via the `definition` "A2ARequest".
 */
export type A2ARequest =
  | SendMessageRequest
  | SendStreamingMessageRequest
  | GetTaskRequest
  | CancelTaskRequest
  | SetTaskPushNotificationConfigRequest
  | GetTaskPushNotificationConfigRequest
  | TaskResubscriptionRequest
  | ListTaskPushNotificationConfigRequest
  | DeleteTaskPushNotificationConfigRequest
  | GetAuthenticatedExtendedCardRequest;
/**
 * A discriminated union representing a part of a message or artifact, which can
 * be text, a file, or structured data.
 *
 * This interface was referenced by `MySchema`'s JSON-Schema
 * via the `definition` "Part".
 */
export type Part = TextPart | FilePart | DataPart;
/**
 * Defines a security scheme that can be used to secure an agent's endpoints.
 * This is a discriminated union type based on the OpenAPI 3.0 Security Scheme Object.
 *
 * This interface was referenced by `MySchema`'s JSON-Schema
 * via the `definition` "SecurityScheme".
 */
export type SecurityScheme =
  | APIKeySecurityScheme
  | HTTPAuthSecurityScheme
  | OAuth2SecurityScheme
  | OpenIdConnectSecurityScheme
  | MutualTLSSecurityScheme;
/**
 * Represents a JSON-RPC response for the `tasks/cancel` method.
 *
 * This interface was referenced by `MySchema`'s JSON-Schema
 * via the `definition` "CancelTaskResponse".
 */
export type CancelTaskResponse = JSONRPCErrorResponse | CancelTaskSuccessResponse;
/**
 * Represents a JSON-RPC response for the `tasks/pushNotificationConfig/delete` method.
 *
 * This interface was referenced by `MySchema`'s JSON-Schema
 * via the `definition` "DeleteTaskPushNotificationConfigResponse".
 */
export type DeleteTaskPushNotificationConfigResponse =
  | JSONRPCErrorResponse
  | DeleteTaskPushNotificationConfigSuccessResponse;
/**
 * Represents a JSON-RPC response for the `agent/getAuthenticatedExtendedCard` method.
 *
 * This interface was referenced by `MySchema`'s JSON-Schema
 * via the `definition` "GetAuthenticatedExtendedCardResponse".
 */
export type GetAuthenticatedExtendedCardResponse = JSONRPCErrorResponse | GetAuthenticatedExtendedCardSuccessResponse;
/**
 * Represents a JSON-RPC response for the `tasks/pushNotificationConfig/get` method.
 *
 * This interface was referenced by `MySchema`'s JSON-Schema
 * via the `definition` "GetTaskPushNotificationConfigResponse".
 */
export type GetTaskPushNotificationConfigResponse = JSONRPCErrorResponse | GetTaskPushNotificationConfigSuccessResponse;
/**
 * Represents a JSON-RPC response for the `tasks/get` method.
 *
 * This interface was referenced by `MySchema`'s JSON-Schema
 * via the `definition` "GetTaskResponse".
 */
export type GetTaskResponse = JSONRPCErrorResponse | GetTaskSuccessResponse;
/**
 * A discriminated union representing all possible JSON-RPC 2.0 responses
 * for the A2A specification methods.
 *
 * This interface was referenced by `MySchema`'s JSON-Schema
 * via the `definition` "JSONRPCResponse".
 */
export type JSONRPCResponse =
  | JSONRPCErrorResponse
  | SendMessageSuccessResponse
  | SendStreamingMessageSuccessResponse
  | GetTaskSuccessResponse
  | CancelTaskSuccessResponse
  | SetTaskPushNotificationConfigSuccessResponse
  | GetTaskPushNotificationConfigSuccessResponse
  | ListTaskPushNotificationConfigSuccessResponse
  | DeleteTaskPushNotificationConfigSuccessResponse
  | GetAuthenticatedExtendedCardSuccessResponse;
/**
 * Represents a JSON-RPC response for the `tasks/pushNotificationConfig/list` method.
 *
 * This interface was referenced by `MySchema`'s JSON-Schema
 * via the `definition` "ListTaskPushNotificationConfigResponse".
 */
export type ListTaskPushNotificationConfigResponse =
  | JSONRPCErrorResponse
  | ListTaskPushNotificationConfigSuccessResponse;
/**
 * Represents a JSON-RPC response for the `message/send` method.
 *
 * This interface was referenced by `MySchema`'s JSON-Schema
 * via the `definition` "SendMessageResponse".
 */
export type SendMessageResponse = JSONRPCErrorResponse | SendMessageSuccessResponse;
/**
 * Represents a JSON-RPC response for the `message/stream` method.
 *
 * This interface was referenced by `MySchema`'s JSON-Schema
 * via the `definition` "SendStreamingMessageResponse".
 */
export type SendStreamingMessageResponse = JSONRPCErrorResponse | SendStreamingMessageSuccessResponse;
/**
 * Represents a JSON-RPC response for the `tasks/pushNotificationConfig/set` method.
 *
 * This interface was referenced by `MySchema`'s JSON-Schema
 * via the `definition` "SetTaskPushNotificationConfigResponse".
 */
export type SetTaskPushNotificationConfigResponse = JSONRPCErrorResponse | SetTaskPushNotificationConfigSuccessResponse;
/**
 * Defines the lifecycle states of a Task.
 *
 * This interface was referenced by `MySchema`'s JSON-Schema
 * via the `definition` "TaskState".
 */
export type TaskState =
  | "submitted"
  | "working"
  | "input-required"
  | "completed"
  | "canceled"
  | "failed"
  | "rejected"
  | "auth-required"
  | "unknown";
/**
 * Supported A2A transport protocols.
 *
 * This interface was referenced by `MySchema`'s JSON-Schema
 * via the `definition` "TransportProtocol".
 */
export type TransportProtocol = "JSONRPC" | "GRPC" | "HTTP+JSON";
‚ãÆ----
export interface MySchema {
  [k: string]: unknown;
}
/**
 * An error indicating that the server received invalid JSON.
 *
 * This interface was referenced by `MySchema`'s JSON-Schema
 * via the `definition` "JSONParseError".
 */
export interface JSONParseError {
  /**
   * The error code for a JSON parse error.
   */
  code: -32700;
  /**
   * A primitive or structured value containing additional information about the error.
   * This may be omitted.
   */
  data?: {
    [k: string]: unknown;
  };
  /**
   * The error message.
   */
  message: string;
}
‚ãÆ----
/**
   * The error code for a JSON parse error.
   */
‚ãÆ----
/**
   * A primitive or structured value containing additional information about the error.
   * This may be omitted.
   */
‚ãÆ----
/**
   * The error message.
   */
‚ãÆ----
/**
 * An error indicating that the JSON sent is not a valid Request object.
 *
 * This interface was referenced by `MySchema`'s JSON-Schema
 * via the `definition` "InvalidRequestError".
 */
export interface InvalidRequestError {
  /**
   * The error code for an invalid request.
   */
  code: -32600;
  /**
   * A primitive or structured value containing additional information about the error.
   * This may be omitted.
   */
  data?: {
    [k: string]: unknown;
  };
  /**
   * The error message.
   */
  message: string;
}
‚ãÆ----
/**
   * The error code for an invalid request.
   */
‚ãÆ----
/**
   * A primitive or structured value containing additional information about the error.
   * This may be omitted.
   */
‚ãÆ----
/**
   * The error message.
   */
‚ãÆ----
/**
 * An error indicating that the requested method does not exist or is not available.
 *
 * This interface was referenced by `MySchema`'s JSON-Schema
 * via the `definition` "MethodNotFoundError".
 */
export interface MethodNotFoundError {
  /**
   * The error code for a method not found error.
   */
  code: -32601;
  /**
   * A primitive or structured value containing additional information about the error.
   * This may be omitted.
   */
  data?: {
    [k: string]: unknown;
  };
  /**
   * The error message.
   */
  message: string;
}
‚ãÆ----
/**
   * The error code for a method not found error.
   */
‚ãÆ----
/**
   * A primitive or structured value containing additional information about the error.
   * This may be omitted.
   */
‚ãÆ----
/**
   * The error message.
   */
‚ãÆ----
/**
 * An error indicating that the method parameters are invalid.
 *
 * This interface was referenced by `MySchema`'s JSON-Schema
 * via the `definition` "InvalidParamsError".
 */
export interface InvalidParamsError {
  /**
   * The error code for an invalid parameters error.
   */
  code: -32602;
  /**
   * A primitive or structured value containing additional information about the error.
   * This may be omitted.
   */
  data?: {
    [k: string]: unknown;
  };
  /**
   * The error message.
   */
  message: string;
}
‚ãÆ----
/**
   * The error code for an invalid parameters error.
   */
‚ãÆ----
/**
   * A primitive or structured value containing additional information about the error.
   * This may be omitted.
   */
‚ãÆ----
/**
   * The error message.
   */
‚ãÆ----
/**
 * An error indicating an internal error on the server.
 *
 * This interface was referenced by `MySchema`'s JSON-Schema
 * via the `definition` "InternalError".
 */
export interface InternalError {
  /**
   * The error code for an internal server error.
   */
  code: -32603;
  /**
   * A primitive or structured value containing additional information about the error.
   * This may be omitted.
   */
  data?: {
    [k: string]: unknown;
  };
  /**
   * The error message.
   */
  message: string;
}
‚ãÆ----
/**
   * The error code for an internal server error.
   */
‚ãÆ----
/**
   * A primitive or structured value containing additional information about the error.
   * This may be omitted.
   */
‚ãÆ----
/**
   * The error message.
   */
‚ãÆ----
/**
 * An A2A-specific error indicating that the requested task ID was not found.
 *
 * This interface was referenced by `MySchema`'s JSON-Schema
 * via the `definition` "TaskNotFoundError".
 */
export interface TaskNotFoundError {
  /**
   * The error code for a task not found error.
   */
  code: -32001;
  /**
   * A primitive or structured value containing additional information about the error.
   * This may be omitted.
   */
  data?: {
    [k: string]: unknown;
  };
  /**
   * The error message.
   */
  message: string;
}
‚ãÆ----
/**
   * The error code for a task not found error.
   */
‚ãÆ----
/**
   * A primitive or structured value containing additional information about the error.
   * This may be omitted.
   */
‚ãÆ----
/**
   * The error message.
   */
‚ãÆ----
/**
 * An A2A-specific error indicating that the task is in a state where it cannot be canceled.
 *
 * This interface was referenced by `MySchema`'s JSON-Schema
 * via the `definition` "TaskNotCancelableError".
 */
export interface TaskNotCancelableError {
  /**
   * The error code for a task that cannot be canceled.
   */
  code: -32002;
  /**
   * A primitive or structured value containing additional information about the error.
   * This may be omitted.
   */
  data?: {
    [k: string]: unknown;
  };
  /**
   * The error message.
   */
  message: string;
}
‚ãÆ----
/**
   * The error code for a task that cannot be canceled.
   */
‚ãÆ----
/**
   * A primitive or structured value containing additional information about the error.
   * This may be omitted.
   */
‚ãÆ----
/**
   * The error message.
   */
‚ãÆ----
/**
 * An A2A-specific error indicating that the agent does not support push notifications.
 *
 * This interface was referenced by `MySchema`'s JSON-Schema
 * via the `definition` "PushNotificationNotSupportedError".
 */
export interface PushNotificationNotSupportedError {
  /**
   * The error code for when push notifications are not supported.
   */
  code: -32003;
  /**
   * A primitive or structured value containing additional information about the error.
   * This may be omitted.
   */
  data?: {
    [k: string]: unknown;
  };
  /**
   * The error message.
   */
  message: string;
}
‚ãÆ----
/**
   * The error code for when push notifications are not supported.
   */
‚ãÆ----
/**
   * A primitive or structured value containing additional information about the error.
   * This may be omitted.
   */
‚ãÆ----
/**
   * The error message.
   */
‚ãÆ----
/**
 * An A2A-specific error indicating that the requested operation is not supported by the agent.
 *
 * This interface was referenced by `MySchema`'s JSON-Schema
 * via the `definition` "UnsupportedOperationError".
 */
export interface UnsupportedOperationError {
  /**
   * The error code for an unsupported operation.
   */
  code: -32004;
  /**
   * A primitive or structured value containing additional information about the error.
   * This may be omitted.
   */
  data?: {
    [k: string]: unknown;
  };
  /**
   * The error message.
   */
  message: string;
}
‚ãÆ----
/**
   * The error code for an unsupported operation.
   */
‚ãÆ----
/**
   * A primitive or structured value containing additional information about the error.
   * This may be omitted.
   */
‚ãÆ----
/**
   * The error message.
   */
‚ãÆ----
/**
 * An A2A-specific error indicating an incompatibility between the requested
 * content types and the agent's capabilities.
 *
 * This interface was referenced by `MySchema`'s JSON-Schema
 * via the `definition` "ContentTypeNotSupportedError".
 */
export interface ContentTypeNotSupportedError {
  /**
   * The error code for an unsupported content type.
   */
  code: -32005;
  /**
   * A primitive or structured value containing additional information about the error.
   * This may be omitted.
   */
  data?: {
    [k: string]: unknown;
  };
  /**
   * The error message.
   */
  message: string;
}
‚ãÆ----
/**
   * The error code for an unsupported content type.
   */
‚ãÆ----
/**
   * A primitive or structured value containing additional information about the error.
   * This may be omitted.
   */
‚ãÆ----
/**
   * The error message.
   */
‚ãÆ----
/**
 * An A2A-specific error indicating that the agent returned a response that
 * does not conform to the specification for the current method.
 *
 * This interface was referenced by `MySchema`'s JSON-Schema
 * via the `definition` "InvalidAgentResponseError".
 */
export interface InvalidAgentResponseError {
  /**
   * The error code for an invalid agent response.
   */
  code: -32006;
  /**
   * A primitive or structured value containing additional information about the error.
   * This may be omitted.
   */
  data?: {
    [k: string]: unknown;
  };
  /**
   * The error message.
   */
  message: string;
}
‚ãÆ----
/**
   * The error code for an invalid agent response.
   */
‚ãÆ----
/**
   * A primitive or structured value containing additional information about the error.
   * This may be omitted.
   */
‚ãÆ----
/**
   * The error message.
   */
‚ãÆ----
/**
 * An A2A-specific error indicating that the agent does not have an Authenticated Extended Card configured
 *
 * This interface was referenced by `MySchema`'s JSON-Schema
 * via the `definition` "AuthenticatedExtendedCardNotConfiguredError".
 */
export interface AuthenticatedExtendedCardNotConfiguredError {
  /**
   * The error code for when an authenticated extended card is not configured.
   */
  code: -32007;
  /**
   * A primitive or structured value containing additional information about the error.
   * This may be omitted.
   */
  data?: {
    [k: string]: unknown;
  };
  /**
   * The error message.
   */
  message: string;
}
‚ãÆ----
/**
   * The error code for when an authenticated extended card is not configured.
   */
‚ãÆ----
/**
   * A primitive or structured value containing additional information about the error.
   * This may be omitted.
   */
‚ãÆ----
/**
   * The error message.
   */
‚ãÆ----
/**
 * Represents a JSON-RPC request for the `message/send` method.
 *
 * This interface was referenced by `MySchema`'s JSON-Schema
 * via the `definition` "SendMessageRequest".
 */
export interface SendMessageRequest {
  /**
   * The identifier for this request.
   */
  id: string | number;
  /**
   * The version of the JSON-RPC protocol. MUST be exactly "2.0".
   */
  jsonrpc: "2.0";
  /**
   * The method name. Must be 'message/send'.
   */
  method: "message/send";
  params: MessageSendParams;
}
‚ãÆ----
/**
   * The identifier for this request.
   */
‚ãÆ----
/**
   * The version of the JSON-RPC protocol. MUST be exactly "2.0".
   */
‚ãÆ----
/**
   * The method name. Must be 'message/send'.
   */
‚ãÆ----
/**
 * The parameters for sending a message.
 */
export interface MessageSendParams {
  configuration?: MessageSendConfiguration;
  message: Message;
  /**
   * Optional metadata for extensions.
   */
  metadata?: {
    [k: string]: unknown;
  };
}
‚ãÆ----
/**
   * Optional metadata for extensions.
   */
‚ãÆ----
/**
 * Optional configuration for the send request.
 */
export interface MessageSendConfiguration {
  /**
   * A list of output MIME types the client is prepared to accept in the response.
   */
  acceptedOutputModes?: string[];
  /**
   * If true, the client will wait for the task to complete. The server may reject this if the task is long-running.
   */
  blocking?: boolean;
  /**
   * The number of most recent messages from the task's history to retrieve in the response.
   */
  historyLength?: number;
  pushNotificationConfig?: PushNotificationConfig;
}
‚ãÆ----
/**
   * A list of output MIME types the client is prepared to accept in the response.
   */
‚ãÆ----
/**
   * If true, the client will wait for the task to complete. The server may reject this if the task is long-running.
   */
‚ãÆ----
/**
   * The number of most recent messages from the task's history to retrieve in the response.
   */
‚ãÆ----
/**
 * Configuration for the agent to send push notifications for updates after the initial response.
 */
export interface PushNotificationConfig {
  authentication?: PushNotificationAuthenticationInfo;
  /**
   * A unique ID for the push notification configuration, set by the client
   * to support multiple notification callbacks.
   */
  id?: string;
  /**
   * A unique token for this task or session to validate incoming push notifications.
   */
  token?: string;
  /**
   * The callback URL where the agent should send push notifications.
   */
  url: string;
}
‚ãÆ----
/**
   * A unique ID for the push notification configuration, set by the client
   * to support multiple notification callbacks.
   */
‚ãÆ----
/**
   * A unique token for this task or session to validate incoming push notifications.
   */
‚ãÆ----
/**
   * The callback URL where the agent should send push notifications.
   */
‚ãÆ----
/**
 * Optional authentication details for the agent to use when calling the notification URL.
 */
export interface PushNotificationAuthenticationInfo {
  /**
   * Optional credentials required by the push notification endpoint.
   */
  credentials?: string;
  /**
   * A list of supported authentication schemes (e.g., 'Basic', 'Bearer').
   */
  schemes: string[];
}
‚ãÆ----
/**
   * Optional credentials required by the push notification endpoint.
   */
‚ãÆ----
/**
   * A list of supported authentication schemes (e.g., 'Basic', 'Bearer').
   */
‚ãÆ----
/**
 * The message object being sent to the agent.
 */
export interface Message {
  /**
   * The context identifier for this message, used to group related interactions.
   */
  contextId?: string;
  /**
   * The URIs of extensions that are relevant to this message.
   */
  extensions?: string[];
  /**
   * The type of this object, used as a discriminator. Always 'message' for a Message.
   */
  kind: "message";
  /**
   * A unique identifier for the message, typically a UUID, generated by the sender.
   */
  messageId: string;
  /**
   * Optional metadata for extensions. The key is an extension-specific identifier.
   */
  metadata?: {
    [k: string]: unknown;
  };
  /**
   * An array of content parts that form the message body. A message can be
   * composed of multiple parts of different types (e.g., text and files).
   */
  parts: Part[];
  /**
   * A list of other task IDs that this message references for additional context.
   */
  referenceTaskIds?: string[];
  /**
   * Identifies the sender of the message. `user` for the client, `agent` for the service.
   */
  role: "agent" | "user";
  /**
   * The identifier of the task this message is part of. Can be omitted for the first message of a new task.
   */
  taskId?: string;
}
‚ãÆ----
/**
   * The context identifier for this message, used to group related interactions.
   */
‚ãÆ----
/**
   * The URIs of extensions that are relevant to this message.
   */
‚ãÆ----
/**
   * The type of this object, used as a discriminator. Always 'message' for a Message.
   */
‚ãÆ----
/**
   * A unique identifier for the message, typically a UUID, generated by the sender.
   */
‚ãÆ----
/**
   * Optional metadata for extensions. The key is an extension-specific identifier.
   */
‚ãÆ----
/**
   * An array of content parts that form the message body. A message can be
   * composed of multiple parts of different types (e.g., text and files).
   */
‚ãÆ----
/**
   * A list of other task IDs that this message references for additional context.
   */
‚ãÆ----
/**
   * Identifies the sender of the message. `user` for the client, `agent` for the service.
   */
‚ãÆ----
/**
   * The identifier of the task this message is part of. Can be omitted for the first message of a new task.
   */
‚ãÆ----
/**
 * Represents a text segment within a message or artifact.
 *
 * This interface was referenced by `MySchema`'s JSON-Schema
 * via the `definition` "TextPart".
 */
export interface TextPart {
  /**
   * The type of this part, used as a discriminator. Always 'text'.
   */
  kind: "text";
  /**
   * Optional metadata associated with this part.
   */
  metadata?: {
    [k: string]: unknown;
  };
  /**
   * The string content of the text part.
   */
  text: string;
}
‚ãÆ----
/**
   * The type of this part, used as a discriminator. Always 'text'.
   */
‚ãÆ----
/**
   * Optional metadata associated with this part.
   */
‚ãÆ----
/**
   * The string content of the text part.
   */
‚ãÆ----
/**
 * Represents a file segment within a message or artifact. The file content can be
 * provided either directly as bytes or as a URI.
 *
 * This interface was referenced by `MySchema`'s JSON-Schema
 * via the `definition` "FilePart".
 */
export interface FilePart {
  /**
   * The file content, represented as either a URI or as base64-encoded bytes.
   */
  file: FileWithBytes | FileWithUri;
  /**
   * The type of this part, used as a discriminator. Always 'file'.
   */
  kind: "file";
  /**
   * Optional metadata associated with this part.
   */
  metadata?: {
    [k: string]: unknown;
  };
}
‚ãÆ----
/**
   * The file content, represented as either a URI or as base64-encoded bytes.
   */
‚ãÆ----
/**
   * The type of this part, used as a discriminator. Always 'file'.
   */
‚ãÆ----
/**
   * Optional metadata associated with this part.
   */
‚ãÆ----
/**
 * Represents a file with its content provided directly as a base64-encoded string.
 *
 * This interface was referenced by `MySchema`'s JSON-Schema
 * via the `definition` "FileWithBytes".
 */
export interface FileWithBytes {
  /**
   * The base64-encoded content of the file.
   */
  bytes: string;
  /**
   * The MIME type of the file (e.g., "application/pdf").
   */
  mimeType?: string;
  /**
   * An optional name for the file (e.g., "document.pdf").
   */
  name?: string;
}
‚ãÆ----
/**
   * The base64-encoded content of the file.
   */
‚ãÆ----
/**
   * The MIME type of the file (e.g., "application/pdf").
   */
‚ãÆ----
/**
   * An optional name for the file (e.g., "document.pdf").
   */
‚ãÆ----
/**
 * Represents a file with its content located at a specific URI.
 *
 * This interface was referenced by `MySchema`'s JSON-Schema
 * via the `definition` "FileWithUri".
 */
export interface FileWithUri {
  /**
   * The MIME type of the file (e.g., "application/pdf").
   */
  mimeType?: string;
  /**
   * An optional name for the file (e.g., "document.pdf").
   */
  name?: string;
  /**
   * A URL pointing to the file's content.
   */
  uri: string;
}
‚ãÆ----
/**
   * The MIME type of the file (e.g., "application/pdf").
   */
‚ãÆ----
/**
   * An optional name for the file (e.g., "document.pdf").
   */
‚ãÆ----
/**
   * A URL pointing to the file's content.
   */
‚ãÆ----
/**
 * Represents a structured data segment (e.g., JSON) within a message or artifact.
 *
 * This interface was referenced by `MySchema`'s JSON-Schema
 * via the `definition` "DataPart".
 */
export interface DataPart {
  /**
   * The structured data content.
   */
  data: {
    [k: string]: unknown;
  };
  /**
   * The type of this part, used as a discriminator. Always 'data'.
   */
  kind: "data";
  /**
   * Optional metadata associated with this part.
   */
  metadata?: {
    [k: string]: unknown;
  };
}
‚ãÆ----
/**
   * The structured data content.
   */
‚ãÆ----
/**
   * The type of this part, used as a discriminator. Always 'data'.
   */
‚ãÆ----
/**
   * Optional metadata associated with this part.
   */
‚ãÆ----
/**
 * Represents a JSON-RPC request for the `message/stream` method.
 *
 * This interface was referenced by `MySchema`'s JSON-Schema
 * via the `definition` "SendStreamingMessageRequest".
 */
export interface SendStreamingMessageRequest {
  /**
   * The identifier for this request.
   */
  id: string | number;
  /**
   * The version of the JSON-RPC protocol. MUST be exactly "2.0".
   */
  jsonrpc: "2.0";
  /**
   * The method name. Must be 'message/stream'.
   */
  method: "message/stream";
  params: MessageSendParams1;
}
‚ãÆ----
/**
   * The identifier for this request.
   */
‚ãÆ----
/**
   * The version of the JSON-RPC protocol. MUST be exactly "2.0".
   */
‚ãÆ----
/**
   * The method name. Must be 'message/stream'.
   */
‚ãÆ----
/**
 * The parameters for sending a message.
 */
export interface MessageSendParams1 {
  configuration?: MessageSendConfiguration;
  message: Message;
  /**
   * Optional metadata for extensions.
   */
  metadata?: {
    [k: string]: unknown;
  };
}
‚ãÆ----
/**
   * Optional metadata for extensions.
   */
‚ãÆ----
/**
 * Represents a JSON-RPC request for the `tasks/get` method.
 *
 * This interface was referenced by `MySchema`'s JSON-Schema
 * via the `definition` "GetTaskRequest".
 */
export interface GetTaskRequest {
  /**
   * The identifier for this request.
   */
  id: string | number;
  /**
   * The version of the JSON-RPC protocol. MUST be exactly "2.0".
   */
  jsonrpc: "2.0";
  /**
   * The method name. Must be 'tasks/get'.
   */
  method: "tasks/get";
  params: TaskQueryParams;
}
‚ãÆ----
/**
   * The identifier for this request.
   */
‚ãÆ----
/**
   * The version of the JSON-RPC protocol. MUST be exactly "2.0".
   */
‚ãÆ----
/**
   * The method name. Must be 'tasks/get'.
   */
‚ãÆ----
/**
 * The parameters for querying a task.
 */
export interface TaskQueryParams {
  /**
   * The number of most recent messages from the task's history to retrieve.
   */
  historyLength?: number;
  /**
   * The unique identifier of the task.
   */
  id: string;
  /**
   * Optional metadata associated with the request.
   */
  metadata?: {
    [k: string]: unknown;
  };
}
‚ãÆ----
/**
   * The number of most recent messages from the task's history to retrieve.
   */
‚ãÆ----
/**
   * The unique identifier of the task.
   */
‚ãÆ----
/**
   * Optional metadata associated with the request.
   */
‚ãÆ----
/**
 * Represents a JSON-RPC request for the `tasks/cancel` method.
 *
 * This interface was referenced by `MySchema`'s JSON-Schema
 * via the `definition` "CancelTaskRequest".
 */
export interface CancelTaskRequest {
  /**
   * The identifier for this request.
   */
  id: string | number;
  /**
   * The version of the JSON-RPC protocol. MUST be exactly "2.0".
   */
  jsonrpc: "2.0";
  /**
   * The method name. Must be 'tasks/cancel'.
   */
  method: "tasks/cancel";
  params: TaskIdParams;
}
‚ãÆ----
/**
   * The identifier for this request.
   */
‚ãÆ----
/**
   * The version of the JSON-RPC protocol. MUST be exactly "2.0".
   */
‚ãÆ----
/**
   * The method name. Must be 'tasks/cancel'.
   */
‚ãÆ----
/**
 * The parameters identifying the task to cancel.
 */
export interface TaskIdParams {
  /**
   * The unique identifier of the task.
   */
  id: string;
  /**
   * Optional metadata associated with the request.
   */
  metadata?: {
    [k: string]: unknown;
  };
}
‚ãÆ----
/**
   * The unique identifier of the task.
   */
‚ãÆ----
/**
   * Optional metadata associated with the request.
   */
‚ãÆ----
/**
 * Represents a JSON-RPC request for the `tasks/pushNotificationConfig/set` method.
 *
 * This interface was referenced by `MySchema`'s JSON-Schema
 * via the `definition` "SetTaskPushNotificationConfigRequest".
 */
export interface SetTaskPushNotificationConfigRequest {
  /**
   * The identifier for this request.
   */
  id: string | number;
  /**
   * The version of the JSON-RPC protocol. MUST be exactly "2.0".
   */
  jsonrpc: "2.0";
  /**
   * The method name. Must be 'tasks/pushNotificationConfig/set'.
   */
  method: "tasks/pushNotificationConfig/set";
  params: TaskPushNotificationConfig;
}
‚ãÆ----
/**
   * The identifier for this request.
   */
‚ãÆ----
/**
   * The version of the JSON-RPC protocol. MUST be exactly "2.0".
   */
‚ãÆ----
/**
   * The method name. Must be 'tasks/pushNotificationConfig/set'.
   */
‚ãÆ----
/**
 * The parameters for setting the push notification configuration.
 */
export interface TaskPushNotificationConfig {
  pushNotificationConfig: PushNotificationConfig1;
  /**
   * The ID of the task.
   */
  taskId: string;
}
‚ãÆ----
/**
   * The ID of the task.
   */
‚ãÆ----
/**
 * The push notification configuration for this task.
 */
export interface PushNotificationConfig1 {
  authentication?: PushNotificationAuthenticationInfo;
  /**
   * A unique ID for the push notification configuration, set by the client
   * to support multiple notification callbacks.
   */
  id?: string;
  /**
   * A unique token for this task or session to validate incoming push notifications.
   */
  token?: string;
  /**
   * The callback URL where the agent should send push notifications.
   */
  url: string;
}
‚ãÆ----
/**
   * A unique ID for the push notification configuration, set by the client
   * to support multiple notification callbacks.
   */
‚ãÆ----
/**
   * A unique token for this task or session to validate incoming push notifications.
   */
‚ãÆ----
/**
   * The callback URL where the agent should send push notifications.
   */
‚ãÆ----
/**
 * Represents a JSON-RPC request for the `tasks/pushNotificationConfig/get` method.
 *
 * This interface was referenced by `MySchema`'s JSON-Schema
 * via the `definition` "GetTaskPushNotificationConfigRequest".
 */
export interface GetTaskPushNotificationConfigRequest {
  /**
   * The identifier for this request.
   */
  id: string | number;
  /**
   * The version of the JSON-RPC protocol. MUST be exactly "2.0".
   */
  jsonrpc: "2.0";
  /**
   * The method name. Must be 'tasks/pushNotificationConfig/get'.
   */
  method: "tasks/pushNotificationConfig/get";
  /**
   * The parameters for getting a push notification configuration.
   */
  params: TaskIdParams1 | GetTaskPushNotificationConfigParams;
}
‚ãÆ----
/**
   * The identifier for this request.
   */
‚ãÆ----
/**
   * The version of the JSON-RPC protocol. MUST be exactly "2.0".
   */
‚ãÆ----
/**
   * The method name. Must be 'tasks/pushNotificationConfig/get'.
   */
‚ãÆ----
/**
   * The parameters for getting a push notification configuration.
   */
‚ãÆ----
/**
 * Defines parameters containing a task ID, used for simple task operations.
 *
 * This interface was referenced by `MySchema`'s JSON-Schema
 * via the `definition` "TaskIdParams".
 */
export interface TaskIdParams1 {
  /**
   * The unique identifier of the task.
   */
  id: string;
  /**
   * Optional metadata associated with the request.
   */
  metadata?: {
    [k: string]: unknown;
  };
}
‚ãÆ----
/**
   * The unique identifier of the task.
   */
‚ãÆ----
/**
   * Optional metadata associated with the request.
   */
‚ãÆ----
/**
 * Defines parameters for fetching a specific push notification configuration for a task.
 *
 * This interface was referenced by `MySchema`'s JSON-Schema
 * via the `definition` "GetTaskPushNotificationConfigParams".
 */
export interface GetTaskPushNotificationConfigParams {
  /**
   * The unique identifier of the task.
   */
  id: string;
  /**
   * Optional metadata associated with the request.
   */
  metadata?: {
    [k: string]: unknown;
  };
  /**
   * The ID of the push notification configuration to retrieve.
   */
  pushNotificationConfigId?: string;
}
‚ãÆ----
/**
   * The unique identifier of the task.
   */
‚ãÆ----
/**
   * Optional metadata associated with the request.
   */
‚ãÆ----
/**
   * The ID of the push notification configuration to retrieve.
   */
‚ãÆ----
/**
 * Represents a JSON-RPC request for the `tasks/resubscribe` method, used to resume a streaming connection.
 *
 * This interface was referenced by `MySchema`'s JSON-Schema
 * via the `definition` "TaskResubscriptionRequest".
 */
export interface TaskResubscriptionRequest {
  /**
   * The identifier for this request.
   */
  id: string | number;
  /**
   * The version of the JSON-RPC protocol. MUST be exactly "2.0".
   */
  jsonrpc: "2.0";
  /**
   * The method name. Must be 'tasks/resubscribe'.
   */
  method: "tasks/resubscribe";
  params: TaskIdParams2;
}
‚ãÆ----
/**
   * The identifier for this request.
   */
‚ãÆ----
/**
   * The version of the JSON-RPC protocol. MUST be exactly "2.0".
   */
‚ãÆ----
/**
   * The method name. Must be 'tasks/resubscribe'.
   */
‚ãÆ----
/**
 * Defines parameters containing a task ID, used for simple task operations.
 */
export interface TaskIdParams2 {
  /**
   * The unique identifier of the task.
   */
  id: string;
  /**
   * Optional metadata associated with the request.
   */
  metadata?: {
    [k: string]: unknown;
  };
}
‚ãÆ----
/**
   * The unique identifier of the task.
   */
‚ãÆ----
/**
   * Optional metadata associated with the request.
   */
‚ãÆ----
/**
 * Represents a JSON-RPC request for the `tasks/pushNotificationConfig/list` method.
 *
 * This interface was referenced by `MySchema`'s JSON-Schema
 * via the `definition` "ListTaskPushNotificationConfigRequest".
 */
export interface ListTaskPushNotificationConfigRequest {
  /**
   * The identifier for this request.
   */
  id: string | number;
  /**
   * The version of the JSON-RPC protocol. MUST be exactly "2.0".
   */
  jsonrpc: "2.0";
  /**
   * The method name. Must be 'tasks/pushNotificationConfig/list'.
   */
  method: "tasks/pushNotificationConfig/list";
  params: ListTaskPushNotificationConfigParams;
}
‚ãÆ----
/**
   * The identifier for this request.
   */
‚ãÆ----
/**
   * The version of the JSON-RPC protocol. MUST be exactly "2.0".
   */
‚ãÆ----
/**
   * The method name. Must be 'tasks/pushNotificationConfig/list'.
   */
‚ãÆ----
/**
 * The parameters identifying the task whose configurations are to be listed.
 */
export interface ListTaskPushNotificationConfigParams {
  /**
   * The unique identifier of the task.
   */
  id: string;
  /**
   * Optional metadata associated with the request.
   */
  metadata?: {
    [k: string]: unknown;
  };
}
‚ãÆ----
/**
   * The unique identifier of the task.
   */
‚ãÆ----
/**
   * Optional metadata associated with the request.
   */
‚ãÆ----
/**
 * Represents a JSON-RPC request for the `tasks/pushNotificationConfig/delete` method.
 *
 * This interface was referenced by `MySchema`'s JSON-Schema
 * via the `definition` "DeleteTaskPushNotificationConfigRequest".
 */
export interface DeleteTaskPushNotificationConfigRequest {
  /**
   * The identifier for this request.
   */
  id: string | number;
  /**
   * The version of the JSON-RPC protocol. MUST be exactly "2.0".
   */
  jsonrpc: "2.0";
  /**
   * The method name. Must be 'tasks/pushNotificationConfig/delete'.
   */
  method: "tasks/pushNotificationConfig/delete";
  params: DeleteTaskPushNotificationConfigParams;
}
‚ãÆ----
/**
   * The identifier for this request.
   */
‚ãÆ----
/**
   * The version of the JSON-RPC protocol. MUST be exactly "2.0".
   */
‚ãÆ----
/**
   * The method name. Must be 'tasks/pushNotificationConfig/delete'.
   */
‚ãÆ----
/**
 * The parameters identifying the push notification configuration to delete.
 */
export interface DeleteTaskPushNotificationConfigParams {
  /**
   * The unique identifier of the task.
   */
  id: string;
  /**
   * Optional metadata associated with the request.
   */
  metadata?: {
    [k: string]: unknown;
  };
  /**
   * The ID of the push notification configuration to delete.
   */
  pushNotificationConfigId: string;
}
‚ãÆ----
/**
   * The unique identifier of the task.
   */
‚ãÆ----
/**
   * Optional metadata associated with the request.
   */
‚ãÆ----
/**
   * The ID of the push notification configuration to delete.
   */
‚ãÆ----
/**
 * Represents a JSON-RPC request for the `agent/getAuthenticatedExtendedCard` method.
 *
 * This interface was referenced by `MySchema`'s JSON-Schema
 * via the `definition` "GetAuthenticatedExtendedCardRequest".
 */
export interface GetAuthenticatedExtendedCardRequest {
  /**
   * The identifier for this request.
   */
  id: string | number;
  /**
   * The version of the JSON-RPC protocol. MUST be exactly "2.0".
   */
  jsonrpc: "2.0";
  /**
   * The method name. Must be 'agent/getAuthenticatedExtendedCard'.
   */
  method: "agent/getAuthenticatedExtendedCard";
}
‚ãÆ----
/**
   * The identifier for this request.
   */
‚ãÆ----
/**
   * The version of the JSON-RPC protocol. MUST be exactly "2.0".
   */
‚ãÆ----
/**
   * The method name. Must be 'agent/getAuthenticatedExtendedCard'.
   */
‚ãÆ----
/**
 * Defines a security scheme using an API key.
 *
 * This interface was referenced by `MySchema`'s JSON-Schema
 * via the `definition` "APIKeySecurityScheme".
 */
export interface APIKeySecurityScheme {
  /**
   * An optional description for the security scheme.
   */
  description?: string;
  /**
   * The location of the API key.
   */
  in: "cookie" | "header" | "query";
  /**
   * The name of the header, query, or cookie parameter to be used.
   */
  name: string;
  /**
   * The type of the security scheme. Must be 'apiKey'.
   */
  type: "apiKey";
}
‚ãÆ----
/**
   * An optional description for the security scheme.
   */
‚ãÆ----
/**
   * The location of the API key.
   */
‚ãÆ----
/**
   * The name of the header, query, or cookie parameter to be used.
   */
‚ãÆ----
/**
   * The type of the security scheme. Must be 'apiKey'.
   */
‚ãÆ----
/**
 * Defines optional capabilities supported by an agent.
 *
 * This interface was referenced by `MySchema`'s JSON-Schema
 * via the `definition` "AgentCapabilities".
 */
export interface AgentCapabilities {
  /**
   * A list of protocol extensions supported by the agent.
   */
  extensions?: AgentExtension[];
  /**
   * Indicates if the agent supports sending push notifications for asynchronous task updates.
   */
  pushNotifications?: boolean;
  /**
   * Indicates if the agent provides a history of state transitions for a task.
   */
  stateTransitionHistory?: boolean;
  /**
   * Indicates if the agent supports Server-Sent Events (SSE) for streaming responses.
   */
  streaming?: boolean;
}
‚ãÆ----
/**
   * A list of protocol extensions supported by the agent.
   */
‚ãÆ----
/**
   * Indicates if the agent supports sending push notifications for asynchronous task updates.
   */
‚ãÆ----
/**
   * Indicates if the agent provides a history of state transitions for a task.
   */
‚ãÆ----
/**
   * Indicates if the agent supports Server-Sent Events (SSE) for streaming responses.
   */
‚ãÆ----
/**
 * A declaration of a protocol extension supported by an Agent.
 *
 * This interface was referenced by `MySchema`'s JSON-Schema
 * via the `definition` "AgentExtension".
 */
export interface AgentExtension {
  /**
   * A human-readable description of how this agent uses the extension.
   */
  description?: string;
  /**
   * Optional, extension-specific configuration parameters.
   */
  params?: {
    [k: string]: unknown;
  };
  /**
   * If true, the client must understand and comply with the extension's requirements
   * to interact with the agent.
   */
  required?: boolean;
  /**
   * The unique URI identifying the extension.
   */
  uri: string;
}
‚ãÆ----
/**
   * A human-readable description of how this agent uses the extension.
   */
‚ãÆ----
/**
   * Optional, extension-specific configuration parameters.
   */
‚ãÆ----
/**
   * If true, the client must understand and comply with the extension's requirements
   * to interact with the agent.
   */
‚ãÆ----
/**
   * The unique URI identifying the extension.
   */
‚ãÆ----
/**
 * The AgentCard is a self-describing manifest for an agent. It provides essential
 * metadata including the agent's identity, capabilities, skills, supported
 * communication methods, and security requirements.
 *
 * This interface was referenced by `MySchema`'s JSON-Schema
 * via the `definition` "AgentCard".
 */
export interface AgentCard {
  /**
   * A list of additional supported interfaces (transport and URL combinations).
   * This allows agents to expose multiple transports, potentially at different URLs.
   *
   * Best practices:
   * - SHOULD include all supported transports for completeness
   * - SHOULD include an entry matching the main 'url' and 'preferredTransport'
   * - MAY reuse URLs if multiple transports are available at the same endpoint
   * - MUST accurately declare the transport available at each URL
   *
   * Clients can select any interface from this list based on their transport capabilities
   * and preferences. This enables transport negotiation and fallback scenarios.
   */
  additionalInterfaces?: AgentInterface[];
  capabilities: AgentCapabilities1;
  /**
   * Default set of supported input MIME types for all skills, which can be
   * overridden on a per-skill basis.
   */
  defaultInputModes: string[];
  /**
   * Default set of supported output MIME types for all skills, which can be
   * overridden on a per-skill basis.
   */
  defaultOutputModes: string[];
  /**
   * A human-readable description of the agent, assisting users and other agents
   * in understanding its purpose.
   */
  description: string;
  /**
   * An optional URL to the agent's documentation.
   */
  documentationUrl?: string;
  /**
   * An optional URL to an icon for the agent.
   */
  iconUrl?: string;
  /**
   * A human-readable name for the agent.
   */
  name: string;
  /**
   * The transport protocol for the preferred endpoint (the main 'url' field).
   * If not specified, defaults to 'JSONRPC'.
   *
   * IMPORTANT: The transport specified here MUST be available at the main 'url'.
   * This creates a binding between the main URL and its supported transport protocol.
   * Clients should prefer this transport and URL combination when both are supported.
   */
  preferredTransport?: string;
  /**
   * The version of the A2A protocol this agent supports.
   */
  protocolVersion: string;
  provider?: AgentProvider;
  /**
   * A list of security requirement objects that apply to all agent interactions. Each object
   * lists security schemes that can be used. Follows the OpenAPI 3.0 Security Requirement Object.
   * This list can be seen as an OR of ANDs. Each object in the list describes one possible
   * set of security requirements that must be present on a request. This allows specifying,
   * for example, "callers must either use OAuth OR an API Key AND mTLS."
   */
  security?: {
    [k: string]: string[];
  }[];
  /**
   * A declaration of the security schemes available to authorize requests. The key is the
   * scheme name. Follows the OpenAPI 3.0 Security Scheme Object.
   */
  securitySchemes?: {
    [k: string]: SecurityScheme;
  };
  /**
   * JSON Web Signatures computed for this AgentCard.
   */
  signatures?: AgentCardSignature[];
  /**
   * The set of skills, or distinct capabilities, that the agent can perform.
   */
  skills: AgentSkill[];
  /**
   * If true, the agent can provide an extended agent card with additional details
   * to authenticated users. Defaults to false.
   */
  supportsAuthenticatedExtendedCard?: boolean;
  /**
   * The preferred endpoint URL for interacting with the agent.
   * This URL MUST support the transport specified by 'preferredTransport'.
   */
  url: string;
  /**
   * The agent's own version number. The format is defined by the provider.
   */
  version: string;
}
‚ãÆ----
/**
   * A list of additional supported interfaces (transport and URL combinations).
   * This allows agents to expose multiple transports, potentially at different URLs.
   *
   * Best practices:
   * - SHOULD include all supported transports for completeness
   * - SHOULD include an entry matching the main 'url' and 'preferredTransport'
   * - MAY reuse URLs if multiple transports are available at the same endpoint
   * - MUST accurately declare the transport available at each URL
   *
   * Clients can select any interface from this list based on their transport capabilities
   * and preferences. This enables transport negotiation and fallback scenarios.
   */
‚ãÆ----
/**
   * Default set of supported input MIME types for all skills, which can be
   * overridden on a per-skill basis.
   */
‚ãÆ----
/**
   * Default set of supported output MIME types for all skills, which can be
   * overridden on a per-skill basis.
   */
‚ãÆ----
/**
   * A human-readable description of the agent, assisting users and other agents
   * in understanding its purpose.
   */
‚ãÆ----
/**
   * An optional URL to the agent's documentation.
   */
‚ãÆ----
/**
   * An optional URL to an icon for the agent.
   */
‚ãÆ----
/**
   * A human-readable name for the agent.
   */
‚ãÆ----
/**
   * The transport protocol for the preferred endpoint (the main 'url' field).
   * If not specified, defaults to 'JSONRPC'.
   *
   * IMPORTANT: The transport specified here MUST be available at the main 'url'.
   * This creates a binding between the main URL and its supported transport protocol.
   * Clients should prefer this transport and URL combination when both are supported.
   */
‚ãÆ----
/**
   * The version of the A2A protocol this agent supports.
   */
‚ãÆ----
/**
   * A list of security requirement objects that apply to all agent interactions. Each object
   * lists security schemes that can be used. Follows the OpenAPI 3.0 Security Requirement Object.
   * This list can be seen as an OR of ANDs. Each object in the list describes one possible
   * set of security requirements that must be present on a request. This allows specifying,
   * for example, "callers must either use OAuth OR an API Key AND mTLS."
   */
‚ãÆ----
/**
   * A declaration of the security schemes available to authorize requests. The key is the
   * scheme name. Follows the OpenAPI 3.0 Security Scheme Object.
   */
‚ãÆ----
/**
   * JSON Web Signatures computed for this AgentCard.
   */
‚ãÆ----
/**
   * The set of skills, or distinct capabilities, that the agent can perform.
   */
‚ãÆ----
/**
   * If true, the agent can provide an extended agent card with additional details
   * to authenticated users. Defaults to false.
   */
‚ãÆ----
/**
   * The preferred endpoint URL for interacting with the agent.
   * This URL MUST support the transport specified by 'preferredTransport'.
   */
‚ãÆ----
/**
   * The agent's own version number. The format is defined by the provider.
   */
‚ãÆ----
/**
 * Declares a combination of a target URL and a transport protocol for interacting with the agent.
 * This allows agents to expose the same functionality over multiple transport mechanisms.
 *
 * This interface was referenced by `MySchema`'s JSON-Schema
 * via the `definition` "AgentInterface".
 */
export interface AgentInterface {
  /**
   * The transport protocol supported at this URL.
   */
  transport: string;
  /**
   * The URL where this interface is available. Must be a valid absolute HTTPS URL in production.
   */
  url: string;
}
‚ãÆ----
/**
   * The transport protocol supported at this URL.
   */
‚ãÆ----
/**
   * The URL where this interface is available. Must be a valid absolute HTTPS URL in production.
   */
‚ãÆ----
/**
 * A declaration of optional capabilities supported by the agent.
 */
export interface AgentCapabilities1 {
  /**
   * A list of protocol extensions supported by the agent.
   */
  extensions?: AgentExtension[];
  /**
   * Indicates if the agent supports sending push notifications for asynchronous task updates.
   */
  pushNotifications?: boolean;
  /**
   * Indicates if the agent provides a history of state transitions for a task.
   */
  stateTransitionHistory?: boolean;
  /**
   * Indicates if the agent supports Server-Sent Events (SSE) for streaming responses.
   */
  streaming?: boolean;
}
‚ãÆ----
/**
   * A list of protocol extensions supported by the agent.
   */
‚ãÆ----
/**
   * Indicates if the agent supports sending push notifications for asynchronous task updates.
   */
‚ãÆ----
/**
   * Indicates if the agent provides a history of state transitions for a task.
   */
‚ãÆ----
/**
   * Indicates if the agent supports Server-Sent Events (SSE) for streaming responses.
   */
‚ãÆ----
/**
 * Information about the agent's service provider.
 */
export interface AgentProvider {
  /**
   * The name of the agent provider's organization.
   */
  organization: string;
  /**
   * A URL for the agent provider's website or relevant documentation.
   */
  url: string;
}
‚ãÆ----
/**
   * The name of the agent provider's organization.
   */
‚ãÆ----
/**
   * A URL for the agent provider's website or relevant documentation.
   */
‚ãÆ----
/**
 * Defines a security scheme using HTTP authentication.
 *
 * This interface was referenced by `MySchema`'s JSON-Schema
 * via the `definition` "HTTPAuthSecurityScheme".
 */
export interface HTTPAuthSecurityScheme {
  /**
   * A hint to the client to identify how the bearer token is formatted (e.g., "JWT").
   * This is primarily for documentation purposes.
   */
  bearerFormat?: string;
  /**
   * An optional description for the security scheme.
   */
  description?: string;
  /**
   * The name of the HTTP Authentication scheme to be used in the Authorization header,
   * as defined in RFC7235 (e.g., "Bearer").
   * This value should be registered in the IANA Authentication Scheme registry.
   */
  scheme: string;
  /**
   * The type of the security scheme. Must be 'http'.
   */
  type: "http";
}
‚ãÆ----
/**
   * A hint to the client to identify how the bearer token is formatted (e.g., "JWT").
   * This is primarily for documentation purposes.
   */
‚ãÆ----
/**
   * An optional description for the security scheme.
   */
‚ãÆ----
/**
   * The name of the HTTP Authentication scheme to be used in the Authorization header,
   * as defined in RFC7235 (e.g., "Bearer").
   * This value should be registered in the IANA Authentication Scheme registry.
   */
‚ãÆ----
/**
   * The type of the security scheme. Must be 'http'.
   */
‚ãÆ----
/**
 * Defines a security scheme using OAuth 2.0.
 *
 * This interface was referenced by `MySchema`'s JSON-Schema
 * via the `definition` "OAuth2SecurityScheme".
 */
export interface OAuth2SecurityScheme {
  /**
   * An optional description for the security scheme.
   */
  description?: string;
  flows: OAuthFlows;
  /**
   * URL to the oauth2 authorization server metadata
   * [RFC8414](https://datatracker.ietf.org/doc/html/rfc8414). TLS is required.
   */
  oauth2MetadataUrl?: string;
  /**
   * The type of the security scheme. Must be 'oauth2'.
   */
  type: "oauth2";
}
‚ãÆ----
/**
   * An optional description for the security scheme.
   */
‚ãÆ----
/**
   * URL to the oauth2 authorization server metadata
   * [RFC8414](https://datatracker.ietf.org/doc/html/rfc8414). TLS is required.
   */
‚ãÆ----
/**
   * The type of the security scheme. Must be 'oauth2'.
   */
‚ãÆ----
/**
 * An object containing configuration information for the supported OAuth 2.0 flows.
 */
export interface OAuthFlows {
  authorizationCode?: AuthorizationCodeOAuthFlow;
  clientCredentials?: ClientCredentialsOAuthFlow;
  implicit?: ImplicitOAuthFlow;
  password?: PasswordOAuthFlow;
}
/**
 * Configuration for the OAuth Authorization Code flow. Previously called accessCode in OpenAPI 2.0.
 */
export interface AuthorizationCodeOAuthFlow {
  /**
   * The authorization URL to be used for this flow.
   * This MUST be a URL and use TLS.
   */
  authorizationUrl: string;
  /**
   * The URL to be used for obtaining refresh tokens.
   * This MUST be a URL and use TLS.
   */
  refreshUrl?: string;
  /**
   * The available scopes for the OAuth2 security scheme. A map between the scope
   * name and a short description for it.
   */
  scopes: {
    [k: string]: string;
  };
  /**
   * The token URL to be used for this flow.
   * This MUST be a URL and use TLS.
   */
  tokenUrl: string;
}
‚ãÆ----
/**
   * The authorization URL to be used for this flow.
   * This MUST be a URL and use TLS.
   */
‚ãÆ----
/**
   * The URL to be used for obtaining refresh tokens.
   * This MUST be a URL and use TLS.
   */
‚ãÆ----
/**
   * The available scopes for the OAuth2 security scheme. A map between the scope
   * name and a short description for it.
   */
‚ãÆ----
/**
   * The token URL to be used for this flow.
   * This MUST be a URL and use TLS.
   */
‚ãÆ----
/**
 * Configuration for the OAuth Client Credentials flow. Previously called application in OpenAPI 2.0.
 */
export interface ClientCredentialsOAuthFlow {
  /**
   * The URL to be used for obtaining refresh tokens. This MUST be a URL.
   */
  refreshUrl?: string;
  /**
   * The available scopes for the OAuth2 security scheme. A map between the scope
   * name and a short description for it.
   */
  scopes: {
    [k: string]: string;
  };
  /**
   * The token URL to be used for this flow. This MUST be a URL.
   */
  tokenUrl: string;
}
‚ãÆ----
/**
   * The URL to be used for obtaining refresh tokens. This MUST be a URL.
   */
‚ãÆ----
/**
   * The available scopes for the OAuth2 security scheme. A map between the scope
   * name and a short description for it.
   */
‚ãÆ----
/**
   * The token URL to be used for this flow. This MUST be a URL.
   */
‚ãÆ----
/**
 * Configuration for the OAuth Implicit flow.
 */
export interface ImplicitOAuthFlow {
  /**
   * The authorization URL to be used for this flow. This MUST be a URL.
   */
  authorizationUrl: string;
  /**
   * The URL to be used for obtaining refresh tokens. This MUST be a URL.
   */
  refreshUrl?: string;
  /**
   * The available scopes for the OAuth2 security scheme. A map between the scope
   * name and a short description for it.
   */
  scopes: {
    [k: string]: string;
  };
}
‚ãÆ----
/**
   * The authorization URL to be used for this flow. This MUST be a URL.
   */
‚ãÆ----
/**
   * The URL to be used for obtaining refresh tokens. This MUST be a URL.
   */
‚ãÆ----
/**
   * The available scopes for the OAuth2 security scheme. A map between the scope
   * name and a short description for it.
   */
‚ãÆ----
/**
 * Configuration for the OAuth Resource Owner Password flow.
 */
export interface PasswordOAuthFlow {
  /**
   * The URL to be used for obtaining refresh tokens. This MUST be a URL.
   */
  refreshUrl?: string;
  /**
   * The available scopes for the OAuth2 security scheme. A map between the scope
   * name and a short description for it.
   */
  scopes: {
    [k: string]: string;
  };
  /**
   * The token URL to be used for this flow. This MUST be a URL.
   */
  tokenUrl: string;
}
‚ãÆ----
/**
   * The URL to be used for obtaining refresh tokens. This MUST be a URL.
   */
‚ãÆ----
/**
   * The available scopes for the OAuth2 security scheme. A map between the scope
   * name and a short description for it.
   */
‚ãÆ----
/**
   * The token URL to be used for this flow. This MUST be a URL.
   */
‚ãÆ----
/**
 * Defines a security scheme using OpenID Connect.
 *
 * This interface was referenced by `MySchema`'s JSON-Schema
 * via the `definition` "OpenIdConnectSecurityScheme".
 */
export interface OpenIdConnectSecurityScheme {
  /**
   * An optional description for the security scheme.
   */
  description?: string;
  /**
   * The OpenID Connect Discovery URL for the OIDC provider's metadata.
   */
  openIdConnectUrl: string;
  /**
   * The type of the security scheme. Must be 'openIdConnect'.
   */
  type: "openIdConnect";
}
‚ãÆ----
/**
   * An optional description for the security scheme.
   */
‚ãÆ----
/**
   * The OpenID Connect Discovery URL for the OIDC provider's metadata.
   */
‚ãÆ----
/**
   * The type of the security scheme. Must be 'openIdConnect'.
   */
‚ãÆ----
/**
 * Defines a security scheme using mTLS authentication.
 *
 * This interface was referenced by `MySchema`'s JSON-Schema
 * via the `definition` "MutualTLSSecurityScheme".
 */
export interface MutualTLSSecurityScheme {
  /**
   * An optional description for the security scheme.
   */
  description?: string;
  /**
   * The type of the security scheme. Must be 'mutualTLS'.
   */
  type: "mutualTLS";
}
‚ãÆ----
/**
   * An optional description for the security scheme.
   */
‚ãÆ----
/**
   * The type of the security scheme. Must be 'mutualTLS'.
   */
‚ãÆ----
/**
 * AgentCardSignature represents a JWS signature of an AgentCard.
 * This follows the JSON format of an RFC 7515 JSON Web Signature (JWS).
 *
 * This interface was referenced by `MySchema`'s JSON-Schema
 * via the `definition` "AgentCardSignature".
 */
export interface AgentCardSignature {
  /**
   * The unprotected JWS header values.
   */
  header?: {
    [k: string]: unknown;
  };
  /**
   * The protected JWS header for the signature. This is a Base64url-encoded
   * JSON object, as per RFC 7515.
   */
  protected: string;
  /**
   * The computed signature, Base64url-encoded.
   */
  signature: string;
}
‚ãÆ----
/**
   * The unprotected JWS header values.
   */
‚ãÆ----
/**
   * The protected JWS header for the signature. This is a Base64url-encoded
   * JSON object, as per RFC 7515.
   */
‚ãÆ----
/**
   * The computed signature, Base64url-encoded.
   */
‚ãÆ----
/**
 * Represents a distinct capability or function that an agent can perform.
 *
 * This interface was referenced by `MySchema`'s JSON-Schema
 * via the `definition` "AgentSkill".
 */
export interface AgentSkill {
  /**
   * A detailed description of the skill, intended to help clients or users
   * understand its purpose and functionality.
   */
  description: string;
  /**
   * Example prompts or scenarios that this skill can handle. Provides a hint to
   * the client on how to use the skill.
   */
  examples?: string[];
  /**
   * A unique identifier for the agent's skill.
   */
  id: string;
  /**
   * The set of supported input MIME types for this skill, overriding the agent's defaults.
   */
  inputModes?: string[];
  /**
   * A human-readable name for the skill.
   */
  name: string;
  /**
   * The set of supported output MIME types for this skill, overriding the agent's defaults.
   */
  outputModes?: string[];
  /**
   * Security schemes necessary for the agent to leverage this skill.
   * As in the overall AgentCard.security, this list represents a logical OR of security
   * requirement objects. Each object is a set of security schemes that must be used together
   * (a logical AND).
   */
  security?: {
    [k: string]: string[];
  }[];
  /**
   * A set of keywords describing the skill's capabilities.
   */
  tags: string[];
}
‚ãÆ----
/**
   * A detailed description of the skill, intended to help clients or users
   * understand its purpose and functionality.
   */
‚ãÆ----
/**
   * Example prompts or scenarios that this skill can handle. Provides a hint to
   * the client on how to use the skill.
   */
‚ãÆ----
/**
   * A unique identifier for the agent's skill.
   */
‚ãÆ----
/**
   * The set of supported input MIME types for this skill, overriding the agent's defaults.
   */
‚ãÆ----
/**
   * A human-readable name for the skill.
   */
‚ãÆ----
/**
   * The set of supported output MIME types for this skill, overriding the agent's defaults.
   */
‚ãÆ----
/**
   * Security schemes necessary for the agent to leverage this skill.
   * As in the overall AgentCard.security, this list represents a logical OR of security
   * requirement objects. Each object is a set of security schemes that must be used together
   * (a logical AND).
   */
‚ãÆ----
/**
   * A set of keywords describing the skill's capabilities.
   */
‚ãÆ----
/**
 * Represents the service provider of an agent.
 *
 * This interface was referenced by `MySchema`'s JSON-Schema
 * via the `definition` "AgentProvider".
 */
export interface AgentProvider1 {
  /**
   * The name of the agent provider's organization.
   */
  organization: string;
  /**
   * A URL for the agent provider's website or relevant documentation.
   */
  url: string;
}
‚ãÆ----
/**
   * The name of the agent provider's organization.
   */
‚ãÆ----
/**
   * A URL for the agent provider's website or relevant documentation.
   */
‚ãÆ----
/**
 * Represents a file, data structure, or other resource generated by an agent during a task.
 *
 * This interface was referenced by `MySchema`'s JSON-Schema
 * via the `definition` "Artifact".
 */
export interface Artifact {
  /**
   * A unique identifier for the artifact within the scope of the task.
   */
  artifactId: string;
  /**
   * An optional, human-readable description of the artifact.
   */
  description?: string;
  /**
   * The URIs of extensions that are relevant to this artifact.
   */
  extensions?: string[];
  /**
   * Optional metadata for extensions. The key is an extension-specific identifier.
   */
  metadata?: {
    [k: string]: unknown;
  };
  /**
   * An optional, human-readable name for the artifact.
   */
  name?: string;
  /**
   * An array of content parts that make up the artifact.
   */
  parts: Part[];
}
‚ãÆ----
/**
   * A unique identifier for the artifact within the scope of the task.
   */
‚ãÆ----
/**
   * An optional, human-readable description of the artifact.
   */
‚ãÆ----
/**
   * The URIs of extensions that are relevant to this artifact.
   */
‚ãÆ----
/**
   * Optional metadata for extensions. The key is an extension-specific identifier.
   */
‚ãÆ----
/**
   * An optional, human-readable name for the artifact.
   */
‚ãÆ----
/**
   * An array of content parts that make up the artifact.
   */
‚ãÆ----
/**
 * Defines configuration details for the OAuth 2.0 Authorization Code flow.
 *
 * This interface was referenced by `MySchema`'s JSON-Schema
 * via the `definition` "AuthorizationCodeOAuthFlow".
 */
export interface AuthorizationCodeOAuthFlow1 {
  /**
   * The authorization URL to be used for this flow.
   * This MUST be a URL and use TLS.
   */
  authorizationUrl: string;
  /**
   * The URL to be used for obtaining refresh tokens.
   * This MUST be a URL and use TLS.
   */
  refreshUrl?: string;
  /**
   * The available scopes for the OAuth2 security scheme. A map between the scope
   * name and a short description for it.
   */
  scopes: {
    [k: string]: string;
  };
  /**
   * The token URL to be used for this flow.
   * This MUST be a URL and use TLS.
   */
  tokenUrl: string;
}
‚ãÆ----
/**
   * The authorization URL to be used for this flow.
   * This MUST be a URL and use TLS.
   */
‚ãÆ----
/**
   * The URL to be used for obtaining refresh tokens.
   * This MUST be a URL and use TLS.
   */
‚ãÆ----
/**
   * The available scopes for the OAuth2 security scheme. A map between the scope
   * name and a short description for it.
   */
‚ãÆ----
/**
   * The token URL to be used for this flow.
   * This MUST be a URL and use TLS.
   */
‚ãÆ----
/**
 * Represents a JSON-RPC 2.0 Error Response object.
 *
 * This interface was referenced by `MySchema`'s JSON-Schema
 * via the `definition` "JSONRPCErrorResponse".
 */
export interface JSONRPCErrorResponse {
  /**
   * An object describing the error that occurred.
   */
  error:
    | JSONRPCError
    | JSONParseError
    | InvalidRequestError
    | MethodNotFoundError
    | InvalidParamsError
    | InternalError
    | TaskNotFoundError
    | TaskNotCancelableError
    | PushNotificationNotSupportedError
    | UnsupportedOperationError
    | ContentTypeNotSupportedError
    | InvalidAgentResponseError
    | AuthenticatedExtendedCardNotConfiguredError;
  /**
   * The identifier established by the client.
   */
  id: string | number | null;
  /**
   * The version of the JSON-RPC protocol. MUST be exactly "2.0".
   */
  jsonrpc: "2.0";
}
‚ãÆ----
/**
   * An object describing the error that occurred.
   */
‚ãÆ----
/**
   * The identifier established by the client.
   */
‚ãÆ----
/**
   * The version of the JSON-RPC protocol. MUST be exactly "2.0".
   */
‚ãÆ----
/**
 * Represents a JSON-RPC 2.0 Error object, included in an error response.
 *
 * This interface was referenced by `MySchema`'s JSON-Schema
 * via the `definition` "JSONRPCError".
 */
export interface JSONRPCError {
  /**
   * A number that indicates the error type that occurred.
   */
  code: number;
  /**
   * A primitive or structured value containing additional information about the error.
   * This may be omitted.
   */
  data?: {
    [k: string]: unknown;
  };
  /**
   * A string providing a short description of the error.
   */
  message: string;
}
‚ãÆ----
/**
   * A number that indicates the error type that occurred.
   */
‚ãÆ----
/**
   * A primitive or structured value containing additional information about the error.
   * This may be omitted.
   */
‚ãÆ----
/**
   * A string providing a short description of the error.
   */
‚ãÆ----
/**
 * Represents a successful JSON-RPC response for the `tasks/cancel` method.
 *
 * This interface was referenced by `MySchema`'s JSON-Schema
 * via the `definition` "CancelTaskSuccessResponse".
 */
export interface CancelTaskSuccessResponse {
  /**
   * The identifier established by the client.
   */
  id: string | number | null;
  /**
   * The version of the JSON-RPC protocol. MUST be exactly "2.0".
   */
  jsonrpc: "2.0";
  result: Task;
}
‚ãÆ----
/**
   * The identifier established by the client.
   */
‚ãÆ----
/**
   * The version of the JSON-RPC protocol. MUST be exactly "2.0".
   */
‚ãÆ----
/**
 * The result, containing the final state of the canceled Task object.
 */
export interface Task {
  /**
   * A collection of artifacts generated by the agent during the execution of the task.
   */
  artifacts?: Artifact[];
  /**
   * A server-generated identifier for maintaining context across multiple related tasks or interactions.
   */
  contextId: string;
  /**
   * An array of messages exchanged during the task, representing the conversation history.
   */
  history?: Message1[];
  /**
   * A unique identifier for the task, generated by the server for a new task.
   */
  id: string;
  /**
   * The type of this object, used as a discriminator. Always 'task' for a Task.
   */
  kind: "task";
  /**
   * Optional metadata for extensions. The key is an extension-specific identifier.
   */
  metadata?: {
    [k: string]: unknown;
  };
  status: TaskStatus;
}
‚ãÆ----
/**
   * A collection of artifacts generated by the agent during the execution of the task.
   */
‚ãÆ----
/**
   * A server-generated identifier for maintaining context across multiple related tasks or interactions.
   */
‚ãÆ----
/**
   * An array of messages exchanged during the task, representing the conversation history.
   */
‚ãÆ----
/**
   * A unique identifier for the task, generated by the server for a new task.
   */
‚ãÆ----
/**
   * The type of this object, used as a discriminator. Always 'task' for a Task.
   */
‚ãÆ----
/**
   * Optional metadata for extensions. The key is an extension-specific identifier.
   */
‚ãÆ----
/**
 * Represents a single message in the conversation between a user and an agent.
 *
 * This interface was referenced by `MySchema`'s JSON-Schema
 * via the `definition` "Message".
 */
export interface Message1 {
  /**
   * The context identifier for this message, used to group related interactions.
   */
  contextId?: string;
  /**
   * The URIs of extensions that are relevant to this message.
   */
  extensions?: string[];
  /**
   * The type of this object, used as a discriminator. Always 'message' for a Message.
   */
  kind: "message";
  /**
   * A unique identifier for the message, typically a UUID, generated by the sender.
   */
  messageId: string;
  /**
   * Optional metadata for extensions. The key is an extension-specific identifier.
   */
  metadata?: {
    [k: string]: unknown;
  };
  /**
   * An array of content parts that form the message body. A message can be
   * composed of multiple parts of different types (e.g., text and files).
   */
  parts: Part[];
  /**
   * A list of other task IDs that this message references for additional context.
   */
  referenceTaskIds?: string[];
  /**
   * Identifies the sender of the message. `user` for the client, `agent` for the service.
   */
  role: "agent" | "user";
  /**
   * The identifier of the task this message is part of. Can be omitted for the first message of a new task.
   */
  taskId?: string;
}
‚ãÆ----
/**
   * The context identifier for this message, used to group related interactions.
   */
‚ãÆ----
/**
   * The URIs of extensions that are relevant to this message.
   */
‚ãÆ----
/**
   * The type of this object, used as a discriminator. Always 'message' for a Message.
   */
‚ãÆ----
/**
   * A unique identifier for the message, typically a UUID, generated by the sender.
   */
‚ãÆ----
/**
   * Optional metadata for extensions. The key is an extension-specific identifier.
   */
‚ãÆ----
/**
   * An array of content parts that form the message body. A message can be
   * composed of multiple parts of different types (e.g., text and files).
   */
‚ãÆ----
/**
   * A list of other task IDs that this message references for additional context.
   */
‚ãÆ----
/**
   * Identifies the sender of the message. `user` for the client, `agent` for the service.
   */
‚ãÆ----
/**
   * The identifier of the task this message is part of. Can be omitted for the first message of a new task.
   */
‚ãÆ----
/**
 * The current status of the task, including its state and a descriptive message.
 */
export interface TaskStatus {
  message?: Message2;
  /**
   * The current state of the task's lifecycle.
   */
  state:
    | "submitted"
    | "working"
    | "input-required"
    | "completed"
    | "canceled"
    | "failed"
    | "rejected"
    | "auth-required"
    | "unknown";
  /**
   * An ISO 8601 datetime string indicating when this status was recorded.
   */
  timestamp?: string;
}
‚ãÆ----
/**
   * The current state of the task's lifecycle.
   */
‚ãÆ----
/**
   * An ISO 8601 datetime string indicating when this status was recorded.
   */
‚ãÆ----
/**
 * Represents a single message in the conversation between a user and an agent.
 */
export interface Message2 {
  /**
   * The context identifier for this message, used to group related interactions.
   */
  contextId?: string;
  /**
   * The URIs of extensions that are relevant to this message.
   */
  extensions?: string[];
  /**
   * The type of this object, used as a discriminator. Always 'message' for a Message.
   */
  kind: "message";
  /**
   * A unique identifier for the message, typically a UUID, generated by the sender.
   */
  messageId: string;
  /**
   * Optional metadata for extensions. The key is an extension-specific identifier.
   */
  metadata?: {
    [k: string]: unknown;
  };
  /**
   * An array of content parts that form the message body. A message can be
   * composed of multiple parts of different types (e.g., text and files).
   */
  parts: Part[];
  /**
   * A list of other task IDs that this message references for additional context.
   */
  referenceTaskIds?: string[];
  /**
   * Identifies the sender of the message. `user` for the client, `agent` for the service.
   */
  role: "agent" | "user";
  /**
   * The identifier of the task this message is part of. Can be omitted for the first message of a new task.
   */
  taskId?: string;
}
‚ãÆ----
/**
   * The context identifier for this message, used to group related interactions.
   */
‚ãÆ----
/**
   * The URIs of extensions that are relevant to this message.
   */
‚ãÆ----
/**
   * The type of this object, used as a discriminator. Always 'message' for a Message.
   */
‚ãÆ----
/**
   * A unique identifier for the message, typically a UUID, generated by the sender.
   */
‚ãÆ----
/**
   * Optional metadata for extensions. The key is an extension-specific identifier.
   */
‚ãÆ----
/**
   * An array of content parts that form the message body. A message can be
   * composed of multiple parts of different types (e.g., text and files).
   */
‚ãÆ----
/**
   * A list of other task IDs that this message references for additional context.
   */
‚ãÆ----
/**
   * Identifies the sender of the message. `user` for the client, `agent` for the service.
   */
‚ãÆ----
/**
   * The identifier of the task this message is part of. Can be omitted for the first message of a new task.
   */
‚ãÆ----
/**
 * Defines configuration details for the OAuth 2.0 Client Credentials flow.
 *
 * This interface was referenced by `MySchema`'s JSON-Schema
 * via the `definition` "ClientCredentialsOAuthFlow".
 */
export interface ClientCredentialsOAuthFlow1 {
  /**
   * The URL to be used for obtaining refresh tokens. This MUST be a URL.
   */
  refreshUrl?: string;
  /**
   * The available scopes for the OAuth2 security scheme. A map between the scope
   * name and a short description for it.
   */
  scopes: {
    [k: string]: string;
  };
  /**
   * The token URL to be used for this flow. This MUST be a URL.
   */
  tokenUrl: string;
}
‚ãÆ----
/**
   * The URL to be used for obtaining refresh tokens. This MUST be a URL.
   */
‚ãÆ----
/**
   * The available scopes for the OAuth2 security scheme. A map between the scope
   * name and a short description for it.
   */
‚ãÆ----
/**
   * The token URL to be used for this flow. This MUST be a URL.
   */
‚ãÆ----
/**
 * Defines parameters for deleting a specific push notification configuration for a task.
 *
 * This interface was referenced by `MySchema`'s JSON-Schema
 * via the `definition` "DeleteTaskPushNotificationConfigParams".
 */
export interface DeleteTaskPushNotificationConfigParams1 {
  /**
   * The unique identifier of the task.
   */
  id: string;
  /**
   * Optional metadata associated with the request.
   */
  metadata?: {
    [k: string]: unknown;
  };
  /**
   * The ID of the push notification configuration to delete.
   */
  pushNotificationConfigId: string;
}
‚ãÆ----
/**
   * The unique identifier of the task.
   */
‚ãÆ----
/**
   * Optional metadata associated with the request.
   */
‚ãÆ----
/**
   * The ID of the push notification configuration to delete.
   */
‚ãÆ----
/**
 * Represents a successful JSON-RPC response for the `tasks/pushNotificationConfig/delete` method.
 *
 * This interface was referenced by `MySchema`'s JSON-Schema
 * via the `definition` "DeleteTaskPushNotificationConfigSuccessResponse".
 */
export interface DeleteTaskPushNotificationConfigSuccessResponse {
  /**
   * The identifier established by the client.
   */
  id: string | number | null;
  /**
   * The version of the JSON-RPC protocol. MUST be exactly "2.0".
   */
  jsonrpc: "2.0";
  /**
   * The result is null on successful deletion.
   */
  result: null;
}
‚ãÆ----
/**
   * The identifier established by the client.
   */
‚ãÆ----
/**
   * The version of the JSON-RPC protocol. MUST be exactly "2.0".
   */
‚ãÆ----
/**
   * The result is null on successful deletion.
   */
‚ãÆ----
/**
 * Defines base properties for a file.
 *
 * This interface was referenced by `MySchema`'s JSON-Schema
 * via the `definition` "FileBase".
 */
export interface FileBase {
  /**
   * The MIME type of the file (e.g., "application/pdf").
   */
  mimeType?: string;
  /**
   * An optional name for the file (e.g., "document.pdf").
   */
  name?: string;
}
‚ãÆ----
/**
   * The MIME type of the file (e.g., "application/pdf").
   */
‚ãÆ----
/**
   * An optional name for the file (e.g., "document.pdf").
   */
‚ãÆ----
/**
 * Represents a successful JSON-RPC response for the `agent/getAuthenticatedExtendedCard` method.
 *
 * This interface was referenced by `MySchema`'s JSON-Schema
 * via the `definition` "GetAuthenticatedExtendedCardSuccessResponse".
 */
export interface GetAuthenticatedExtendedCardSuccessResponse {
  /**
   * The identifier established by the client.
   */
  id: string | number | null;
  /**
   * The version of the JSON-RPC protocol. MUST be exactly "2.0".
   */
  jsonrpc: "2.0";
  result: AgentCard1;
}
‚ãÆ----
/**
   * The identifier established by the client.
   */
‚ãÆ----
/**
   * The version of the JSON-RPC protocol. MUST be exactly "2.0".
   */
‚ãÆ----
/**
 * The result is an Agent Card object.
 */
export interface AgentCard1 {
  /**
   * A list of additional supported interfaces (transport and URL combinations).
   * This allows agents to expose multiple transports, potentially at different URLs.
   *
   * Best practices:
   * - SHOULD include all supported transports for completeness
   * - SHOULD include an entry matching the main 'url' and 'preferredTransport'
   * - MAY reuse URLs if multiple transports are available at the same endpoint
   * - MUST accurately declare the transport available at each URL
   *
   * Clients can select any interface from this list based on their transport capabilities
   * and preferences. This enables transport negotiation and fallback scenarios.
   */
  additionalInterfaces?: AgentInterface[];
  capabilities: AgentCapabilities1;
  /**
   * Default set of supported input MIME types for all skills, which can be
   * overridden on a per-skill basis.
   */
  defaultInputModes: string[];
  /**
   * Default set of supported output MIME types for all skills, which can be
   * overridden on a per-skill basis.
   */
  defaultOutputModes: string[];
  /**
   * A human-readable description of the agent, assisting users and other agents
   * in understanding its purpose.
   */
  description: string;
  /**
   * An optional URL to the agent's documentation.
   */
  documentationUrl?: string;
  /**
   * An optional URL to an icon for the agent.
   */
  iconUrl?: string;
  /**
   * A human-readable name for the agent.
   */
  name: string;
  /**
   * The transport protocol for the preferred endpoint (the main 'url' field).
   * If not specified, defaults to 'JSONRPC'.
   *
   * IMPORTANT: The transport specified here MUST be available at the main 'url'.
   * This creates a binding between the main URL and its supported transport protocol.
   * Clients should prefer this transport and URL combination when both are supported.
   */
  preferredTransport?: string;
  /**
   * The version of the A2A protocol this agent supports.
   */
  protocolVersion: string;
  provider?: AgentProvider;
  /**
   * A list of security requirement objects that apply to all agent interactions. Each object
   * lists security schemes that can be used. Follows the OpenAPI 3.0 Security Requirement Object.
   * This list can be seen as an OR of ANDs. Each object in the list describes one possible
   * set of security requirements that must be present on a request. This allows specifying,
   * for example, "callers must either use OAuth OR an API Key AND mTLS."
   */
  security?: {
    [k: string]: string[];
  }[];
  /**
   * A declaration of the security schemes available to authorize requests. The key is the
   * scheme name. Follows the OpenAPI 3.0 Security Scheme Object.
   */
  securitySchemes?: {
    [k: string]: SecurityScheme;
  };
  /**
   * JSON Web Signatures computed for this AgentCard.
   */
  signatures?: AgentCardSignature[];
  /**
   * The set of skills, or distinct capabilities, that the agent can perform.
   */
  skills: AgentSkill[];
  /**
   * If true, the agent can provide an extended agent card with additional details
   * to authenticated users. Defaults to false.
   */
  supportsAuthenticatedExtendedCard?: boolean;
  /**
   * The preferred endpoint URL for interacting with the agent.
   * This URL MUST support the transport specified by 'preferredTransport'.
   */
  url: string;
  /**
   * The agent's own version number. The format is defined by the provider.
   */
  version: string;
}
‚ãÆ----
/**
   * A list of additional supported interfaces (transport and URL combinations).
   * This allows agents to expose multiple transports, potentially at different URLs.
   *
   * Best practices:
   * - SHOULD include all supported transports for completeness
   * - SHOULD include an entry matching the main 'url' and 'preferredTransport'
   * - MAY reuse URLs if multiple transports are available at the same endpoint
   * - MUST accurately declare the transport available at each URL
   *
   * Clients can select any interface from this list based on their transport capabilities
   * and preferences. This enables transport negotiation and fallback scenarios.
   */
‚ãÆ----
/**
   * Default set of supported input MIME types for all skills, which can be
   * overridden on a per-skill basis.
   */
‚ãÆ----
/**
   * Default set of supported output MIME types for all skills, which can be
   * overridden on a per-skill basis.
   */
‚ãÆ----
/**
   * A human-readable description of the agent, assisting users and other agents
   * in understanding its purpose.
   */
‚ãÆ----
/**
   * An optional URL to the agent's documentation.
   */
‚ãÆ----
/**
   * An optional URL to an icon for the agent.
   */
‚ãÆ----
/**
   * A human-readable name for the agent.
   */
‚ãÆ----
/**
   * The transport protocol for the preferred endpoint (the main 'url' field).
   * If not specified, defaults to 'JSONRPC'.
   *
   * IMPORTANT: The transport specified here MUST be available at the main 'url'.
   * This creates a binding between the main URL and its supported transport protocol.
   * Clients should prefer this transport and URL combination when both are supported.
   */
‚ãÆ----
/**
   * The version of the A2A protocol this agent supports.
   */
‚ãÆ----
/**
   * A list of security requirement objects that apply to all agent interactions. Each object
   * lists security schemes that can be used. Follows the OpenAPI 3.0 Security Requirement Object.
   * This list can be seen as an OR of ANDs. Each object in the list describes one possible
   * set of security requirements that must be present on a request. This allows specifying,
   * for example, "callers must either use OAuth OR an API Key AND mTLS."
   */
‚ãÆ----
/**
   * A declaration of the security schemes available to authorize requests. The key is the
   * scheme name. Follows the OpenAPI 3.0 Security Scheme Object.
   */
‚ãÆ----
/**
   * JSON Web Signatures computed for this AgentCard.
   */
‚ãÆ----
/**
   * The set of skills, or distinct capabilities, that the agent can perform.
   */
‚ãÆ----
/**
   * If true, the agent can provide an extended agent card with additional details
   * to authenticated users. Defaults to false.
   */
‚ãÆ----
/**
   * The preferred endpoint URL for interacting with the agent.
   * This URL MUST support the transport specified by 'preferredTransport'.
   */
‚ãÆ----
/**
   * The agent's own version number. The format is defined by the provider.
   */
‚ãÆ----
/**
 * Represents a successful JSON-RPC response for the `tasks/pushNotificationConfig/get` method.
 *
 * This interface was referenced by `MySchema`'s JSON-Schema
 * via the `definition` "GetTaskPushNotificationConfigSuccessResponse".
 */
export interface GetTaskPushNotificationConfigSuccessResponse {
  /**
   * The identifier established by the client.
   */
  id: string | number | null;
  /**
   * The version of the JSON-RPC protocol. MUST be exactly "2.0".
   */
  jsonrpc: "2.0";
  result: TaskPushNotificationConfig1;
}
‚ãÆ----
/**
   * The identifier established by the client.
   */
‚ãÆ----
/**
   * The version of the JSON-RPC protocol. MUST be exactly "2.0".
   */
‚ãÆ----
/**
 * The result, containing the requested push notification configuration.
 */
export interface TaskPushNotificationConfig1 {
  pushNotificationConfig: PushNotificationConfig1;
  /**
   * The ID of the task.
   */
  taskId: string;
}
‚ãÆ----
/**
   * The ID of the task.
   */
‚ãÆ----
/**
 * Represents a successful JSON-RPC response for the `tasks/get` method.
 *
 * This interface was referenced by `MySchema`'s JSON-Schema
 * via the `definition` "GetTaskSuccessResponse".
 */
export interface GetTaskSuccessResponse {
  /**
   * The identifier established by the client.
   */
  id: string | number | null;
  /**
   * The version of the JSON-RPC protocol. MUST be exactly "2.0".
   */
  jsonrpc: "2.0";
  result: Task1;
}
‚ãÆ----
/**
   * The identifier established by the client.
   */
‚ãÆ----
/**
   * The version of the JSON-RPC protocol. MUST be exactly "2.0".
   */
‚ãÆ----
/**
 * The result, containing the requested Task object.
 */
export interface Task1 {
  /**
   * A collection of artifacts generated by the agent during the execution of the task.
   */
  artifacts?: Artifact[];
  /**
   * A server-generated identifier for maintaining context across multiple related tasks or interactions.
   */
  contextId: string;
  /**
   * An array of messages exchanged during the task, representing the conversation history.
   */
  history?: Message1[];
  /**
   * A unique identifier for the task, generated by the server for a new task.
   */
  id: string;
  /**
   * The type of this object, used as a discriminator. Always 'task' for a Task.
   */
  kind: "task";
  /**
   * Optional metadata for extensions. The key is an extension-specific identifier.
   */
  metadata?: {
    [k: string]: unknown;
  };
  status: TaskStatus;
}
‚ãÆ----
/**
   * A collection of artifacts generated by the agent during the execution of the task.
   */
‚ãÆ----
/**
   * A server-generated identifier for maintaining context across multiple related tasks or interactions.
   */
‚ãÆ----
/**
   * An array of messages exchanged during the task, representing the conversation history.
   */
‚ãÆ----
/**
   * A unique identifier for the task, generated by the server for a new task.
   */
‚ãÆ----
/**
   * The type of this object, used as a discriminator. Always 'task' for a Task.
   */
‚ãÆ----
/**
   * Optional metadata for extensions. The key is an extension-specific identifier.
   */
‚ãÆ----
/**
 * Defines configuration details for the OAuth 2.0 Implicit flow.
 *
 * This interface was referenced by `MySchema`'s JSON-Schema
 * via the `definition` "ImplicitOAuthFlow".
 */
export interface ImplicitOAuthFlow1 {
  /**
   * The authorization URL to be used for this flow. This MUST be a URL.
   */
  authorizationUrl: string;
  /**
   * The URL to be used for obtaining refresh tokens. This MUST be a URL.
   */
  refreshUrl?: string;
  /**
   * The available scopes for the OAuth2 security scheme. A map between the scope
   * name and a short description for it.
   */
  scopes: {
    [k: string]: string;
  };
}
‚ãÆ----
/**
   * The authorization URL to be used for this flow. This MUST be a URL.
   */
‚ãÆ----
/**
   * The URL to be used for obtaining refresh tokens. This MUST be a URL.
   */
‚ãÆ----
/**
   * The available scopes for the OAuth2 security scheme. A map between the scope
   * name and a short description for it.
   */
‚ãÆ----
/**
 * Defines the base structure for any JSON-RPC 2.0 request, response, or notification.
 *
 * This interface was referenced by `MySchema`'s JSON-Schema
 * via the `definition` "JSONRPCMessage".
 */
export interface JSONRPCMessage {
  /**
   * A unique identifier established by the client. It must be a String, a Number, or null.
   * The server must reply with the same value in the response. This property is omitted for notifications.
   */
  id?: string | number | null;
  /**
   * The version of the JSON-RPC protocol. MUST be exactly "2.0".
   */
  jsonrpc: "2.0";
}
‚ãÆ----
/**
   * A unique identifier established by the client. It must be a String, a Number, or null.
   * The server must reply with the same value in the response. This property is omitted for notifications.
   */
‚ãÆ----
/**
   * The version of the JSON-RPC protocol. MUST be exactly "2.0".
   */
‚ãÆ----
/**
 * Represents a JSON-RPC 2.0 Request object.
 *
 * This interface was referenced by `MySchema`'s JSON-Schema
 * via the `definition` "JSONRPCRequest".
 */
export interface JSONRPCRequest {
  /**
   * A unique identifier established by the client. It must be a String, a Number, or null.
   * The server must reply with the same value in the response. This property is omitted for notifications.
   */
  id?: string | number | null;
  /**
   * The version of the JSON-RPC protocol. MUST be exactly "2.0".
   */
  jsonrpc: "2.0";
  /**
   * A string containing the name of the method to be invoked.
   */
  method: string;
  /**
   * A structured value holding the parameter values to be used during the method invocation.
   */
  params?: {
    [k: string]: unknown;
  };
}
‚ãÆ----
/**
   * A unique identifier established by the client. It must be a String, a Number, or null.
   * The server must reply with the same value in the response. This property is omitted for notifications.
   */
‚ãÆ----
/**
   * The version of the JSON-RPC protocol. MUST be exactly "2.0".
   */
‚ãÆ----
/**
   * A string containing the name of the method to be invoked.
   */
‚ãÆ----
/**
   * A structured value holding the parameter values to be used during the method invocation.
   */
‚ãÆ----
/**
 * Represents a successful JSON-RPC response for the `message/send` method.
 *
 * This interface was referenced by `MySchema`'s JSON-Schema
 * via the `definition` "SendMessageSuccessResponse".
 */
export interface SendMessageSuccessResponse {
  /**
   * The identifier established by the client.
   */
  id: string | number | null;
  /**
   * The version of the JSON-RPC protocol. MUST be exactly "2.0".
   */
  jsonrpc: "2.0";
  /**
   * The result, which can be a direct reply Message or the initial Task object.
   */
  result: Task2 | Message1;
}
‚ãÆ----
/**
   * The identifier established by the client.
   */
‚ãÆ----
/**
   * The version of the JSON-RPC protocol. MUST be exactly "2.0".
   */
‚ãÆ----
/**
   * The result, which can be a direct reply Message or the initial Task object.
   */
‚ãÆ----
/**
 * Represents a single, stateful operation or conversation between a client and an agent.
 *
 * This interface was referenced by `MySchema`'s JSON-Schema
 * via the `definition` "Task".
 */
export interface Task2 {
  /**
   * A collection of artifacts generated by the agent during the execution of the task.
   */
  artifacts?: Artifact[];
  /**
   * A server-generated identifier for maintaining context across multiple related tasks or interactions.
   */
  contextId: string;
  /**
   * An array of messages exchanged during the task, representing the conversation history.
   */
  history?: Message1[];
  /**
   * A unique identifier for the task, generated by the server for a new task.
   */
  id: string;
  /**
   * The type of this object, used as a discriminator. Always 'task' for a Task.
   */
  kind: "task";
  /**
   * Optional metadata for extensions. The key is an extension-specific identifier.
   */
  metadata?: {
    [k: string]: unknown;
  };
  status: TaskStatus;
}
‚ãÆ----
/**
   * A collection of artifacts generated by the agent during the execution of the task.
   */
‚ãÆ----
/**
   * A server-generated identifier for maintaining context across multiple related tasks or interactions.
   */
‚ãÆ----
/**
   * An array of messages exchanged during the task, representing the conversation history.
   */
‚ãÆ----
/**
   * A unique identifier for the task, generated by the server for a new task.
   */
‚ãÆ----
/**
   * The type of this object, used as a discriminator. Always 'task' for a Task.
   */
‚ãÆ----
/**
   * Optional metadata for extensions. The key is an extension-specific identifier.
   */
‚ãÆ----
/**
 * Represents a successful JSON-RPC response for the `message/stream` method.
 * The server may send multiple response objects for a single request.
 *
 * This interface was referenced by `MySchema`'s JSON-Schema
 * via the `definition` "SendStreamingMessageSuccessResponse".
 */
export interface SendStreamingMessageSuccessResponse {
  /**
   * The identifier established by the client.
   */
  id: string | number | null;
  /**
   * The version of the JSON-RPC protocol. MUST be exactly "2.0".
   */
  jsonrpc: "2.0";
  /**
   * The result, which can be a Message, Task, or a streaming update event.
   */
  result: Task2 | Message1 | TaskStatusUpdateEvent | TaskArtifactUpdateEvent;
}
‚ãÆ----
/**
   * The identifier established by the client.
   */
‚ãÆ----
/**
   * The version of the JSON-RPC protocol. MUST be exactly "2.0".
   */
‚ãÆ----
/**
   * The result, which can be a Message, Task, or a streaming update event.
   */
‚ãÆ----
/**
 * An event sent by the agent to notify the client of a change in a task's status.
 * This is typically used in streaming or subscription models.
 *
 * This interface was referenced by `MySchema`'s JSON-Schema
 * via the `definition` "TaskStatusUpdateEvent".
 */
export interface TaskStatusUpdateEvent {
  /**
   * The context ID associated with the task.
   */
  contextId: string;
  /**
   * If true, this is the final event in the stream for this interaction.
   */
  final: boolean;
  /**
   * The type of this event, used as a discriminator. Always 'status-update'.
   */
  kind: "status-update";
  /**
   * Optional metadata for extensions.
   */
  metadata?: {
    [k: string]: unknown;
  };
  status: TaskStatus1;
  /**
   * The ID of the task that was updated.
   */
  taskId: string;
}
‚ãÆ----
/**
   * The context ID associated with the task.
   */
‚ãÆ----
/**
   * If true, this is the final event in the stream for this interaction.
   */
‚ãÆ----
/**
   * The type of this event, used as a discriminator. Always 'status-update'.
   */
‚ãÆ----
/**
   * Optional metadata for extensions.
   */
‚ãÆ----
/**
   * The ID of the task that was updated.
   */
‚ãÆ----
/**
 * The new status of the task.
 */
export interface TaskStatus1 {
  message?: Message2;
  /**
   * The current state of the task's lifecycle.
   */
  state:
    | "submitted"
    | "working"
    | "input-required"
    | "completed"
    | "canceled"
    | "failed"
    | "rejected"
    | "auth-required"
    | "unknown";
  /**
   * An ISO 8601 datetime string indicating when this status was recorded.
   */
  timestamp?: string;
}
‚ãÆ----
/**
   * The current state of the task's lifecycle.
   */
‚ãÆ----
/**
   * An ISO 8601 datetime string indicating when this status was recorded.
   */
‚ãÆ----
/**
 * An event sent by the agent to notify the client that an artifact has been
 * generated or updated. This is typically used in streaming models.
 *
 * This interface was referenced by `MySchema`'s JSON-Schema
 * via the `definition` "TaskArtifactUpdateEvent".
 */
export interface TaskArtifactUpdateEvent {
  /**
   * If true, the content of this artifact should be appended to a previously sent artifact with the same ID.
   */
  append?: boolean;
  artifact: Artifact1;
  /**
   * The context ID associated with the task.
   */
  contextId: string;
  /**
   * The type of this event, used as a discriminator. Always 'artifact-update'.
   */
  kind: "artifact-update";
  /**
   * If true, this is the final chunk of the artifact.
   */
  lastChunk?: boolean;
  /**
   * Optional metadata for extensions.
   */
  metadata?: {
    [k: string]: unknown;
  };
  /**
   * The ID of the task this artifact belongs to.
   */
  taskId: string;
}
‚ãÆ----
/**
   * If true, the content of this artifact should be appended to a previously sent artifact with the same ID.
   */
‚ãÆ----
/**
   * The context ID associated with the task.
   */
‚ãÆ----
/**
   * The type of this event, used as a discriminator. Always 'artifact-update'.
   */
‚ãÆ----
/**
   * If true, this is the final chunk of the artifact.
   */
‚ãÆ----
/**
   * Optional metadata for extensions.
   */
‚ãÆ----
/**
   * The ID of the task this artifact belongs to.
   */
‚ãÆ----
/**
 * Represents a file, data structure, or other resource generated by an agent during a task.
 */
export interface Artifact1 {
  /**
   * A unique identifier for the artifact within the scope of the task.
   */
  artifactId: string;
  /**
   * An optional, human-readable description of the artifact.
   */
  description?: string;
  /**
   * The URIs of extensions that are relevant to this artifact.
   */
  extensions?: string[];
  /**
   * Optional metadata for extensions. The key is an extension-specific identifier.
   */
  metadata?: {
    [k: string]: unknown;
  };
  /**
   * An optional, human-readable name for the artifact.
   */
  name?: string;
  /**
   * An array of content parts that make up the artifact.
   */
  parts: Part[];
}
‚ãÆ----
/**
   * A unique identifier for the artifact within the scope of the task.
   */
‚ãÆ----
/**
   * An optional, human-readable description of the artifact.
   */
‚ãÆ----
/**
   * The URIs of extensions that are relevant to this artifact.
   */
‚ãÆ----
/**
   * Optional metadata for extensions. The key is an extension-specific identifier.
   */
‚ãÆ----
/**
   * An optional, human-readable name for the artifact.
   */
‚ãÆ----
/**
   * An array of content parts that make up the artifact.
   */
‚ãÆ----
/**
 * Represents a successful JSON-RPC response for the `tasks/pushNotificationConfig/set` method.
 *
 * This interface was referenced by `MySchema`'s JSON-Schema
 * via the `definition` "SetTaskPushNotificationConfigSuccessResponse".
 */
export interface SetTaskPushNotificationConfigSuccessResponse {
  /**
   * The identifier established by the client.
   */
  id: string | number | null;
  /**
   * The version of the JSON-RPC protocol. MUST be exactly "2.0".
   */
  jsonrpc: "2.0";
  result: TaskPushNotificationConfig2;
}
‚ãÆ----
/**
   * The identifier established by the client.
   */
‚ãÆ----
/**
   * The version of the JSON-RPC protocol. MUST be exactly "2.0".
   */
‚ãÆ----
/**
 * The result, containing the configured push notification settings.
 */
export interface TaskPushNotificationConfig2 {
  pushNotificationConfig: PushNotificationConfig1;
  /**
   * The ID of the task.
   */
  taskId: string;
}
‚ãÆ----
/**
   * The ID of the task.
   */
‚ãÆ----
/**
 * Represents a successful JSON-RPC response for the `tasks/pushNotificationConfig/list` method.
 *
 * This interface was referenced by `MySchema`'s JSON-Schema
 * via the `definition` "ListTaskPushNotificationConfigSuccessResponse".
 */
export interface ListTaskPushNotificationConfigSuccessResponse {
  /**
   * The identifier established by the client.
   */
  id: string | number | null;
  /**
   * The version of the JSON-RPC protocol. MUST be exactly "2.0".
   */
  jsonrpc: "2.0";
  /**
   * The result, containing an array of all push notification configurations for the task.
   */
  result: TaskPushNotificationConfig3[];
}
‚ãÆ----
/**
   * The identifier established by the client.
   */
‚ãÆ----
/**
   * The version of the JSON-RPC protocol. MUST be exactly "2.0".
   */
‚ãÆ----
/**
   * The result, containing an array of all push notification configurations for the task.
   */
‚ãÆ----
/**
 * A container associating a push notification configuration with a specific task.
 *
 * This interface was referenced by `MySchema`'s JSON-Schema
 * via the `definition` "TaskPushNotificationConfig".
 */
export interface TaskPushNotificationConfig3 {
  pushNotificationConfig: PushNotificationConfig1;
  /**
   * The ID of the task.
   */
  taskId: string;
}
‚ãÆ----
/**
   * The ID of the task.
   */
‚ãÆ----
/**
 * Represents a successful JSON-RPC 2.0 Response object.
 *
 * This interface was referenced by `MySchema`'s JSON-Schema
 * via the `definition` "JSONRPCSuccessResponse".
 */
export interface JSONRPCSuccessResponse {
  /**
   * The identifier established by the client.
   */
  id: string | number | null;
  /**
   * The version of the JSON-RPC protocol. MUST be exactly "2.0".
   */
  jsonrpc: "2.0";
  /**
   * The value of this member is determined by the method invoked on the Server.
   */
  result: {
    [k: string]: unknown;
  };
}
‚ãÆ----
/**
   * The identifier established by the client.
   */
‚ãÆ----
/**
   * The version of the JSON-RPC protocol. MUST be exactly "2.0".
   */
‚ãÆ----
/**
   * The value of this member is determined by the method invoked on the Server.
   */
‚ãÆ----
/**
 * Defines parameters for listing all push notification configurations associated with a task.
 *
 * This interface was referenced by `MySchema`'s JSON-Schema
 * via the `definition` "ListTaskPushNotificationConfigParams".
 */
export interface ListTaskPushNotificationConfigParams1 {
  /**
   * The unique identifier of the task.
   */
  id: string;
  /**
   * Optional metadata associated with the request.
   */
  metadata?: {
    [k: string]: unknown;
  };
}
‚ãÆ----
/**
   * The unique identifier of the task.
   */
‚ãÆ----
/**
   * Optional metadata associated with the request.
   */
‚ãÆ----
/**
 * Defines configuration options for a `message/send` or `message/stream` request.
 *
 * This interface was referenced by `MySchema`'s JSON-Schema
 * via the `definition` "MessageSendConfiguration".
 */
export interface MessageSendConfiguration1 {
  /**
   * A list of output MIME types the client is prepared to accept in the response.
   */
  acceptedOutputModes?: string[];
  /**
   * If true, the client will wait for the task to complete. The server may reject this if the task is long-running.
   */
  blocking?: boolean;
  /**
   * The number of most recent messages from the task's history to retrieve in the response.
   */
  historyLength?: number;
  pushNotificationConfig?: PushNotificationConfig;
}
‚ãÆ----
/**
   * A list of output MIME types the client is prepared to accept in the response.
   */
‚ãÆ----
/**
   * If true, the client will wait for the task to complete. The server may reject this if the task is long-running.
   */
‚ãÆ----
/**
   * The number of most recent messages from the task's history to retrieve in the response.
   */
‚ãÆ----
/**
 * Defines the parameters for a request to send a message to an agent. This can be used
 * to create a new task, continue an existing one, or restart a task.
 *
 * This interface was referenced by `MySchema`'s JSON-Schema
 * via the `definition` "MessageSendParams".
 */
export interface MessageSendParams2 {
  configuration?: MessageSendConfiguration;
  message: Message;
  /**
   * Optional metadata for extensions.
   */
  metadata?: {
    [k: string]: unknown;
  };
}
‚ãÆ----
/**
   * Optional metadata for extensions.
   */
‚ãÆ----
/**
 * Defines the configuration for the supported OAuth 2.0 flows.
 *
 * This interface was referenced by `MySchema`'s JSON-Schema
 * via the `definition` "OAuthFlows".
 */
export interface OAuthFlows1 {
  authorizationCode?: AuthorizationCodeOAuthFlow;
  clientCredentials?: ClientCredentialsOAuthFlow;
  implicit?: ImplicitOAuthFlow;
  password?: PasswordOAuthFlow;
}
/**
 * Defines base properties common to all message or artifact parts.
 *
 * This interface was referenced by `MySchema`'s JSON-Schema
 * via the `definition` "PartBase".
 */
export interface PartBase {
  /**
   * Optional metadata associated with this part.
   */
  metadata?: {
    [k: string]: unknown;
  };
}
‚ãÆ----
/**
   * Optional metadata associated with this part.
   */
‚ãÆ----
/**
 * Defines configuration details for the OAuth 2.0 Resource Owner Password flow.
 *
 * This interface was referenced by `MySchema`'s JSON-Schema
 * via the `definition` "PasswordOAuthFlow".
 */
export interface PasswordOAuthFlow1 {
  /**
   * The URL to be used for obtaining refresh tokens. This MUST be a URL.
   */
  refreshUrl?: string;
  /**
   * The available scopes for the OAuth2 security scheme. A map between the scope
   * name and a short description for it.
   */
  scopes: {
    [k: string]: string;
  };
  /**
   * The token URL to be used for this flow. This MUST be a URL.
   */
  tokenUrl: string;
}
‚ãÆ----
/**
   * The URL to be used for obtaining refresh tokens. This MUST be a URL.
   */
‚ãÆ----
/**
   * The available scopes for the OAuth2 security scheme. A map between the scope
   * name and a short description for it.
   */
‚ãÆ----
/**
   * The token URL to be used for this flow. This MUST be a URL.
   */
‚ãÆ----
/**
 * Defines authentication details for a push notification endpoint.
 *
 * This interface was referenced by `MySchema`'s JSON-Schema
 * via the `definition` "PushNotificationAuthenticationInfo".
 */
export interface PushNotificationAuthenticationInfo1 {
  /**
   * Optional credentials required by the push notification endpoint.
   */
  credentials?: string;
  /**
   * A list of supported authentication schemes (e.g., 'Basic', 'Bearer').
   */
  schemes: string[];
}
‚ãÆ----
/**
   * Optional credentials required by the push notification endpoint.
   */
‚ãÆ----
/**
   * A list of supported authentication schemes (e.g., 'Basic', 'Bearer').
   */
‚ãÆ----
/**
 * Defines the configuration for setting up push notifications for task updates.
 *
 * This interface was referenced by `MySchema`'s JSON-Schema
 * via the `definition` "PushNotificationConfig".
 */
export interface PushNotificationConfig2 {
  authentication?: PushNotificationAuthenticationInfo;
  /**
   * A unique ID for the push notification configuration, set by the client
   * to support multiple notification callbacks.
   */
  id?: string;
  /**
   * A unique token for this task or session to validate incoming push notifications.
   */
  token?: string;
  /**
   * The callback URL where the agent should send push notifications.
   */
  url: string;
}
‚ãÆ----
/**
   * A unique ID for the push notification configuration, set by the client
   * to support multiple notification callbacks.
   */
‚ãÆ----
/**
   * A unique token for this task or session to validate incoming push notifications.
   */
‚ãÆ----
/**
   * The callback URL where the agent should send push notifications.
   */
‚ãÆ----
/**
 * Defines base properties shared by all security scheme objects.
 *
 * This interface was referenced by `MySchema`'s JSON-Schema
 * via the `definition` "SecuritySchemeBase".
 */
export interface SecuritySchemeBase {
  /**
   * An optional description for the security scheme.
   */
  description?: string;
}
‚ãÆ----
/**
   * An optional description for the security scheme.
   */
‚ãÆ----
/**
 * Defines parameters for querying a task, with an option to limit history length.
 *
 * This interface was referenced by `MySchema`'s JSON-Schema
 * via the `definition` "TaskQueryParams".
 */
export interface TaskQueryParams1 {
  /**
   * The number of most recent messages from the task's history to retrieve.
   */
  historyLength?: number;
  /**
   * The unique identifier of the task.
   */
  id: string;
  /**
   * Optional metadata associated with the request.
   */
  metadata?: {
    [k: string]: unknown;
  };
}
‚ãÆ----
/**
   * The number of most recent messages from the task's history to retrieve.
   */
‚ãÆ----
/**
   * The unique identifier of the task.
   */
‚ãÆ----
/**
   * Optional metadata associated with the request.
   */
‚ãÆ----
/**
 * Represents the status of a task at a specific point in time.
 *
 * This interface was referenced by `MySchema`'s JSON-Schema
 * via the `definition` "TaskStatus".
 */
export interface TaskStatus2 {
  message?: Message2;
  /**
   * The current state of the task's lifecycle.
   */
  state:
    | "submitted"
    | "working"
    | "input-required"
    | "completed"
    | "canceled"
    | "failed"
    | "rejected"
    | "auth-required"
    | "unknown";
  /**
   * An ISO 8601 datetime string indicating when this status was recorded.
   */
  timestamp?: string;
}
‚ãÆ----
/**
   * The current state of the task's lifecycle.
   */
‚ãÆ----
/**
   * An ISO 8601 datetime string indicating when this status was recorded.
   */

================
File: test/server/default_request_handler.spec.ts
================
import { assert, expect } from 'chai';
import sinon, { SinonStub, SinonFakeTimers } from 'sinon';
‚ãÆ----
import { AgentExecutor } from '../../src/server/agent_execution/agent_executor.js';
import { RequestContext, ExecutionEventBus, TaskStore, InMemoryTaskStore, DefaultRequestHandler, ExecutionEventQueue, A2AError } from '../../src/server/index.js';
import { AgentCard, Artifact, DeleteTaskPushNotificationConfigParams, GetTaskPushNotificationConfigParams, ListTaskPushNotificationConfigParams, Message, MessageSendParams, PushNotificationConfig, Task, TaskIdParams, TaskPushNotificationConfig, TaskState, TaskStatusUpdateEvent } from '../../src/index.js';
import { DefaultExecutionEventBusManager, ExecutionEventBusManager } from '../../src/server/events/execution_event_bus_manager.js';
import { A2ARequestHandler } from '../../src/server/request_handler/a2a_request_handler.js';
‚ãÆ----
/**
 * A realistic mock of AgentExecutor for cancellation tests.
 */
class CancellableMockAgentExecutor implements AgentExecutor
‚ãÆ----
constructor(clock: SinonFakeTimers)
‚ãÆ----
// Simulate a long-running process
‚ãÆ----
// Use fake timers to simulate work
‚ãÆ----
// The execute loop is responsible for publishing the final state
‚ãÆ----
// Stub for spying on cancelTask calls
‚ãÆ----
// Before each test, reset the components to a clean state
‚ãÆ----
// Default mock for most tests
‚ãÆ----
// After each test, restore any sinon fakes or stubs
‚ãÆ----
// Helper function to create a basic user message
const createTestMessage = (id: string, text: string): Message => (
‚ãÆ----
/**
     * A mock implementation of AgentExecutor to control agent behavior during tests.
     */
class MockAgentExecutor implements AgentExecutor
‚ãÆ----
// Stubs to control and inspect calls to execute and cancelTask
‚ãÆ----
// Test blocking case
‚ãÆ----
// First event is the task creation, which should be returned immediately
‚ãÆ----
// Simulate work before publishing more events
‚ãÆ----
// This call should return as soon as the first 'task' event is published
‚ãÆ----
// Assert that we got the initial task object back right away
‚ãÆ----
// The background processing should not have completed yet
‚ãÆ----
// Allow the background processing to complete
‚ãÆ----
// Now, check the final state in the store to ensure background processing finished
‚ãÆ----
// Test non-blocking case
‚ãÆ----
expect(error.code).to.equal(-32600); // Invalid Request
‚ãÆ----
const collect = async (iterator: AsyncGenerator<any>, results: any[]) =>
‚ãÆ----
// First event of resubscribe is always a task.
‚ãÆ----
// Config ID defaults to task ID
‚ãÆ----
expect(error.code).to.equal(-32001); // Task Not Found
‚ãÆ----
expect(error.code).to.equal(-32003); // Push Notification Not Supported
‚ãÆ----
// Use the more advanced mock for this specific test
‚ãÆ----
// Allow the task to be created and enter the 'working' state
‚ãÆ----
// Now, issue the cancel request
‚ãÆ----
// Let the executor's loop run to completion to detect the cancellation
‚ãÆ----
// Canceled API issues cancel request to executor and returns latest task state.
// In this scenario, executor is waiting on clock to detect that task has been cancelled.
// While the cancel API has returned with latest task state => Working.

================
File: .gitignore
================
# Byte-compiled / optimized / DLL files
__pycache__/
*.py[cod]
*.pyc
*$py.class
**/dist
/tmp
/out-tsc
/bazel-out

# C extensions
*.so

# Distribution / packaging
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
pip-wheel-metadata/
share/python-wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST

# PyInstaller
#  Usually these files are written by a python script from a template
#  before PyInstaller builds the exe, so as to inject date/other infos into it.
*.manifest
*.spec

# Installer logs
pip-log.txt
pip-delete-this-directory.txt

# Unit test / coverage reports
htmlcov/
.tox/
.nox/
.coverage
.coverage.*
.cache
nosetests.xml
coverage.xml
*.cover
*.py,cover
.hypothesis/
.pytest_cache/

# Translations
*.mo
*.pot

# Django stuff:
*.log
local_settings.py
db.sqlite3
db.sqlite3-journal

# Flask stuff:
instance/
.webassets-cache

# Scrapy stuff:
.scrapy

# Sphinx documentation
docs/_build/

# PyBuilder
target/

# Jupyter Notebook
.ipynb_checkpoints

# IPython
profile_default/
ipython_config.py

# pyenv
.python-version

# pipenv
#   According to pypa/pipenv#598, it is recommended to include Pipfile.lock in version control.
#   However, in case of collaboration, if having platform-specific dependencies or dependencies
#   having no cross-platform support, pipenv may install dependencies that don't work, or not
#   install all needed dependencies.
Pipfile.lock
Pipfile

# PEP 582; used by e.g. github.com/David-OConnor/pyflow
__pypackages__/

# Celery stuff
celerybeat-schedule
celerybeat.pid

# SageMath parsed files
*.sage.py

# Environments
.env
.venv
.venv*
env/
venv/
ENV/
env.bak/
venv.bak/

# Spyder project settings
.spyderproject
.spyproject

# Rope project settings
.ropeproject

# mkdocs documentation
/site

# mypy
.mypy_cache/
.dmypy.json
dmypy.json

# Pyre type checker
.pyre/

# macOS
.DS_Store

# PyCharm
.idea

# User-specific files
language/examples/prompt-design/train.csv
README-TOC*.md

# Terraform
terraform.tfstate**
.terraform*
.Terraform*

tmp*

# Node
**/node_modules
npm-debug.log
yarn-error.log

# IDEs and editors
.idea/
.project
.classpath
.c9/
*.launch
.settings/
*.sublime-workspace

# Miscellaneous
**/.angular/*
/.angular/cache
.sass-cache/
/connect.lock
/coverage
/libpeerconnection.log
testem.log
/typings

# System files
.DS_Store
Thumbs.db

================
File: CHANGELOG.md
================
# Changelog

## [0.3.1](https://github.com/a2aproject/a2a-js/compare/v0.3.0...v0.3.1) (2025-08-06)


### Bug Fixes

* add missing express entrypoint to tsup config ([#96](https://github.com/a2aproject/a2a-js/issues/96)) ([8e990e4](https://github.com/a2aproject/a2a-js/commit/8e990e497927e3554699f8ebb005829b170d9bc3))

## [0.3.0](https://github.com/a2aproject/a2a-js/compare/v0.2.5...v0.3.0) (2025-08-05)


### ‚ö† BREAKING CHANGES

* upgrade to a2a 0.3.0 spec version ([#87](https://github.com/a2aproject/a2a-js/issues/87))
* make Express dependency optional

### Features

* make Express dependency optional ([60899c5](https://github.com/a2aproject/a2a-js/commit/60899c51e2910570402d1207f6b50952bed8862f))
* upgrade to a2a 0.3.0 spec version ([#87](https://github.com/a2aproject/a2a-js/issues/87)) ([ae53da1](https://github.com/a2aproject/a2a-js/commit/ae53da1e36ff58912e01fefa854c5b3174edf7d8))

## [0.2.5](https://github.com/a2aproject/a2a-js/compare/v0.2.4...v0.2.5) (2025-07-30)


### Features

* add support for custom agent card url. resolves [#68](https://github.com/a2aproject/a2a-js/issues/68) ([#79](https://github.com/a2aproject/a2a-js/issues/79)) ([dc92d32](https://github.com/a2aproject/a2a-js/commit/dc92d321ac7c142ff5232cdca0db8a24b4d76da0))
* Export ExecutionEventQueue in server ([#61](https://github.com/a2aproject/a2a-js/issues/61)) ([530c0b9](https://github.com/a2aproject/a2a-js/commit/530c0b9f1fd50fafd991f640c119837860ae8c3f))
* Export type AgentExecutionEvent ([#66](https://github.com/a2aproject/a2a-js/issues/66)) ([f4c81f4](https://github.com/a2aproject/a2a-js/commit/f4c81f41866c24d83823b5db7d24b5fdb56b37b4))


### Bug Fixes

* correct the example code ([#64](https://github.com/a2aproject/a2a-js/issues/64)) ([126eee4](https://github.com/a2aproject/a2a-js/commit/126eee4e3b79e9475a5af5cbebb0e98b68f286fa))
* setting context id in _createRequestContext ([#49](https://github.com/a2aproject/a2a-js/issues/49)) ([1abc8a1](https://github.com/a2aproject/a2a-js/commit/1abc8a1f3590f78647d94c5a1e31444203e1131f))

## [0.2.4](https://github.com/a2aproject/a2a-js/compare/v0.2.3...v0.2.4) (2025-07-14)


### Miscellaneous Chores

* fix empty npm publish by version-bump ([#56](https://github.com/a2aproject/a2a-js/issues/56)) ([b12e033](https://github.com/a2aproject/a2a-js/commit/b12e033ed8ffc823672d68d749344247ee0914ee))

## [0.2.3](https://github.com/a2aproject/a2a-js/compare/v0.2.2...v0.2.3) (2025-07-14)


### ‚ö† BREAKING CHANGES

* separate entrypoints for client, server & common

### Features

* add CommonJS support alongside ESM ([#27](https://github.com/a2aproject/a2a-js/issues/27)) ([1b3e516](https://github.com/a2aproject/a2a-js/commit/1b3e516e2ba6058eddd84943b07616cf5b74f5b0))
* Allow adding middlewares in server ([#51](https://github.com/a2aproject/a2a-js/issues/51)) ([b4fc323](https://github.com/a2aproject/a2a-js/commit/b4fc323c1f607622ee7841c95c1e401cf79df186))
* separate entrypoints for client, server & common ([e8dd025](https://github.com/a2aproject/a2a-js/commit/e8dd0250847c1e628a1c932f1ba4cc5c57064714))

## [0.2.2](https://github.com/google-a2a/a2a-js/compare/v0.2.1...v0.2.2) (2025-06-20)


### Features

* add action to publish to npm ([e4ab96e](https://github.com/google-a2a/a2a-js/commit/e4ab96ed4f875cc3079534637fbf88f9adad7f74))
* add sample agent ([#19](https://github.com/google-a2a/a2a-js/issues/19)) ([1f21a0a](https://github.com/google-a2a/a2a-js/commit/1f21a0a8662550547c1703d33e71f5cf7bd28d6b))
* add test coverage ([#20](https://github.com/google-a2a/a2a-js/issues/20)) ([7bde9cd](https://github.com/google-a2a/a2a-js/commit/7bde9cd839c015e270719d312df18ddc0c6f34b0))
* generate types from spec & use unknown in types ([#17](https://github.com/google-a2a/a2a-js/issues/17)) ([748f928](https://github.com/google-a2a/a2a-js/commit/748f9283a8e93d6104e29309f27d83fb2f9193e0))
* reject sendMessage for tasks in terminal states ([#29](https://github.com/google-a2a/a2a-js/issues/29)) ([9f86195](https://github.com/google-a2a/a2a-js/commit/9f86195d01fada7f041df0199cf93bcff2da8b80))
* Supply taskId & contextId in requestContext ([#22](https://github.com/google-a2a/a2a-js/issues/22)) ([79db7f4](https://github.com/google-a2a/a2a-js/commit/79db7f48cac482b176f2297ca374e1e937eda1d0))
* support non-blocking message send ([#28](https://github.com/google-a2a/a2a-js/issues/28)) ([6984dbb](https://github.com/google-a2a/a2a-js/commit/6984dbb3655a71bb540e6c14cb2f4792a4556fad))
* use string union instead of enums ([#24](https://github.com/google-a2a/a2a-js/issues/24)) ([bcc1f7e](https://github.com/google-a2a/a2a-js/commit/bcc1f7e0e14065163dacf3f60e74c7bb501f243e))

## 0.2.1 (2025-06-06)


### Features

* Add cancelTask to executor & finished to eventBus ([831c393](https://github.com/google-a2a/a2a-js/commit/831c3937ba59e0b4c2fdfd9577f506921929034a))
* Add sdk files for client & server ([00fe8cd](https://github.com/google-a2a/a2a-js/commit/00fe8cd33db4d5464a320dc2d16fd483b5a2fbbf))
* add sdk/tests for client & server ([a921c98](https://github.com/google-a2a/a2a-js/commit/a921c98946ba4e0636d9d6d320918e1fcb3ba5aa))
* add tests for all APIs ([e6281ca](https://github.com/google-a2a/a2a-js/commit/e6281caa131ebcc247cf750f597ead2ea28f2c3d))


### Bug Fixes

* library should released as 0.2.1 ([#8](https://github.com/google-a2a/a2a-js/issues/8)) ([0335732](https://github.com/google-a2a/a2a-js/commit/033573295e0ab8115d2fcd0c64a0bd5df1537b67))

================
File: CODE_OF_CONDUCT.md
================
# Code of Conduct

## Our Pledge

In the interest of fostering an open and welcoming environment, we as
contributors and maintainers pledge to making participation in our project and
our community a harassment-free experience for everyone, regardless of age, body
size, disability, ethnicity, gender identity and expression, level of
experience, education, socio-economic status, nationality, personal appearance,
race, religion, or sexual identity and orientation.

## Our Standards

Examples of behavior that contributes to creating a positive environment
include:

*   Using welcoming and inclusive language
*   Being respectful of differing viewpoints and experiences
*   Gracefully accepting constructive criticism
*   Focusing on what is best for the community
*   Showing empathy towards other community members

Examples of unacceptable behavior by participants include:

*   The use of sexualized language or imagery and unwelcome sexual attention or
    advances
*   Trolling, insulting/derogatory comments, and personal or political attacks
*   Public or private harassment
*   Publishing others' private information, such as a physical or electronic
    address, without explicit permission
*   Other conduct which could reasonably be considered inappropriate in a
    professional setting

## Our Responsibilities

Project maintainers are responsible for clarifying the standards of acceptable
behavior and are expected to take appropriate and fair corrective action in
response to any instances of unacceptable behavior.

Project maintainers have the right and responsibility to remove, edit, or reject
comments, commits, code, wiki edits, issues, and other contributions that are
not aligned to this Code of Conduct, or to ban temporarily or permanently any
contributor for other behaviors that they deem inappropriate, threatening,
offensive, or harmful.

## Scope

This Code of Conduct applies both within project spaces and in public spaces
when an individual is representing the project or its community. Examples of
representing a project or community include using an official project e-mail
address, posting via an official social media account, or acting as an appointed
representative at an online or offline event. Representation of a project may be
further defined and clarified by project maintainers.

This Code of Conduct also applies outside the project spaces when the Project
Steward has a reasonable belief that an individual's behavior may have a
negative impact on the project or its community.

## Conflict Resolution

We do not believe that all conflict is bad; healthy debate and disagreement
often yield positive results. However, it is never okay to be disrespectful or
to engage in behavior that violates the project‚Äôs code of conduct.

If you see someone violating the code of conduct, you are encouraged to address
the behavior directly with those involved. Many issues can be resolved quickly
and easily, and this gives people more control over the outcome of their
dispute. If you are unable to resolve the matter for any reason, or if the
behavior is threatening or harassing, report it. We are dedicated to providing
an environment where participants feel welcome and safe.

Reports should be directed to *[PROJECT STEWARD NAME(s) AND EMAIL(s)]*, the
Project Steward(s) for *[PROJECT NAME]*. It is the Project Steward‚Äôs duty to
receive and address reported violations of the code of conduct. They will then
work with a committee consisting of representatives from the Open Source
Programs Office and the Google Open Source Strategy team. If for any reason you
are uncomfortable reaching out to the Project Steward, please email
opensource@google.com.

We will investigate every complaint, but you may not receive a direct response.
We will use our discretion in determining when and how to follow up on reported
incidents, which may range from not taking action to permanent expulsion from
the project and project-sponsored spaces. We will notify the accused of the
report and provide them an opportunity to discuss it before any action is taken.
The identity of the reporter will be omitted from the details of the report
supplied to the accused. In potentially harmful situations, such as ongoing
harassment or threats to anyone's safety, we may take action without notice.

## Attribution

This Code of Conduct is adapted from the Contributor Covenant, version 1.4,
available at
https://www.contributor-covenant.org/version/1/4/code-of-conduct.html

Note: A version of this file is also available in the
[New Project repo](https://github.com/google/new-project/blob/master/docs/code-of-conduct.md).

================
File: CONTRIBUTING.md
================
# How to contribute

We'd love to accept your patches and contributions to this project.

## Before you begin

### Sign our Contributor License Agreement

Contributions to this project must be accompanied by a
[Contributor License Agreement](https://cla.developers.google.com/about) (CLA).
You (or your employer) retain the copyright to your contribution; this simply
gives us permission to use and redistribute your contributions as part of the
project.

If you or your current employer have already signed the Google CLA (even if it
was for a different project), you probably don't need to do it again.

Visit <https://cla.developers.google.com/> to see your current agreements or to
sign a new one.

### Review our community guidelines

This project follows
[Google's Open Source Community Guidelines](https://opensource.google/conduct/).

## Contribution process

### Code reviews

All submissions, including submissions by project members, require review. We
use GitHub pull requests for this purpose. Consult
[GitHub Help](https://help.github.com/articles/about-pull-requests/) for more
information on using pull requests.

### Contributor Guide

You may follow these steps to contribute:

1. **Fork the official repository.** This will create a copy of the official repository in your own account.
2. **Sync the branches.** This will ensure that your copy of the repository is up-to-date with the latest changes from the official repository.
3. **Work on your forked repository's feature branch.** This is where you will make your changes to the code.
4. **Commit your updates on your forked repository's feature branch.** This will save your changes to your copy of the repository.
5. **Submit a pull request to the official repository's main branch.** This will request that your changes be merged into the official repository.
6. **Resolve any linting errors.** This will ensure that your changes are formatted correctly.

Here are some additional things to keep in mind during the process:

- **Test your changes.** Before you submit a pull request, make sure that your changes work as expected.
- **Be patient.** It may take some time for your pull request to be reviewed and merged.

---

## For Google Employees

Complete the following steps to register your GitHub account and be added as a contributor to this repository.

1. Register your GitHub account at [go/GitHub](http://go/github)

================
File: LICENSE
================
Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "[]"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright [yyyy] [name of copyright owner]

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

================
File: package.json
================
{
  "name": "@a2a-js/sdk",
  "version": "0.3.1",
  "description": "Server & Client SDK for Agent2Agent protocol",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/a2aproject/a2a-js.git"
  },
  "engines": {
    "node": ">=18"
  },
  "main": "dist/index.js",
  "types": "dist/index.d.ts",
  "type": "module",
  "exports": {
    ".": {
      "types": "./dist/index.d.ts",
      "import": "./dist/index.js",
      "require": "./dist/index.cjs"
    },
    "./server": {
      "types": "./dist/server/index.d.ts",
      "import": "./dist/server/index.js",
      "require": "./dist/server/index.cjs"
    },
    "./server/express": {
      "types": "./dist/server/express/index.d.ts",
      "import": "./dist/server/express/index.js",
      "require": "./dist/server/express/index.cjs"
    },
    "./client": {
      "types": "./dist/client/index.d.ts",
      "import": "./dist/client/index.js",
      "require": "./dist/client/index.cjs"
    }
  },
  "files": [
    "dist",
    "!dist/**/*.map",
    "README.md"
  ],
  "devDependencies": {
    "@genkit-ai/googleai": "^1.8.0",
    "@genkit-ai/vertexai": "^1.8.0",
    "@types/chai": "^5.2.2",
    "@types/express": "^4.17.23",
    "@types/mocha": "^10.0.10",
    "@types/node": "^22.13.14",
    "@types/sinon": "^17.0.4",
    "c8": "^10.1.3",
    "chai": "^5.2.0",
    "express": "^4.21.2",
    "genkit": "^1.8.0",
    "gts": "^6.0.2",
    "json-schema-to-typescript": "^15.0.4",
    "mocha": "^11.6.0",
    "sinon": "^20.0.0",
    "tsup": "^8.5.0",
    "tsx": "^4.19.3",
    "typescript": "^5.8.2"
  },
  "scripts": {
    "clean": "gts clean",
    "build": "tsup",
    "pretest": "npm run build",
    "test": "mocha test/**/*.spec.ts",
    "coverage": "c8 npm run test",
    "generate": "curl https://raw.githubusercontent.com/google-a2a/A2A/refs/heads/main/specification/json/a2a.json > spec.json && node scripts/generateTypes.js && rm spec.json",
    "sample:cli": "tsx src/samples/cli.ts",
    "sample:movie-agent": "tsx src/samples/agents/movie-agent/index.ts"
  },
  "dependencies": {
    "uuid": "^11.1.0"
  },
  "peerDependencies": {
    "express": "^4.21.2"
  },
  "peerDependenciesMeta": {
    "express": {
      "optional": true
    }
  },
  "mocha": {
    "require": "tsx"
  }
}

================
File: README.md
================
# A2A JavaScript SDK

[![License](https://img.shields.io/badge/License-Apache_2.0-blue.svg)](LICENSE)

<!-- markdownlint-disable no-inline-html -->

<html>
   <h2 align="center">
   <img src="https://raw.githubusercontent.com/google-a2a/A2A/refs/heads/main/docs/assets/a2a-logo-black.svg" width="256" alt="A2A Logo"/>
   </h2>
   <h3 align="center">A JavaScript library that helps run agentic applications as A2AServers following the <a href="https://google-a2a.github.io/A2A">Agent2Agent (A2A) Protocol</a>.</h3>
</html>

<!-- markdownlint-enable no-inline-html -->

## Installation

You can install the A2A SDK using either `npm`.

```bash
npm install @a2a-js/sdk
```

### For Server Usage

If you plan to use the A2A server functionality (A2AExpressApp), you'll also need to install Express as it's a peer dependency:

```bash
npm install express
```

You can also find JavaScript samples [here](https://github.com/google-a2a/a2a-samples/tree/main/samples/js).

## A2A Server

This directory contains a TypeScript server implementation for the Agent-to-Agent (A2A) communication protocol, built using Express.js.

**Note:** Express is a peer dependency for server functionality. Make sure to install it separately:
```bash
npm install express
```

### 1. Define Agent Card

```typescript
import type { AgentCard } from "@a2a-js/sdk";

const movieAgentCard: AgentCard = {
  name: "Movie Agent",
  description:
    "An agent that can answer questions about movies and actors using TMDB.",
  // Adjust the base URL and port as needed.
  url: "http://localhost:41241/",
  provider: {
    organization: "A2A Agents",
    url: "https://example.com/a2a-agents", // Added provider URL
  },
  protocolVersion: "0.3.0", // A2A protocol this agent supports.
  version: "0.0.2", // Incremented version
  capabilities: {
    streaming: true, // Supports streaming
    pushNotifications: false, // Assuming not implemented for this agent yet
    stateTransitionHistory: true, // Agent uses history
  },
  securitySchemes: undefined, // Or define actual security schemes if any
  security: undefined,
  defaultInputModes: ["text/plain"],
  defaultOutputModes: ["text/plain"],
  skills: [
    {
      id: "general_movie_chat",
      name: "General Movie Chat",
      description:
        "Answer general questions or chat about movies, actors, directors.",
      tags: ["movies", "actors", "directors"],
      examples: [
        "Tell me about the plot of Inception.",
        "Recommend a good sci-fi movie.",
        "Who directed The Matrix?",
        "What other movies has Scarlett Johansson been in?",
        "Find action movies starring Keanu Reeves",
        "Which came out first, Jurassic Park or Terminator 2?",
      ],
      inputModes: ["text/plain"], // Explicitly defining for skill
      outputModes: ["text/plain"], // Explicitly defining for skill
    },
  ],
  supportsAuthenticatedExtendedCard: false,
};
```

### 2. Define Agent Executor

```typescript
import {
  InMemoryTaskStore,
  TaskStore,
  AgentExecutor,
  RequestContext,
  ExecutionEventBus,
  DefaultRequestHandler,
} from "@a2a-js/sdk/server";
import { A2AExpressApp } from "@a2a-js/sdk/server/express";

// 1. Define your agent's logic as a AgentExecutor
class MyAgentExecutor implements AgentExecutor {
  private cancelledTasks = new Set<string>();

  public cancelTask = async (
    taskId: string,
    eventBus: ExecutionEventBus
  ): Promise<void> => {
    this.cancelledTasks.add(taskId);
    // The execute loop is responsible for publishing the final state
  };

  async execute(
    requestContext: RequestContext,
    eventBus: ExecutionEventBus
  ): Promise<void> {
    const userMessage = requestContext.userMessage;
    const existingTask = requestContext.task;

    // Determine IDs for the task and context, from requestContext.
    const taskId = requestContext.taskId;
    const contextId = requestContext.contextId;

    console.log(
      `[MyAgentExecutor] Processing message ${userMessage.messageId} for task ${taskId} (context: ${contextId})`
    );

    // 1. Publish initial Task event if it's a new task
    if (!existingTask) {
      const initialTask: Task = {
        kind: "task",
        id: taskId,
        contextId: contextId,
        status: {
          state: "submitted",
          timestamp: new Date().toISOString(),
        },
        history: [userMessage],
        metadata: userMessage.metadata,
        artifacts: [], // Initialize artifacts array
      };
      eventBus.publish(initialTask);
    }

    // 2. Publish "working" status update
    const workingStatusUpdate: TaskStatusUpdateEvent = {
      kind: "status-update",
      taskId: taskId,
      contextId: contextId,
      status: {
        state: "working",
        message: {
          kind: "message",
          role: "agent",
          messageId: uuidv4(),
          parts: [{ kind: "text", text: "Generating code..." }],
          taskId: taskId,
          contextId: contextId,
        },
        timestamp: new Date().toISOString(),
      },
      final: false,
    };
    eventBus.publish(workingStatusUpdate);

    // Simulate work...
    await new Promise((resolve) => setTimeout(resolve, 1000));

    // Check for request cancellation
    if (this.cancelledTasks.has(taskId)) {
      console.log(`[MyAgentExecutor] Request cancelled for task: ${taskId}`);
      const cancelledUpdate: TaskStatusUpdateEvent = {
        kind: "status-update",
        taskId: taskId,
        contextId: contextId,
        status: {
          state: "canceled",
          timestamp: new Date().toISOString(),
        },
        final: true,
      };
      eventBus.publish(cancelledUpdate);
      eventBus.finished();
      return;
    }

    // 3. Publish artifact update
    const artifactUpdate: TaskArtifactUpdateEvent = {
      kind: "artifact-update",
      taskId: taskId,
      contextId: contextId,
      artifact: {
        artifactId: "artifact-1",
        name: "artifact-1",
        parts: [{ kind: "text", text: `Task ${taskId} completed.` }],
      },
      append: false, // Each emission is a complete file snapshot
      lastChunk: true, // True for this file artifact
    };
    eventBus.publish(artifactUpdate);

    // 4. Publish final status update
    const finalUpdate: TaskStatusUpdateEvent = {
      kind: "status-update",
      taskId: taskId,
      contextId: contextId,
      status: {
        state: "completed",
        message: {
          kind: "message",
          role: "agent",
          messageId: uuidv4(),
          taskId: taskId,
          contextId: contextId,
        },
        timestamp: new Date().toISOString(),
      },
      final: true,
    };
    eventBus.publish(finalUpdate);
    eventBus.finished();
  }
}
```

### 3. Start the server

```typescript
const taskStore: TaskStore = new InMemoryTaskStore();
const agentExecutor: AgentExecutor = new MyAgentExecutor();

const requestHandler = new DefaultRequestHandler(
  coderAgentCard,
  taskStore,
  agentExecutor
);

const appBuilder = new A2AExpressApp(requestHandler);
const expressApp = appBuilder.setupRoutes(express(), "");

const PORT = process.env.CODER_AGENT_PORT || 41242; // Different port for coder agent
expressApp.listen(PORT, () => {
  console.log(
    `[MyAgent] Server using new framework started on http://localhost:${PORT}`
  );
  console.log(
    `[MyAgent] Agent Card: http://localhost:${PORT}/.well-known/agent-card.json`
  );
  console.log("[MyAgent] Press Ctrl+C to stop the server");
});
```

### Agent Executor

Developers are expected to implement this interface and provide two methods: `execute` and `cancelTask`.

#### `execute`

- This method is provided with a `RequestContext` and an `EventBus` to publish execution events.
- Executor can either respond by publishing a Message or Task.
- For a task, check if there's an existing task in `RequestContext`. If not, publish an initial Task event using `taskId` & `contextId` from `RequestContext`.
- Executor can subsequently publish `TaskStatusUpdateEvent` or `TaskArtifactUpdateEvent`.
- Executor should indicate which is the `final` event and also call `finished()` method of event bus.
- Executor should also check if an ongoing task has been cancelled. If yes, cancel the execution and emit an `TaskStatusUpdateEvent` with cancelled state.

#### `cancelTask`

Executors should implement cancellation mechanism for an ongoing task.

## A2A Client

There's a `A2AClient` class, which provides methods for interacting with an A2A server over HTTP using JSON-RPC.

### Key Features:

- **JSON-RPC Communication:** Handles sending requests and receiving responses (both standard and streaming via Server-Sent Events) according to the JSON-RPC 2.0 specification.
- **A2A Methods:** Implements standard A2A methods like `sendMessage`, `sendMessageStream`, `getTask`, `cancelTask`, `setTaskPushNotificationConfig`, `getTaskPushNotificationConfig`, and `resubscribeTask`.
- **Error Handling:** Provides basic error handling for network issues and JSON-RPC errors.
- **Streaming Support:** Manages Server-Sent Events (SSE) for real-time task updates (`sendMessageStream`, `resubscribeTask`).
- **Extensibility:** Allows providing a custom `fetch` implementation for different environments (e.g., Node.js).

### Basic Usage

```typescript
import { A2AClient } from "@a2a-js/sdk/client";
import type {
  Message,
  MessageSendParams,
  Task,
  TaskQueryParams,
  SendMessageResponse,
  GetTaskResponse,
  SendMessageSuccessResponse,
  GetTaskSuccessResponse,
} from "@a2a-js/sdk";
import { v4 as uuidv4 } from "uuid";

const client = new A2AClient("http://localhost:41241"); // Replace with your server URL

async function run() {
  const messageId = uuidv4();
  let taskId: string | undefined;

  try {
    // 1. Send a message to the agent.
    const sendParams: MessageSendParams = {
      message: {
        messageId: messageId,
        role: "user",
        parts: [{ kind: "text", text: "Hello, agent!" }],
        kind: "message",
      },
      configuration: {
        blocking: true,
        acceptedOutputModes: ["text/plain"],
      },
    };

    const sendResponse: SendMessageResponse =
      await client.sendMessage(sendParams);

    if (sendResponse.error) {
      console.error("Error sending message:", sendResponse.error);
      return;
    }

    // On success, the result can be a Task or a Message. Check which one it is.
    const result = (sendResponse as SendMessageSuccessResponse).result;

    if (result.kind === "task") {
      // The agent created a task.
      const taskResult = result as Task;
      console.log("Send Message Result (Task):", taskResult);
      taskId = taskResult.id; // Save the task ID for the next call
    } else if (result.kind === "message") {
      // The agent responded with a direct message.
      const messageResult = result as Message;
      console.log("Send Message Result (Direct Message):", messageResult);
      // No task was created, so we can't get task status.
    }

    // 2. If a task was created, get its status.
    if (taskId) {
      const getParams: TaskQueryParams = { id: taskId };
      const getResponse: GetTaskResponse = await client.getTask(getParams);

      if (getResponse.error) {
        console.error(`Error getting task ${taskId}:`, getResponse.error);
        return;
      }

      const getTaskResult = (getResponse as GetTaskSuccessResponse).result;
      console.log("Get Task Result:", getTaskResult);
    }
  } catch (error) {
    console.error("A2A Client Communication Error:", error);
  }
}

run();
```

### Streaming Usage

```typescript
import { A2AClient } from "@a2a-js/sdk/client";
import type {
  TaskStatusUpdateEvent,
  TaskArtifactUpdateEvent,
  MessageSendParams,
  Task,
  Message,
} from "@a2a-js/sdk";
import { v4 as uuidv4 } from "uuid";

const client = new A2AClient("http://localhost:41241");

async function streamTask() {
  const messageId = uuidv4();
  try {
    console.log(`\n--- Starting streaming task for message ${messageId} ---`);

    // Construct the `MessageSendParams` object.
    const streamParams: MessageSendParams = {
      message: {
        messageId: messageId,
        role: "user",
        parts: [{ kind: "text", text: "Stream me some updates!" }],
        kind: "message",
      },
    };

    // Use the `sendMessageStream` method.
    const stream = client.sendMessageStream(streamParams);
    let currentTaskId: string | undefined;

    for await (const event of stream) {
      // The first event is often the Task object itself, establishing the ID.
      if ((event as Task).kind === "task") {
        currentTaskId = (event as Task).id;
        console.log(
          `[${currentTaskId}] Task created. Status: ${(event as Task).status.state}`
        );
        continue;
      }

      // Differentiate subsequent stream events.
      if ((event as TaskStatusUpdateEvent).kind === "status-update") {
        const statusEvent = event as TaskStatusUpdateEvent;
        console.log(
          `[${statusEvent.taskId}] Status Update: ${statusEvent.status.state} - ${
            statusEvent.status.message?.parts[0]?.text ?? ""
          }`
        );
        if (statusEvent.final) {
          console.log(`[${statusEvent.taskId}] Stream marked as final.`);
          break; // Exit loop when server signals completion
        }
      } else if (
        (event as TaskArtifactUpdateEvent).kind === "artifact-update"
      ) {
        const artifactEvent = event as TaskArtifactUpdateEvent;
        // Use artifact.name or artifact.artifactId for identification
        console.log(
          `[${artifactEvent.taskId}] Artifact Update: ${
            artifactEvent.artifact.name ?? artifactEvent.artifact.artifactId
          } - Part Count: ${artifactEvent.artifact.parts.length}`
        );
      } else {
        // This could be a direct Message response if the agent doesn't create a task.
        console.log("Received direct message response in stream:", event);
      }
    }
    console.log(`--- Streaming for message ${messageId} finished ---`);
  } catch (error) {
    console.error(`Error during streaming for message ${messageId}:`, error);
  }
}

streamTask();
```

## License

This project is licensed under the terms of the [Apache 2.0 License](https://raw.githubusercontent.com/google-a2a/a2a-python/refs/heads/main/LICENSE).

## Contributing

See [CONTRIBUTING.md](https://github.com/google-a2a/a2a-js/blob/main/CONTRIBUTING.md) for contribution guidelines.

================
File: SECURITY.md
================
# Security Policy

To report a security issue, please use [g.co/vulnz](https://g.co/vulnz).

The Google Security Team will respond within 5 working days of your report on g.co/vulnz.

We use g.co/vulnz for our intake, and do coordination and disclosure here using GitHub Security Advisory to privately discuss and fix the issue.

================
File: tsconfig.json
================
{
  "compilerOptions": {
    "target": "es2022",
    "module": "NodeNext",
    "skipLibCheck": true,
    "rootDir": ".",
    "outDir": "build",
    "sourceMap": true,
    "declaration": true,
    "esModuleInterop": true, // Often helpful with NodeNext
    "resolveJsonModule": true // Good practice for importing JSON if needed
  },
  "include": ["src/**/*.ts", "test/**/*.ts"]
}

================
File: tsup.config.ts
================
import { defineConfig } from "tsup";




================================================================
End of Codebase
================================================================
